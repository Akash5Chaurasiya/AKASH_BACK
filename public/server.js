/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.server = void 0;\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst errorHandler_1 = __webpack_require__(/*! ./middleware/errorHandler */ \"./src/middleware/errorHandler.ts\");\nconst employeeRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/employeeRoutes */ \"./src/routes/employeeRoutes.ts\"));\nconst attendanceRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/attendanceRoutes */ \"./src/routes/attendanceRoutes.ts\"));\nconst groupRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/groupRoutes */ \"./src/routes/groupRoutes.ts\"));\nconst jobProfileRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/jobProfileRoutes */ \"./src/routes/jobProfileRoutes.ts\"));\nconst adminRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/adminRoutes */ \"./src/routes/adminRoutes.ts\"));\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ \"cors\"));\nconst node_cron_1 = __importDefault(__webpack_require__(/*! node-cron */ \"node-cron\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst cookie_parser_1 = __importDefault(__webpack_require__(/*! cookie-parser */ \"cookie-parser\"));\nconst employeeDocsRouters_1 = __importDefault(__webpack_require__(/*! ./routes/employeeDocsRouters */ \"./src/routes/employeeDocsRouters.ts\"));\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst leaveRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/leaveRoutes */ \"./src/routes/leaveRoutes.ts\"));\nconst authRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/authRoutes */ \"./src/routes/authRoutes.ts\"));\nconst socket_io_1 = __webpack_require__(/*! socket.io */ \"socket.io\");\nconst http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\n// import translate from \"google-translate-api\"\nconst app = (0, express_1.default)();\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst notificationModel_1 = __importDefault(__webpack_require__(/*! ./database/models/notificationModel */ \"./src/database/models/notificationModel.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ./database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ./database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ./database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst trainingRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/trainingRoutes */ \"./src/routes/trainingRoutes.ts\"));\nconst otpRouter_1 = __importDefault(__webpack_require__(/*! ./routes/otpRouter */ \"./src/routes/otpRouter.ts\"));\nconst quizRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/quizRoutes */ \"./src/routes/quizRoutes.ts\"));\nconst departmentRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/departmentRoutes */ \"./src/routes/departmentRoutes.ts\"));\nconst godownRouter_1 = __importDefault(__webpack_require__(/*! ./routes/godownRouter */ \"./src/routes/godownRouter.ts\"));\nconst gobalProcessRouter_1 = __importDefault(__webpack_require__(/*! ./routes/gobalProcessRouter */ \"./src/routes/gobalProcessRouter.ts\"));\nconst rawMaterialRouter_1 = __importDefault(__webpack_require__(/*! ./routes/rawMaterialRouter */ \"./src/routes/rawMaterialRouter.ts\"));\nconst childPartRouter_1 = __importDefault(__webpack_require__(/*! ./routes/childPartRouter */ \"./src/routes/childPartRouter.ts\"));\nconst finishedRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/finishedRoutes */ \"./src/routes/finishedRoutes.ts\"));\nconst customerRouter_1 = __importDefault(__webpack_require__(/*! ./routes/customerRouter */ \"./src/routes/customerRouter.ts\"));\nconst machineRouter_1 = __importDefault(__webpack_require__(/*! ./routes/machineRouter */ \"./src/routes/machineRouter.ts\"));\nconst workOrderRouter_1 = __importDefault(__webpack_require__(/*! ./routes/workOrderRouter */ \"./src/routes/workOrderRouter.ts\"));\nconst productionSlipRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/productionSlipRoutes */ \"./src/routes/productionSlipRoutes.ts\"));\nconst shopRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/shopRoutes */ \"./src/routes/shopRoutes.ts\"));\nconst v2AttendanceRouter_1 = __importDefault(__webpack_require__(/*! ./routes/v2AttendanceRouter */ \"./src/routes/v2AttendanceRouter.ts\"));\nconst inventoryRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/inventoryRoutes */ \"./src/routes/inventoryRoutes.ts\"));\nconst workingDayRouter_1 = __webpack_require__(/*! ./routes/workingDayRouter */ \"./src/routes/workingDayRouter.ts\");\nconst loggedInUserHistoryRouter_1 = __importDefault(__webpack_require__(/*! ./routes/loggedInUserHistoryRouter */ \"./src/routes/loggedInUserHistoryRouter.ts\"));\nconst CNCProgramRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/CNCProgramRoutes */ \"./src/routes/CNCProgramRoutes.ts\"));\nconst planningRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/planningRoutes */ \"./src/routes/planningRoutes.ts\"));\nconst salaryRouter_1 = __importDefault(__webpack_require__(/*! ./routes/salaryRouter */ \"./src/routes/salaryRouter.ts\"));\nconst translate_1 = __importDefault(__webpack_require__(/*! ./translate */ \"./src/translate.ts\"));\nconst activeController_1 = __webpack_require__(/*! ./controllers/employee/activeController */ \"./src/controllers/employee/activeController.ts\");\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"axios\"));\nconst scanSlipRouter_1 = __importDefault(__webpack_require__(/*! ./routes/scanSlipRouter */ \"./src/routes/scanSlipRouter.ts\"));\nconst productivityReportRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/productivityReportRoutes */ \"./src/routes/productivityReportRoutes.ts\"));\nconst salaryChangeController_1 = __webpack_require__(/*! ./controllers/employee/salaryChangeController */ \"./src/controllers/employee/salaryChangeController.ts\");\nconst salaryReportRoutes_1 = __importDefault(__webpack_require__(/*! ./routes/salaryReportRoutes */ \"./src/routes/salaryReportRoutes.ts\"));\n(0, dotenv_1.config)({ path: path_1.default.join(__dirname, \"..\", \"public/.env\") });\nconst FRONTEND_URI1 = process.env.FRONTEND_URI1;\nconst FRONTEND_URI2 = process.env.FRONTEND_URI2;\nconst FRONTEND_URI3 = process.env.FRONTEND_URI3;\nif (!FRONTEND_URI1 || !FRONTEND_URI2) {\n    throw new Error(\"Missing FRONTEND_URI1 or FRONTEND_URI2 environment variables\");\n}\n// middleware\napp.use(express_1.default.json({ limit: \"50mb\" }));\napp.use(express_1.default.urlencoded({ limit: '50mb', extended: true }));\napp.use((0, cors_1.default)({\n    credentials: true,\n    origin: [FRONTEND_URI1, FRONTEND_URI2, FRONTEND_URI3],\n}));\napp.use((0, cookie_parser_1.default)());\napp.use(express_1.default.static(path_1.default.join(__dirname, \"..\", \"builds\", \"hrms\")));\napp.use(express_1.default.static(path_1.default.join(__dirname, \"..\", \"builds\", \"productionApp\")));\n// adding websocket\nconst server = http_1.default.createServer(app);\nexports.server = server;\nconst io = new socket_io_1.Server(server, {\n    cors: {\n        origin: process.env.FRONTEND_URI,\n        methods: [\"GET\", \"POST\", \"PATCH\", \"DELETE\"],\n        credentials: true,\n    },\n});\nconst employeeSocketMap = new Map();\nio.on(\"connection\", (socket) => {\n    const { employeeId } = url_1.default.parse(socket.handshake.url, true).query;\n    if (employeeId) {\n        employeeSocketMap.set(employeeId.toString(), socket);\n        console.log(\"New client connected. Employee ID:\", employeeId);\n    }\n    socket.on(\"disconnect\", () => {\n        if (employeeId) {\n            const storedSocket = employeeSocketMap.get(employeeId.toString());\n            if (storedSocket === socket) {\n                employeeSocketMap.delete(employeeId.toString());\n                console.log(\"Client disconnected. Employee ID:\", employeeId);\n            }\n        }\n        ;\n    });\n    // Listen for new notifications and broadcast them to all connected clients\n    socket.on(\"notification\", (notification) => {\n        io.emit(\"notification\", notification);\n    });\n});\napp.post(\"/api/v1/notifications\", async (req, res) => {\n    const { message, notificationType, groupName, jobProfileName, employeeId, id, parentJobProfileId, } = req.body;\n    try {\n        let targetEmployees = [];\n        let filter = {};\n        if (groupName) {\n            const group = await groupModel_1.default.findOne({ groupName });\n            if (group) {\n                filter.groupId = group?._id;\n            }\n        }\n        if (jobProfileName) {\n            const jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n            if (jobProfile) {\n                filter.jobProfileId = jobProfile?._id;\n            }\n        }\n        if (parentJobProfileId) {\n            filter.jobProfileId = parentJobProfileId;\n        }\n        if (employeeId) {\n            targetEmployees = await employeeModel_1.default.find({ _id: employeeId });\n        }\n        else if (id) {\n            const data = await employeeModel_1.default.findOne({ _id: id });\n            const jobprofile = await jobProfileModel_1.default.findOne({\n                _id: data?.jobProfileId,\n            });\n            targetEmployees = await employeeModel_1.default.find({\n                jobProfileId: jobprofile?.parentJobProfileId,\n            });\n        }\n        else {\n            targetEmployees = await employeeModel_1.default.find(filter);\n        }\n        // Find target employees based on the request body\n        // Send notification to each target employee\n        for (let i = 0; i < targetEmployees.length; i++) {\n            const data = {\n                message,\n                notificationType,\n                date: new Date(),\n            };\n            let notificationEmployee = await notificationModel_1.default.findOne({\n                employeeId: targetEmployees[i]._id,\n            });\n            if (!notificationEmployee) {\n                notificationEmployee = new notificationModel_1.default({\n                    employeeId: targetEmployees[i]._id,\n                });\n            }\n            notificationEmployee.notification.push(data);\n            const savedNotification = await notificationEmployee.save();\n            const targetSocket = employeeSocketMap.get(targetEmployees[i]._id.toString());\n            if (targetSocket && targetSocket.connected) {\n                targetSocket.emit(\"notification\", savedNotification);\n            }\n        }\n        res.json({ message: \"Notification sent successfully\" });\n    }\n    catch (err) {\n        res.status(400).json({ message: err.message });\n    }\n});\n// app.get(\n//   \"/api/v1/notifications/:employeeId\",\n//   async (req: Request, res: Response) => {\n//     const { employeeId } = req.params;\n//     const page = parseInt(req.query.page as string, 10) || 0;\n//     const size = parseInt(req.query.size as string, 10) || 10;\n//     try {\n//       const notifications = await notificationModel\n//         .findOne({ employeeId })\n//         .sort({ \"notification.date\": -1 })\n//         .skip(page * size)\n//         .limit(size)\n//         .exec();\n//       res.json(notifications);\n//     } catch (err: any) {\n//       res.status(400).json({ message: err.message });\n//     }\n//   }\n// );\napp.get(\"/api/v1/notifications/:employeeId\", async (req, res) => {\n    const { employeeId } = req.params;\n    const page = parseInt(req.query.page, 10) || 0;\n    const size = parseInt(req.query.size, 10) || 50;\n    try {\n        const notificationsData = await notificationModel_1.default.findOne({ employeeId });\n        if (!notificationsData) {\n            return res.json([]);\n        }\n        const allNotifications = notificationsData.notification || []; // Assuming notification is an array within the notifications document\n        // Calculate the starting and ending indexes for the current page\n        const startIndex = page * size;\n        const endIndex = startIndex + size;\n        // Filter notifications older than 2 months from the array\n        // const currentDate = new Date();\n        const twoMonthsAgo = new Date();\n        twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);\n        const filteredNotifications = allNotifications.filter((notification) => {\n            if (notification.notificationType.toLowerCase() === \"attendance\") {\n                // Check if the notification is older than one day\n                const oneDayAgo = new Date();\n                oneDayAgo.setDate(oneDayAgo.getDate() - 2);\n                return notification.date >= oneDayAgo;\n            }\n            else {\n                // Check if the notification is older than two months\n                return notification.date >= twoMonthsAgo;\n            }\n        });\n        // Sort notifications in descending order based on the 'date' property\n        filteredNotifications.sort((a, b) => b.date - a.date);\n        // Slice the array to get the paginated notifications\n        const paginatedNotifications = filteredNotifications.slice(startIndex, endIndex);\n        // Update the notifications array in the document to remove older notifications\n        notificationsData.notification = filteredNotifications;\n        await notificationsData.save();\n        res.json({ notification: paginatedNotifications });\n    }\n    catch (err) {\n        res.status(400).json({ message: err.message });\n    }\n    ;\n});\n// app.get('/translate', async (req: Request, res: Response) => {\n//   try {\n//     const textToTranslate = req.query.text as string; // Cast req.query.text to string\n//     if (!textToTranslate) {\n//       throw new Error('Text to translate is missing');\n//     }\n//     // Log the request before sending it\n//     console.log('Translation Request:', textToTranslate);\n//     // Use google-translate-api to translate the text from English to Hindi\n//     const translation = await translate(textToTranslate, { from: 'en', to: 'hi' });\n//     // Log the response from the API\n//     console.log('Translation Response:', translation);\n//     const translatedText = translation.text;\n//     res.json({ translatedText });\n//   } catch (error) {\n//     console.error(error);\n//     res.status(500).json({ error: 'Translation failed' });\n//   }\n// });\n//testing translation\napp.use(\"/api/v1\", translate_1.default);\n// routes\napp.use(\"/api/v1/auth\", authRoutes_1.default);\napp.use(\"/api/v1/employee\", employeeRoutes_1.default);\napp.use(\"/api/v1/admin\", adminRoutes_1.default);\napp.use(\"/api/v1/attendance\", attendanceRoutes_1.default);\napp.use(\"/api/v1/group\", groupRoutes_1.default);\napp.use(\"/api/v1/jobProfile\", jobProfileRoutes_1.default);\napp.use(\"/api/v1/employee/docs\", employeeDocsRouters_1.default);\napp.use(\"/api/v1/leave\", leaveRoutes_1.default);\napp.use(\"/api/v1/training\", trainingRoutes_1.default);\napp.use(\"/api/v1/otpVerify\", otpRouter_1.default);\napp.use(\"/api/v1/quiz\", quizRoutes_1.default);\napp.use(\"/api/v1/department\", departmentRoutes_1.default);\n// BOP\napp.use(\"/api/v1/godown\", godownRouter_1.default);\napp.use(\"/api/v1/globalProcess\", gobalProcessRouter_1.default);\napp.use(\"/api/v1/rawMaterial\", rawMaterialRouter_1.default);\n//childPart and FinishedItems\napp.use(\"/api/v1/childPart\", childPartRouter_1.default);\napp.use(\"/api/v1/finishedItems\", finishedRoutes_1.default);\napp.use(\"/api/v1/customer\", customerRouter_1.default);\napp.use(\"/api/v1/cnc\", CNCProgramRoutes_1.default);\napp.use(\"/api/v1/workOrder\", workOrderRouter_1.default);\napp.use(\"/api/v1/machine\", machineRouter_1.default);\napp.use(\"/api/v1/productionSlip\", productionSlipRoutes_1.default);\napp.use(\"/api/v1/shop\", shopRoutes_1.default);\n// inventory routes\napp.use(\"/api/v1/inventory\", inventoryRoutes_1.default);\n// planning\napp.use(\"/api/v1/planning\", planningRoutes_1.default);\n//productivityReport\napp.use(\"/api/v1/report\", productivityReportRoutes_1.default);\n// salaryReport\napp.use(\"/api/v1/salaryreport\", salaryReportRoutes_1.default);\n// v2 2\napp.use(\"/api/v2/attendance\", v2AttendanceRouter_1.default);\napp.use(\"/api/v2/workingDay\", workingDayRouter_1.workingDayRouter);\napp.use(\"/api/v2/loggedInHistory\", loggedInUserHistoryRouter_1.default);\napp.use(\"/api/v2/scanSlip\", scanSlipRouter_1.default);\n// SUPERVISOR \napp.use(\"/api/v2/salary\", salaryRouter_1.default);\napp.get(\"/api/v2/changeSalary\", salaryChangeController_1.changeSalary);\napp.get(\"/api/v2/changeActive\", activeController_1.changeActiveStatus);\nnode_cron_1.default.schedule('0 0 * * *', () => {\n    const res = axios_1.default.get(\"https://chawlacomponents.com/api/v2/changeActive\");\n    const res2 = axios_1.default.get(\"https://chawlacomponents.com//api/v2/changeSalary\");\n    //console.log(res)\n    // console.log('API scheduled at 12 AM daily.');\n});\n// Route to serve the production buildcr\napp.get(\"/prd/*\", (req, res) => {\n    res.sendFile(path_1.default.join(__dirname, \"..\", \"builds\", \"productionApp\", \"index.html\"));\n});\n// Route to serve the hrms build\napp.get(\"*\", (req, res) => {\n    res.sendFile(path_1.default.join(__dirname, \"..\", \"builds\", \"hrms\", \"index.html\"));\n});\n// 1\n//error Handler\napp.use(errorHandler_1.errorMiddleware);\nexports[\"default\"] = app;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/app.ts?");

/***/ }),

/***/ "./src/controllers/admin/adminController.ts":
/*!**************************************************!*\
  !*** ./src/controllers/admin/adminController.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.changePasswordAdmin = exports.logout = exports.myProfile = exports.adminLogin = exports.getAllAdmin = exports.deleteAdmin = exports.updateAdmin = exports.addAdmin = void 0;\nconst adminModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/adminModel */ \"./src/database/models/adminModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst bcrypt_1 = __importDefault(__webpack_require__(/*! bcrypt */ \"bcrypt\"));\nconst sendCookie_1 = __webpack_require__(/*! ../../utils/sendCookie */ \"./src/utils/sendCookie.ts\");\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst loginHistoryModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/loginHistoryModel */ \"./src/database/models/loginHistoryModel.ts\"));\nconst dateTimeConverter_1 = __webpack_require__(/*! ../../middleware/dateTimeConverter */ \"./src/middleware/dateTimeConverter.ts\");\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\n// adding a admin\nexports.addAdmin = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { name, email, password } = req.body;\n    let admin = await adminModel_1.default.findOne({ email });\n    if (admin) {\n        return next(new errorHandler_1.default(\"Admin Already exist.\", 400));\n    }\n    const hashedPassword = await bcrypt_1.default.hash(password, parseInt(process.env.SALT, 10));\n    admin = await adminModel_1.default.create({\n        name,\n        email: email.toLowerCase(),\n        password: hashedPassword,\n    });\n    resp.status(201).json({\n        success: true,\n        message: \"Admin created successfully.\",\n        admin,\n    });\n});\n// update an admin\nexports.updateAdmin = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const id = req.params;\n    const { userName, email, password } = req.body;\n    let admin = await adminModel_1.default.findOne({ email });\n    if (!admin) {\n        return next(new errorHandler_1.default(\"Admin doesn't exist.\", 400));\n    }\n    const hashedPassword = await bcrypt_1.default.hash(password, parseInt(process.env.SALT, 10));\n    admin = await adminModel_1.default.findByIdAndUpdate({ _id: id }, {\n        userName,\n        email,\n        password: hashedPassword,\n    });\n    resp.status(201).json({\n        success: true,\n        message: \"Admin updated successfully.\",\n        admin,\n    });\n});\n// delete an admin\nexports.deleteAdmin = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const id = req.params;\n    let admin = await adminModel_1.default.findByIdAndDelete({ _id: id });\n    if (!admin) {\n        return next(new errorHandler_1.default(\"admin doesn't exist.\", 400));\n    }\n    resp.status(201).json({\n        success: true,\n        message: \"admin created successfully.\",\n        admin,\n    });\n});\n// get all admin\nexports.getAllAdmin = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let admin = await adminModel_1.default.find({});\n    resp.status(201).json({\n        success: true,\n        message: \"Getting All admin successfully.\",\n        admin,\n    });\n});\n// admin Login\nexports.adminLogin = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { email, phone, password, userAgent, platform, ipAddress } = req.body;\n    if (email) {\n        email = email.toLowerCase();\n    }\n    if (phone) {\n        if (typeof phone === \"string\") {\n            phone = parseInt(phone);\n        }\n    }\n    let admin = await adminModel_1.default.findOne({\n        $or: [\n            { email: email || \"abc@gmail.com\" },\n            { contactNumber: phone || 985953857 },\n        ],\n    }).select(\"+password\");\n    let user = await employeeModel_1.default.findOne({\n        $or: [{ email: email || \"xyz@gmail.com\" }, { contactNumber: phone || 99999999999 }],\n    })\n        .populate(\"jobProfileId\")\n        .exec();\n    const obj = {\n        userAgent,\n        platform,\n    };\n    if (admin) {\n        const userInfo = {\n            name: admin.name,\n            role: \"Admin\",\n            jobProfile: \"Admin\",\n            employeeCode: \"Admin\",\n        };\n        if (admin._id + \"\" !== \"64a3f3353d41be4135d71b31\") {\n            const userLog = await loginHistoryModel_1.default.create({\n                user: admin._id,\n                userInfo: userInfo,\n                device: obj,\n                ipAddress: ipAddress,\n                logInTime: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n            });\n        }\n        ;\n        const comparePassword = await bcrypt_1.default.compare(password, admin.password);\n        if (!comparePassword) {\n            return next(new errorHandler_1.default(\"admin or password doesn't match.\", 400));\n        }\n        (0, sendCookie_1.sendCookieAdmin)(resp, admin, `Welcome back, ${admin.name}`, 200);\n    }\n    else if (user) {\n        const comparePassword = await bcrypt_1.default.compare(password, user.password);\n        const jobprofile = user.jobProfileId;\n        const userInfo = {\n            name: user.name,\n            jobProfile: jobprofile.jobProfileName,\n            role: user.role,\n            employeeCode: user.employeeCode,\n        };\n        const userLog = await loginHistoryModel_1.default.create({\n            user: user._id,\n            userInfo: userInfo,\n            device: obj,\n            ipAddress: ipAddress,\n            logInTime: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n        });\n        if (!comparePassword) {\n            return next(new errorHandler_1.default(\"user or password doesn't match.\", 400));\n        }\n        if (user.active) {\n            (0, sendCookie_1.sendCookieAdmin)(resp, user, `Welcome back, ${user.name}`, 200);\n        }\n        else {\n            return next(new errorHandler_1.default(\"Sorry you are Inactive user !\", 404));\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"User not found\", 404));\n    }\n});\nexports.myProfile = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin) {\n        const admin = req.admin;\n        resp.status(200).json({\n            success: true,\n            message: \"Getting admin details successfully.\",\n            admin,\n        });\n    }\n    else if (req.employee) {\n        const employee = await employeeModel_1.default.findById(req.employee._id)\n            .populate(\"jobProfileId\")\n            .exec();\n        const shop = await shopModel_1.default.findOne({ \"jobProfile.jobProfileId\": employee?.jobProfileId }).select(\"shopName shopCode\");\n        const userPicture = await employeeDocsModel_1.default.findOne({\n            employeeId: employee?._id,\n        });\n        resp.status(200).json({\n            success: true,\n            message: \"Getting employee details successfully.\",\n            profilePicture: userPicture?.profilePicture,\n            employee,\n            shop\n        });\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Login first User not found\",\n        });\n    }\n});\n// logout\nexports.logout = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    resp\n        .status(200)\n        .cookie(\"token\", \"\", {\n        expires: new Date(Date.now()),\n    })\n        .json({\n        success: true,\n        message: \"User logged out successfully\",\n    });\n});\nconst changePasswordAdmin = async (req, resp, next) => {\n    if (req.admin) {\n        const { oldPassword, newPassword } = req.body;\n        const comparePassword = await bcrypt_1.default.compare(oldPassword, req.admin.password);\n        if (comparePassword) {\n            const hashedPassword = await bcrypt_1.default.hash(newPassword, parseInt(process.env.SALT, 10));\n            const updatedEmployee = await adminModel_1.default.findOneAndUpdate({ _id: req.admin._id }, { password: hashedPassword }, { new: true });\n            resp.status(200).json({\n                success: true,\n                message: \"Password changed successfully.\",\n                employee: updatedEmployee,\n            });\n        }\n        else {\n            resp.status(200).json({\n                success: false,\n                message: \"Old password is not correct.\",\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Something went wrong. Login with admin.\", 400));\n    }\n};\nexports.changePasswordAdmin = changePasswordAdmin;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/admin/adminController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/CNCProgramController.ts":
/*!****************************************************************!*\
  !*** ./src/controllers/bomControllers/CNCProgramController.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deleteChildPartFromProgram = exports.CNCProgramLogsDelete = exports.deleteCNCProgram = exports.CNCProgramLogs = exports.getWorkOrderByChildPart = exports.addProgramProductionSlip = exports.updateProduction = exports.updateCNCProgram = exports.finalizeProgram = exports.singleProgram = exports.allProgram = exports.addChildPartInCNCProgram = exports.addCNCProgram = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_2 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst CNCProgramModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/CNCProgramModel */ \"./src/database/models/CNCProgramModel.ts\"));\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst machineModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/machineModel */ \"./src/database/models/machineModel.ts\"));\nconst workOrderModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workOrderModel */ \"./src/database/models/workOrderModel.ts\"));\nconst CNCProgramLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/CNCProgramLogModel */ \"./src/database/models/CNCProgramLogModel.ts\"));\nconst productionSlipController_1 = __webpack_require__(/*! ./productionSlipController */ \"./src/controllers/bomControllers/productionSlipController.ts\");\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst customerModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/customerModel */ \"./src/database/models/customerModel.ts\"));\n(0, dotenv_1.config)({ path: path_2.default.join(__dirname, \"../../../\", \"public/.env\") });\naws_sdk_1.default.config.update({\n    secretAccessKey: process.env.ACCESS_SECRET,\n    accessKeyId: process.env.ACCESS_KEY,\n    region: process.env.REGION,\n});\nconst BUCKET = process.env.BUCKET;\nif (!BUCKET) {\n    console.error(\"No bucket specified in the environment configuration.\");\n    process.exit(1);\n}\nconst s3 = new aws_sdk_1.default.S3();\nexports.addCNCProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { programName, rawMaterialName, weight, DXFDescription, drawingDescription, nestingDescription, status, process, cycleTime, scrapGeneration } = req.body;\n    const rawMaterial = await childPartModel_1.default.findOne({\n        partName: rawMaterialName,\n    });\n    if (!rawMaterial) {\n        return resp.status(404).json({\n            success: false,\n            message: `Raw material not found with Name ${rawMaterialName}`,\n        });\n    }\n    const processDetail = await globalProcessModel_1.default.findOne({\n        processName: process,\n    });\n    if (!processDetail) {\n        return resp.status(404).json({\n            success: false,\n            message: `Process with name ${process} not found.`,\n        });\n    }\n    const programs = await CNCProgramModel_1.default.find({\n        processId: processDetail._id,\n    });\n    const programNumber = programs.length;\n    const files = req.files;\n    const allowedExtensions = [\".pdf\"];\n    let dfxFileUrl = \"\";\n    let drawingUrl = \"\";\n    let nestingUrl = \"\";\n    if (files['DFX']) {\n        const dfxFile = files['DFX'][0];\n        const fileExt = (0, path_1.extname)(dfxFile.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return resp.status(400).send({\n                success: false,\n                message: \"Invalid file type. Only PDF files are allowed.\",\n            });\n        }\n        ;\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${dfxFile.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: dfxFile.buffer,\n            ACL: \"public-read\",\n        };\n        await s3.putObject(uploadParams).promise();\n        const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        dfxFileUrl = fileUrl;\n    }\n    if (files['drawing']) {\n        const drawingFile = files['drawing'][0];\n        const fileExt = (0, path_1.extname)(drawingFile.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return resp.status(400).send({\n                success: false,\n                message: \"Invalid file type. Only PDF files are allowed.\",\n            });\n        }\n        ;\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${drawingFile.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: drawingFile.buffer,\n            ACL: \"public-read\",\n        };\n        await s3.putObject(uploadParams).promise();\n        const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        drawingUrl = fileUrl;\n    }\n    if (files['nesting']) {\n        const nestingFile = files['nesting'][0];\n        const fileExt = (0, path_1.extname)(nestingFile.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return resp.status(400).send({\n                success: false,\n                message: \"Invalid file type. Only PDF files are allowed.\",\n            });\n        }\n        ;\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${nestingFile.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: nestingFile.buffer,\n            ACL: \"public-read\",\n        };\n        await s3.putObject(uploadParams).promise();\n        const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        nestingUrl = fileUrl;\n    }\n    ;\n    const newProgram = await CNCProgramModel_1.default.create({\n        programName: programName,\n        programNumber: processDetail.processCode + \"/\" + (programNumber + 1),\n        rawMaterialName: rawMaterial.partName,\n        rawMaterialCode: rawMaterial.materialCode,\n        rawMaterialId: rawMaterial._id,\n        processId: processDetail._id,\n        processName: processDetail.processName,\n        DXF: {\n            file: dfxFileUrl,\n            description: DXFDescription,\n        },\n        drawing: {\n            file: drawingUrl,\n            description: drawingDescription,\n        },\n        nesting: {\n            file: nestingUrl,\n            description: nestingDescription,\n        },\n        weight: weight,\n        status: status,\n    });\n    newProgram.cycleTime = cycleTime;\n    newProgram.scrap.quantity = scrapGeneration;\n    newProgram.scrap.unit = \"kg\";\n    // Save the new program to your database\n    await newProgram.save();\n    resp.status(200).json({\n        success: true,\n        message: \"CNC program added successfully.\",\n        newProgram,\n    });\n});\n// add childPart in CNC Program\nexports.addChildPartInCNCProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { \n    // programId,\n    childPartName, childPartProduced, \n    // weightPerChildPart,\n    weightUnit, } = req.body;\n    const { programId } = req.params;\n    // const finishedItem = await FinishedItemModel.findOne({MCode:finishItemCode});\n    // if(!finishedItem){\n    //   return resp.status(404).json({\n    //     success:false,\n    //     message:`Finished Item with MCode ${finishItemCode} not found.`\n    //   })\n    // };\n    const childPart = await childPartModel_1.default.findOne({ partName: childPartName });\n    if (!childPart) {\n        return resp.status(404).json({\n            success: false,\n            message: `Child part with name ${childPartName} not found.`,\n        });\n    }\n    // let check = false;\n    // finishedItem.masterBom?.forEach((m)=>{\n    //   const childPart1 = m.childPart?.childPartName;\n    //   if(childPart1 === childPart.partName){\n    //     check = true;\n    //   };\n    // });\n    // if(check === false){\n    //   return resp.status(404).json({\n    //     success:false,\n    //     message:`ChildPart with name ${childPartName} not present in finished Item with name ${finishedItem.itemName}`\n    //   });\n    // };\n    const program = await CNCProgramModel_1.default.findById(programId);\n    if (!program) {\n        return resp.status(400).json({\n            success: false,\n            message: `Program not found with ID ${programId}`,\n        });\n    }\n    let programCheck = false;\n    program.childParts.forEach((p) => {\n        const ChildPartName = p.childPart.childPartName;\n        if (ChildPartName === childPartName) {\n            programCheck = true;\n        }\n    });\n    if (programCheck) {\n        return resp.status(400).json({\n            success: false,\n            message: `Child part ${childPartName} already present in the program.`,\n        });\n    }\n    let weight = 0;\n    childPart.consumedItem.forEach((c) => {\n        weight += c.consumedItemQuantity;\n    });\n    program.childParts.push({\n        // finishItemCode:finishedItem.MCode,\n        childPart: {\n            childPartName: childPart.partName,\n            id: childPart._id,\n        },\n        childPartProduced: childPartProduced,\n        weightPerChildPart: weight,\n        weightUnit: weightUnit || \"kg\",\n    });\n    await program.save();\n    resp.json({\n        success: true,\n        message: \"ChildPart added successfully.\",\n        program,\n    });\n});\n// get all Program\nexports.allProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { name, processes, rawMaterialCodes, shops, sort, customers } = req.body;\n    const query = {};\n    if (name) {\n        query.$or = [\n            { programName: { $regex: name, $options: \"i\" } },\n            { programNumber: { $regex: name, $options: \"i\" } },\n            { rawMaterialName: { $regex: name, $options: \"i\" } },\n            { rawMaterialCode: { $regex: name, $options: \"i\" } },\n            { processName: { $regex: name, $options: \"i\" } }\n        ];\n    }\n    ;\n    if (processes && processes.length > 0) {\n        const processesDetails = await globalProcessModel_1.default.find({ processName: { $in: processes } });\n        //  const ids = processesDetails.map((p)=>p._id);\n        if (!query.processId) {\n            query.processId = { $in: [] };\n        }\n        processesDetails.forEach((p) => {\n            query.processId.$in.push(p._id);\n        });\n    }\n    ;\n    if (rawMaterialCodes && rawMaterialCodes.length > 0) {\n        const rawMaterials = await childPartModel_1.default.find({ materialCode: { $in: rawMaterialCodes } });\n        const ids = rawMaterials.map((r) => r._id);\n        query.rawMaterialId = { $in: ids };\n    }\n    ;\n    if (shops && shops.length > 0) {\n        const Shops = await shopModel_1.default.find({ shopName: { $in: shops } });\n        const shopIds = Shops.map((s) => s._id);\n        const processesDetails = await globalProcessModel_1.default.find({ \"shop.shopId\": { $in: shopIds } });\n        if (!query.processId) {\n            query.processId = { $in: [] };\n        }\n        ;\n        processesDetails.forEach((p) => {\n            query.processId.$in.push(p._id);\n        });\n    }\n    ;\n    if (customers && customers.length) {\n        const customerDetails = await customerModel_1.default.find({ customerName: { $in: customers } }).lean();\n        const customersId = customerDetails.map((c) => c._id);\n        const finishedItems = await finishedItemModel_1.default.find({ customer: { $in: customersId } }).lean();\n        const finishedItemIds = finishedItems.map((f) => f._id);\n        const childParts = await childPartModel_1.default.find({ finishedItemId: { $in: finishedItemIds } }).lean();\n        if (childParts) {\n            const childPartids = childParts.map((c) => c._id);\n            query[\"childParts.childPart.id\"] = { $in: childPartids };\n        }\n    }\n    let allProgram;\n    if (sort === \"asc\") {\n        allProgram = await CNCProgramModel_1.default.find({ ...query }).sort({ programName: 1 }).lean();\n    }\n    else if (sort === \"dec\") {\n        allProgram = await CNCProgramModel_1.default.find({ ...query }).sort({ programName: -1 }).lean();\n    }\n    else {\n        allProgram = await CNCProgramModel_1.default.find({ ...query }).lean();\n    }\n    resp.status(200).json({\n        success: true,\n        message: `Getting all the Programs.`,\n        allProgram,\n    });\n});\n// get Single Program\nexports.singleProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const program = await CNCProgramModel_1.default.findById(id);\n    if (!program) {\n        return resp.json({\n            success: false,\n            message: `Program not found with ID ${id}`,\n        });\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"Getting the program successfully.\",\n        program,\n    });\n});\n// finalize Apis\nexports.finalizeProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { cycleTime, scrapGeneration } = req.body;\n    const file = req.file;\n    const { programId } = req.params;\n    const program = await CNCProgramModel_1.default.findById(programId);\n    if (!program)\n        return next(new errorHandler_1.default(`Program not found with id ${programId}.`, 404));\n    if (!file)\n        return next(new errorHandler_1.default(\"File is not uploaded.\", 400));\n    if (!cycleTime)\n        return next(new errorHandler_1.default(`Cycle time not found.`, 400));\n    if (!scrapGeneration)\n        return next(new errorHandler_1.default(`Scrap quantity is required.`, 400));\n    const allowedExtensions = [\".pdf\"];\n    let uploadedFile = \"\";\n    if (file) {\n        const fileExt = (0, path_1.extname)(file.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return resp.status(400).send({\n                success: false,\n                message: \"Invalid file type. Only PDF files are allowed.\",\n            });\n        }\n        ;\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        await s3.putObject(uploadParams).promise();\n        const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        uploadedFile = fileUrl;\n    }\n    program.nesting.file = uploadedFile;\n    program.cycleTime = cycleTime;\n    program.scrap.quantity = scrapGeneration;\n    program.scrap.unit = \"kg\";\n    program.isCompleted = true;\n    await program.save();\n    resp.status(200).json({\n        success: true,\n        message: \"updating Program successfully.\",\n        program,\n    });\n});\n// update CNC Program\nconst updateCNCProgram = async (req, resp, next) => {\n    try {\n        const { programId } = req.params;\n        const { weight, scrap, rawMaterial, programName, process, status, cycleTime, DXFDescription, drawingDescription, isCompleted, nestingDescription } = req.body;\n        const files = req.files;\n        const allowedExtensions = [\".pdf\"];\n        let dfxFileUrl = \"\";\n        let drawingUrl = \"\";\n        let nestingUrl = \"\";\n        // let dfxCheck = false;\n        // let drawingCheck = false;\n        // let nestingCheck = false;\n        if (files) {\n            if (files['DFX']) {\n                // dfxCheck = true;\n                const dfxFile = files['DFX'][0];\n                const fileExt = (0, path_1.extname)(dfxFile.originalname).toLowerCase();\n                if (!allowedExtensions.includes(fileExt)) {\n                    return resp.status(400).send({\n                        success: false,\n                        message: \"Invalid file type. Only PDF files are allowed.\",\n                    });\n                }\n                ;\n                const fileKey = `uploads/${(0, uuid_1.v4)()}-${dfxFile.originalname}`;\n                const uploadParams = {\n                    Bucket: BUCKET,\n                    Key: fileKey,\n                    Body: dfxFile.buffer,\n                    ACL: \"public-read\",\n                };\n                await s3.putObject(uploadParams).promise();\n                const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n                dfxFileUrl = fileUrl;\n            }\n            if (files['drawing']) {\n                // drawingCheck = true;\n                const drawingFile = files['drawing'][0];\n                const fileExt = (0, path_1.extname)(drawingFile.originalname).toLowerCase();\n                if (!allowedExtensions.includes(fileExt)) {\n                    return resp.status(400).send({\n                        success: false,\n                        message: \"Invalid file type. Only PDF files are allowed.\",\n                    });\n                }\n                ;\n                const fileKey = `uploads/${(0, uuid_1.v4)()}-${drawingFile.originalname}`;\n                const uploadParams = {\n                    Bucket: BUCKET,\n                    Key: fileKey,\n                    Body: drawingFile.buffer,\n                    ACL: \"public-read\",\n                };\n                await s3.putObject(uploadParams).promise();\n                const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n                drawingUrl = fileUrl;\n            }\n            if (files['nesting']) {\n                // nestingCheck = true;\n                const nestingFile = files['nesting'][0];\n                const fileExt = (0, path_1.extname)(nestingFile.originalname).toLowerCase();\n                if (!allowedExtensions.includes(fileExt)) {\n                    return resp.status(400).send({\n                        success: false,\n                        message: \"Invalid file type. Only PDF files are allowed.\",\n                    });\n                }\n                ;\n                const fileKey = `uploads/${(0, uuid_1.v4)()}-${nestingFile.originalname}`;\n                const uploadParams = {\n                    Bucket: BUCKET,\n                    Key: fileKey,\n                    Body: nestingFile.buffer,\n                    ACL: \"public-read\",\n                };\n                await s3.putObject(uploadParams).promise();\n                const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n                nestingUrl = fileUrl;\n            }\n            ;\n        }\n        ;\n        const program = await CNCProgramModel_1.default.findById(programId);\n        if (!program) {\n            return resp.status(404).json({\n                success: false,\n                message: `Program not found with Id ${programId}.`\n            });\n        }\n        ;\n        if (weight) {\n            program.weight = weight;\n        }\n        ;\n        if (scrap) {\n            program.scrap.quantity = scrap;\n            program.scrap.unit = \"kg\";\n        }\n        ;\n        if (cycleTime) {\n            program.cycleTime = cycleTime;\n        }\n        ;\n        if (drawingUrl) {\n            program.drawing.file = drawingUrl;\n        }\n        ;\n        if (dfxFileUrl) {\n            program.DXF.file = dfxFileUrl;\n        }\n        ;\n        if (nestingUrl) {\n            program.nesting.file = nestingUrl;\n        }\n        ;\n        if (DXFDescription) {\n            program.DXF.description = DXFDescription;\n        }\n        ;\n        if (drawingDescription) {\n            program.drawing.description = drawingDescription;\n        }\n        ;\n        if (nestingDescription) {\n            program.nesting.description = nestingDescription;\n        }\n        ;\n        if (isCompleted) {\n            program.isCompleted = isCompleted;\n        }\n        ;\n        // if(dfxCheck=== false){\n        //   program.DXF.file = \"\"\n        // };\n        // if(drawingCheck === false){\n        //   program.drawing.file = \"\"\n        // };\n        // if(nestingCheck === false){\n        //   program.nesting.file = \"\"\n        // };\n        if (rawMaterial) {\n            const rawMaterialDetails = await childPartModel_1.default.findOne({ partName: rawMaterial });\n            if (!rawMaterialDetails) {\n                return resp.status(404).json({\n                    success: false,\n                    message: \"Raw Material not found.\"\n                });\n            }\n            ;\n            program.rawMaterialName = rawMaterialDetails.partName;\n            program.rawMaterialCode = rawMaterialDetails.materialCode;\n        }\n        ;\n        if (process) {\n            const processDetail = await globalProcessModel_1.default.findOne({ processName: process });\n            if (!processDetail) {\n                return resp.status(404).json({\n                    success: false,\n                    message: \"Process not found.\"\n                });\n            }\n            ;\n            program.processName = processDetail.processName;\n            program.processId = processDetail._id;\n        }\n        ;\n        if (programName) {\n            program.programName = programName;\n        }\n        ;\n        if (status) {\n            program.status = status;\n        }\n        ;\n        await program.save();\n        resp.status(200).json({\n            success: true,\n            message: `Updated ${program.programName}.`,\n            program\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.updateCNCProgram = updateCNCProgram;\n// update ChildPart production in CNC Program\nexports.updateProduction = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { programId } = req.params;\n    const { part, objectId } = req.body;\n    const program = await CNCProgramModel_1.default.findById(programId);\n    if (!program)\n        return next(new errorHandler_1.default(\"Program not found.\", 404));\n    for (let c of program.childParts) {\n        const id = c._id + \"\";\n        if (id + \"\" === objectId + \"\") {\n            const childPart = await childPartModel_1.default.findOne({ partName: part.childPartName });\n            if (!childPart) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Child Part not found with name ${part.childPartName}.`\n                });\n            }\n            let weight = 0;\n            childPart?.consumedItem.forEach((c) => {\n                weight += c.consumedItemQuantity;\n            });\n            c.childPart = {\n                childPartName: childPart.partName,\n                id: childPart._id,\n            };\n            c.childPartProduced = part.childPartProduced;\n            c.weightPerChildPart = weight;\n            c.weightUnit = \"kg\";\n            break;\n        }\n    }\n    await program.save();\n    resp.status(200).json({\n        success: true,\n        message: \"Updated successfully.\",\n        program,\n    });\n});\nfunction convertTimeTo24HourFormat(timeString) {\n    // Split the time string into components\n    const [time, amOrPm] = timeString.split(\" \");\n    // Split the time into hours and minutes\n    let [hours, minutes] = time.split(\":\").map(Number);\n    // Convert to 24-hour format\n    if (amOrPm.toLowerCase() === \"pm\" && hours !== 12) {\n        hours += 12;\n    }\n    else if (amOrPm.toLowerCase() === \"am\" && hours === 12) {\n        hours = 0;\n    }\n    const obj = {\n        hour: hours,\n        min: minutes,\n    };\n    // Return the time in 24-hour format\n    return obj;\n}\n;\n// Add production Slip log\nconst addProgramProductionSlip = async (req, resp, next) => {\n    try {\n        const { programId } = req.params;\n        const { childArray, employees, machines, sheetQuantity, startTime, endTime, } = req.body;\n        if (req.employee || req.admin) {\n            let name = \"\";\n            let employeeId;\n            if (req.employee) {\n                name = req.employee.name;\n                employeeId = req.employee._id;\n            }\n            ;\n            if (req.admin) {\n                name = req.admin.name;\n                employeeId = req.admin._id;\n            }\n            ;\n            const convertedStartTime = convertTimeTo24HourFormat(startTime);\n            const convertedEndTime = convertTimeTo24HourFormat(endTime);\n            const newStartTime = new Date();\n            newStartTime.setHours(convertedStartTime.hour, convertedStartTime.min, 0, 0);\n            const newEndTime = new Date();\n            newEndTime.setHours(convertedEndTime.hour, convertedEndTime.min, 0, 0);\n            const program = await CNCProgramModel_1.default.findById(programId);\n            if (!program || program.isCompleted === false)\n                return next(new errorHandler_1.default(\"Program not found or incomplete.\", 404));\n            const employeeDetails = await employeeModel_1.default.find({\n                _id: { $in: employees },\n            }).lean();\n            const employeesArray = [];\n            employeeDetails.forEach((e) => {\n                employeesArray.push({\n                    employeeId: e._id,\n                    employeeName: e.name,\n                });\n            });\n            const machineDetails = await machineModel_1.default\n                .find({ _id: { $in: machines } })\n                .lean();\n            const machineArray = [];\n            machineDetails.forEach((m) => {\n                machineArray.push({\n                    machineCode: m.code,\n                    machineId: m._id,\n                    machineName: m.machineName,\n                });\n            });\n            const workOrders = await workOrderModel_1.default.find({}).lean();\n            const workOrderStore = {};\n            workOrders.forEach((w) => {\n                const orderNumber = w.orderNumber + \"\";\n                workOrderStore[orderNumber] = {\n                    ...w,\n                };\n            });\n            const childPartStore = {};\n            childArray.forEach((c) => {\n                const id = c.childPartId + \"\";\n                const orderNumber = c.workOrderNumber + \"\";\n                if (!workOrderStore[orderNumber]) {\n                    return resp.status(404).json({\n                        success: false,\n                        message: `Work order not found with number ${orderNumber}.`\n                    });\n                }\n                let check = false;\n                workOrderStore[orderNumber].masterBom.forEach((m) => {\n                    // console.log(m._id+\"\",c.childPartId);\n                    if (m._id + \"\" === c.childPartId + \"\") {\n                        check = true;\n                    }\n                });\n                if (check === false) {\n                    return resp.status(404).json({\n                        success: false,\n                        message: `ChildPart ${c.childPartId} not present in workOrder ${orderNumber}`\n                    });\n                }\n                childPartStore[id] = {\n                    workOrderId: workOrderStore[orderNumber]._id,\n                };\n            });\n            let totalWeight = 0;\n            program.childParts.forEach((c) => {\n                totalWeight += c.weightPerChildPart * c.childPartProduced;\n            });\n            let count = await CNCProgramLogModel_1.default.find({ \"machine.machineName\": machineArray[0].machineName });\n            let number = count.length + 1;\n            const programLog = await CNCProgramLogModel_1.default.create({\n                logNumber: program.programNumber + \"-\" + machineArray[0].machineCode + \"-\" + number,\n                CNCProgramId: programId,\n                rawMaterialName: program.rawMaterialName,\n                rawMaterialCode: program.rawMaterialCode,\n                processName: program.processName,\n                processId: program.processId,\n                weight: program.weight,\n                nesting: {\n                    file: program.nesting.file,\n                    description: program.nesting.description\n                },\n                DXF: {\n                    file: program.DXF.file,\n                    description: program.DXF.description\n                },\n                drawing: {\n                    file: program.drawing.file,\n                    description: program.drawing.description\n                },\n                startTime: newStartTime,\n                endTime: newEndTime,\n                sheetConsumed: sheetQuantity,\n                employees: employeesArray,\n                machines: machineArray,\n                productionSlipNumber: [],\n            });\n            let employeeIds = [];\n            employeeIds = employeesArray.map((e) => e.employeeId);\n            let machineIds = [];\n            machineIds = machineArray.map((m) => m.machineId);\n            const cycleTime = (newEndTime.getTime() - newStartTime.getTime()) / sheetQuantity;\n            const productionSlipNumbers = [];\n            let currentStartTime = new Date(newStartTime);\n            // Assuming program.childParts is an array\n            for (const c of program.childParts) {\n                const numberofItem = c.childPartProduced * sheetQuantity;\n                const workOrderId = childPartStore[c.childPart.id + \"\"]?.workOrderId;\n                const fraction = (c.weightPerChildPart * c.childPartProduced) / totalWeight;\n                const intervalDuration = fraction * (newEndTime.getTime() - newStartTime.getTime());\n                const EndTime = new Date(currentStartTime.getTime() + intervalDuration);\n                try {\n                    const productionSlip = await (0, productionSlipController_1.addCompletedSlip)({\n                        workOrderId: workOrderId,\n                        childPartId: c.childPart.id + \"\",\n                        employeeIds: employeeIds,\n                        machineIds: machineIds,\n                        itemProduced: numberofItem,\n                        startTime: currentStartTime + \"\",\n                        endTime: EndTime + \"\",\n                        name,\n                        status: \"cnc\",\n                        employeeId\n                    });\n                    currentStartTime = new Date(EndTime);\n                    if (productionSlip?.productionSlip) {\n                        const prdNumber = productionSlip?.productionSlip.productionSlipNumber;\n                        productionSlipNumbers.push(prdNumber);\n                    }\n                    ;\n                }\n                catch (error) {\n                    console.error(error);\n                }\n            }\n            programLog.productionSlipNumber = productionSlipNumbers;\n            programLog.currentCycleTime = cycleTime / (1000 * 60 * 60);\n            programLog.cycleTimeAsProgram = program.cycleTime;\n            if (req.employee) {\n                programLog.by.name = req.employee.name;\n                programLog.by.id = req.employee._id;\n            }\n            if (req.admin) {\n                programLog.by.name = req.admin.name;\n                programLog.by.id = req.admin._id;\n            }\n            await programLog.save();\n            resp.status(201).json({\n                success: true,\n                message: \"Program log active.\",\n                programLog,\n            });\n        }\n        else {\n            return resp.status(403).json({\n                success: false,\n                message: \"Login first.\",\n            });\n        }\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.addProgramProductionSlip = addProgramProductionSlip;\n// get workOrder by childPart\nexports.getWorkOrderByChildPart = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { childPartId } = req.params;\n    let MCode;\n    const allFinishedItem = await finishedItemModel_1.default.find().lean();\n    allFinishedItem.forEach((a) => {\n        let check = false;\n        a.masterBom?.forEach((m) => {\n            if (m.childPart?.id + \"\" === childPartId + \"\") {\n                MCode = a.MCode;\n                check = true;\n                return;\n            }\n        });\n        if (check)\n            return;\n    });\n    if (MCode === \"\") {\n        return resp.status(400).json({\n            success: false,\n            message: `Child part with id ${childPartId} not found in any finished Item.`\n        });\n    }\n    const allWorkOrder = await workOrderModel_1.default.find({ MCode }).lean();\n    const allProductionSlips = await productionSlipModel_1.default.find({ \"part._id\": childPartId }).lean();\n    const filterData = [];\n    allWorkOrder.forEach((a) => {\n        // NEW CODE\n        a.masterBom.forEach(b => {\n            let itemProduced = 0;\n            if ((b._id + \"\") === childPartId) {\n                if (allProductionSlips) {\n                    allProductionSlips.forEach((p) => {\n                        if ((p.workOrderId + \"\") === (a._id + \"\")) {\n                            itemProduced += p.itemProduced;\n                        }\n                    });\n                }\n                const obj = { workOrderNumber: a.orderNumber, status: a.status, pendingReq: b.numberOfItem - itemProduced };\n                filterData.push(obj);\n            }\n        });\n    });\n    return resp.status(200).json({\n        success: true,\n        message: \"Getting all workOrders per childPart\",\n        data: filterData\n    });\n});\n// get all CNC Program Logs \nexports.CNCProgramLogs = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { name, CNCPrograms, shops, processes, sort, machines, date, nextDate } = req.body;\n    const query = {};\n    if (date) {\n        let startDate = new Date(date);\n        startDate.setHours(0, 0, 0, 0);\n        if (nextDate) {\n            let endDate = new Date(nextDate);\n            endDate.setHours(23, 59, 59, 999);\n            query.createdAt = {\n                $gt: startDate,\n                $lte: endDate\n            };\n        }\n        else {\n            let endDate = new Date(date);\n            endDate.setHours(23, 59, 59, 999);\n            query.createdAt = {\n                $gt: startDate,\n                $lte: endDate\n            };\n        }\n    }\n    if (name) {\n        const CNCPrograms = await CNCProgramModel_1.default.find({\n            $or: [\n                { rawMaterialName: { $regex: name, $options: \"i\" } },\n                { processName: { $regex: name, $options: \"i\" } },\n                { rawMaterialCode: { $regex: name, $options: \"i\" } },\n                { programName: { $regex: name, $options: \"i\" } },\n                { programNumber: { $regex: name, $options: \"i\" } },\n            ]\n        });\n        const ids = CNCPrograms.map((c) => c._id);\n        query.$or = [\n            { \"employees.employeeName\": { $regex: name, $options: \"i\" } },\n            { \"machines.machineName\": { $regex: name, $options: \"i\" } },\n            { \"by.name\": { $regex: name, $options: \"i\" } },\n            { CNCProgramId: { $in: ids } }\n        ];\n    }\n    ;\n    if (machines && machines.length > 0) {\n        const allMachines = await machineModel_1.default.find({ machineName: { $in: machines } });\n        if (allMachines && allMachines.length > 0) {\n            query[\"machines.machineId\"] = allMachines.map(m => m._id);\n        }\n    }\n    if (CNCPrograms && CNCPrograms.length > 0) {\n        const program = await CNCProgramModel_1.default.find({ programName: { $in: CNCPrograms } });\n        if (!query.CNCProgramId) {\n            query.CNCProgramId = { $in: [] };\n        }\n        program.forEach((p) => {\n            query.CNCProgramId.$in.push(p._id);\n        });\n    }\n    ;\n    if (shops && shops.length > 0) {\n        const allShops = await shopModel_1.default.find({ shopName: { $in: shops } });\n        const shopIds = allShops.map((a) => a._id);\n        const processes = await globalProcessModel_1.default.find({ \"shop.shopId\": { $in: shopIds } });\n        const processIds = processes.map((p) => p._id);\n        const program = await CNCProgramModel_1.default.find({ processId: { $in: processIds } });\n        if (!query.CNCProgramId) {\n            query.CNCProgramId = { $in: [] };\n        }\n        program.forEach((p) => {\n            query.CNCProgramId.$in.push(p._id);\n        });\n    }\n    ;\n    if (processes && processes.length > 0) {\n        const Processes = await globalProcessModel_1.default.find({ processName: { $in: processes } });\n        const processIds = Processes.map((p) => p._id);\n        const program = await CNCProgramModel_1.default.find({ processId: { $in: processIds } });\n        if (!query.CNCProgramId) {\n            query.CNCProgramId = { $in: [] };\n        }\n        ;\n        program.forEach((p) => {\n            query.CNCProgramId.$in.push(p._id);\n        });\n    }\n    ;\n    let logs;\n    if (sort === \"latest\") {\n        logs = await CNCProgramLogModel_1.default.find({ ...query }).populate(\"CNCProgramId\").sort({ createdAt: -1 }).lean();\n    }\n    else if (sort === \"oldest\") {\n        logs = await CNCProgramLogModel_1.default.find({ ...query }).populate(\"CNCProgramId\").sort({ createdAt: 1 }).lean();\n    }\n    else {\n        logs = await CNCProgramLogModel_1.default.find({ ...query }).populate(\"CNCProgramId\").lean();\n    }\n    ;\n    // const productionSlipNumber = await ProductionSlipModel.find().lean();\n    // const productionSlipsStore:any = {};\n    // productionSlipNumber.forEach((p)=>{\n    //  const number = p.productionSlipNumber ;\n    //  productionSlipsStore[number] = {\n    //    ...p\n    //  };\n    // });\n    // const result:any = [];\n    // logs.forEach((l)=>{\n    //   const productionSlips:any = [];\n    //   l.productionSlipNumber.forEach((p)=>{\n    //      const number = p;\n    //      const data =  productionSlipsStore[number];\n    //      productionSlips.push(data);\n    //   });\n    //   result.push({\n    //     ...l\n    //     ,productionSlipNumber:productionSlips\n    //   });\n    // });\n    const result = [];\n    const allProcesses = await globalProcessModel_1.default.find({}).lean();\n    const processStore = {};\n    allProcesses.forEach((a) => {\n        const id = a._id + \"\";\n        processStore[id] = { ...a };\n    });\n    logs.forEach((l) => {\n        const processId = l.CNCProgramId.processId + \"\";\n        const name = processStore[processId].processName;\n        const obj = {\n            ...l\n        };\n        obj.CNCProgramId.processName = name;\n        result.push(obj);\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting all data successfully.\",\n        logs: result\n    });\n});\n// delete a CNC Program\nexports.deleteCNCProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const program = await CNCProgramModel_1.default.findById(id);\n    if (!program) {\n        return resp.status(404).json({\n            success: false,\n            message: `Program with id ${id} not found.`\n        });\n    }\n    ;\n    const allLogs = await CNCProgramLogModel_1.default.find({ CNCProgramId: program._id }).lean();\n    if (allLogs.length > 0) {\n        return resp.status(400).json({\n            success: false,\n            message: `This program have total ${allLogs.length} logs.`\n        });\n    }\n    ;\n    await CNCProgramModel_1.default.findByIdAndDelete(program._id);\n    resp.status(200).json({\n        success: true,\n        message: `Program with Id ${id} deleted.`\n    });\n});\n// Delete CNC Program Logs\nexports.CNCProgramLogsDelete = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { logId } = req.params;\n    const log = await CNCProgramLogModel_1.default.findByIdAndDelete(logId);\n    return resp.status(200).json({\n        success: true,\n        message: \"Log deleted successfully.\",\n    });\n});\n// delete a chlidPart in CNCProgram\nexports.deleteChildPartFromProgram = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const { childPartId } = req.body;\n    const program = await CNCProgramModel_1.default.findById(id);\n    if (!program) {\n        return resp.status(404).json({\n            success: false,\n            message: `Program with Id ${id} not found.`\n        });\n    }\n    ;\n    program.childParts = program.childParts.filter((p) => p._id?.toString() !== childPartId);\n    await program.save();\n    resp.status(200).json({\n        success: true,\n        message: \"Program updated successfully.\",\n        CNCProgram: program\n    });\n});\n// // api for raw material id storing in cnc Program\n// export const addRawMaterialId = catchErrorAsync(async (req,resp,next)=>{\n//    const allCNCProgram = await CNCProgramModel.find();\n//    const allRawMaterial = await ChildPartModel.find().lean();\n//    const allRawMaterialStore:any = {};\n//    allRawMaterial.forEach((a)=>{\n//         const name = a.partName+\"\";\n//         allRawMaterialStore[name] = {\n//           ...a\n//         };\n//    });\n//    for (let i of allCNCProgram ){\n//     const program = await CNCProgramModel.findById(i._id);\n//     const rawMaterial = allRawMaterialStore[program?.rawMaterialName+\"\"];\n//     if(program){\n//     program.rawMaterialId= rawMaterial._id;\n//     await program.save()\n//     };\n//    };\n//    resp.status(200).json({\n//     success:true,\n//     message:`Done.`\n//    });\n// });\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/CNCProgramController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/InventoryController.ts":
/*!***************************************************************!*\
  !*** ./src/controllers/bomControllers/InventoryController.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAllInventoryByWorkOrder = exports.getDataInventory = void 0;\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst workOrderModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workOrderModel */ \"./src/database/models/workOrderModel.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\nconst planningModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/planningModel */ \"./src/database/models/planningModel.ts\"));\nconst getDataInventory = async (req, resp, next) => {\n    let { workOrderNumbers, name, MCodes, date, nextDate, status, customers, process, shop, startDate = new Date(), days = 7, } = req.body;\n    try {\n        startDate = new Date(startDate);\n        const month = new Date();\n        month.setDate(1);\n        month.setUTCHours(0, 0, 0, 0);\n        const currentDate = new Date();\n        currentDate.setUTCHours(0, 0, 0, 0);\n        const allFinishedItems = await finishedItemModel_1.default.find().lean();\n        const finishedItemStore = {};\n        allFinishedItems.forEach((a) => {\n            const id = a._id + \"\";\n            finishedItemStore[id] = { ...a };\n        });\n        const allChildParts = await childPartModel_1.default.find().lean();\n        const partStore = {};\n        allChildParts.forEach((a) => {\n            const id = a._id + \"\";\n            partStore[id] = {\n                ...a,\n                neededQuantity: 0,\n                totalProduced: 0,\n            };\n        });\n        const allChildPartStore = {};\n        allChildParts.forEach((a) => {\n            if (a.consumedItem) {\n                a.consumedItem.forEach((c) => {\n                    const id = c.itemId + \"\";\n                    allChildPartStore[id] = {\n                        parentId: a._id,\n                    };\n                });\n            }\n        });\n        const planning = await planningModel_1.default.find({ month }).lean();\n        const planningStore = {};\n        const maxDays = planning[0].dates.length;\n        for (let plan of planning) {\n            const finishedItem = finishedItemStore[plan.finishedItemId + \"\"];\n            const minimumInventory = plan?.minimumInventory\n                ? plan.minimumInventory\n                : 0;\n            const MCode = finishedItem?.MCode + \"\";\n            const lastDay = new Date().getDate() + days < maxDays\n                ? new Date().getDate() + days\n                : maxDays;\n            for (let i = 0; i < lastDay; i++) {\n                const p = plan.dates[i];\n                if (!planningStore[MCode]) {\n                    planningStore[MCode] = {\n                        orderValue: minimumInventory || 0,\n                        dispatchValue: 0,\n                    };\n                }\n                planningStore[MCode].orderValue += p.orderValue;\n                planningStore[MCode].dispatchValue += p.dispatchValue;\n            }\n            // const data = await getBomItemWithQuantity(req,resp,plan.finishedItemId,1);\n            // data?.newFinishItem.items.forEach((d:any)=>{\n            //   const id = d._id+\"\";\n            //   partStore[id] = {\n            //     numberOfItem:d.numberOfItem\n            //   };\n            // });\n        }\n        name = name?.toLowerCase()?.trim();\n        const productionSlipStore = {};\n        const allProductionSlips = await productionSlipModel_1.default.find({}).lean();\n        allProductionSlips.forEach((a) => {\n            const id = a.workOrderId + \"\";\n            if (!productionSlipStore[id]) {\n                productionSlipStore[id] = {\n                    slips: [],\n                };\n            }\n            productionSlipStore[id].slips.push({\n                ...a,\n            });\n        });\n        const query = {};\n        if (workOrderNumbers && workOrderNumbers.length > 0) {\n            query.orderNumber = { $in: workOrderNumbers };\n        }\n        if (MCodes && MCodes.length > 0) {\n            query.MCode = { $in: MCodes };\n        }\n        if (date) {\n            const newDate = new Date(date);\n            newDate.setHours(0, 0, 0, 0);\n            let newNextDate;\n            if (nextDate) {\n                newNextDate = new Date(nextDate);\n                newNextDate.setHours(0, 0, 0, 0);\n                newNextDate.setDate(newNextDate.getDate() + 1);\n            }\n            else {\n                newNextDate = new Date(newDate);\n                newNextDate.setDate(newDate.getDate() + 1);\n            }\n            query.date = {\n                $gte: newDate,\n                $lt: newNextDate,\n            };\n        }\n        if (status && status.length > 0) {\n            query.status = { $in: status };\n        }\n        if (customers && customers.length > 0) {\n            query.customerName = { $in: customers };\n        }\n        const allProcesses = await globalProcessModel_1.default.find({}).lean();\n        const processStore = {};\n        allProcesses.forEach((a) => {\n            const id = a._id + \"\";\n            processStore[id] = {\n                ...a,\n            };\n        });\n        let workOrders = await workOrderModel_1.default\n            .find({ ...query, status: { $nin: [\"cancel\"] } })\n            .lean();\n        const newStore = {};\n        workOrders.forEach((w) => {\n            const id = w._id + \"\";\n            newStore[id] = {};\n            const store = newStore[id];\n            w.masterBom.forEach((w) => {\n                const numberOfItems = w.numberOfItem;\n                w.newChild.forEach((n) => {\n                    if (n.numberOfItem) {\n                        const singleConsumption = n.numberOfItem / numberOfItems;\n                        const id = n._id + \"\";\n                        store[id] = singleConsumption;\n                    }\n                });\n            });\n        });\n        const result = [];\n        workOrders.forEach((w) => {\n            const workOrderId = w._id + \"\";\n            // const orderQuantity = w.orderQuantity;\n            const productionSlips = productionSlipStore[workOrderId];\n            // if (!productionSlips) {\n            //   return;\n            // }\n            let count = 1;\n            w.masterBom.forEach((m) => {\n                const numberOfItems = m.numberOfItem;\n                const childPartId = m._id + \"\";\n                let itemProduced = 0;\n                let itemConsumed = 0;\n                let rawMaterial = [];\n                let processId = m.processId + \"\";\n                let processDetails = processStore[processId];\n                let shopName = processDetails.shop.shopName;\n                if (m.newChild) {\n                    m.newChild.forEach((c) => {\n                        if (c.unit) {\n                            if (c.numberOfItem) {\n                                const partId = c._id + \"\";\n                                const consumptionPerOneItem = newStore[workOrderId][partId];\n                                const obj = {\n                                    consumptionPerOneItem,\n                                    childPartName: c.partName,\n                                    unit: c.unit,\n                                    materialCode: c.materialCode,\n                                    consumptionGodown: c.consumptionGodownName,\n                                };\n                                rawMaterial.push(obj);\n                            }\n                        }\n                    });\n                }\n                let numberOfSlips = 0;\n                let activeSlips = 0;\n                let completedSlips = 0;\n                let cancelledSlips = 0;\n                let cncSlips = 0;\n                let manualSlips = 0;\n                let manualProduced = 0;\n                productionSlips?.slips.forEach((p) => {\n                    if (p.consumedItem) {\n                        p.consumedItem.forEach((c) => {\n                            const id = c._id + \"\";\n                            if (id === childPartId) {\n                                const consumptionPerOneItem = newStore[workOrderId][id];\n                                itemConsumed += p.itemProduced * consumptionPerOneItem;\n                            }\n                        });\n                    }\n                    if (p.part._id + \"\" === childPartId) {\n                        numberOfSlips++;\n                        if (p.status === \"cancel\") {\n                            cancelledSlips++;\n                            return;\n                        }\n                        else if (p.status === \"active\") {\n                            activeSlips++;\n                        }\n                        else if (p.status === \"completed\") {\n                            completedSlips++;\n                        }\n                        else if (p.status === \"manual\") {\n                            manualProduced += p.itemProduced;\n                            manualSlips++;\n                        }\n                        else if (p.status === \"cnc\") {\n                            cncSlips++;\n                        }\n                        // shopName = p.shop.shopName;\n                        itemProduced += p.itemProduced;\n                    }\n                });\n                if (name) {\n                    if (w.orderNumber?.toLowerCase().includes(name) ||\n                        w.partCode?.toLowerCase().includes(name) ||\n                        w.finishItemName?.toLowerCase().includes(name) ||\n                        w.MCode?.toLowerCase().includes(name) ||\n                        m.partName?.toLowerCase().includes(name) ||\n                        processStore[m.processId + \"\"]?.processName\n                            ?.toLowerCase()\n                            .includes(name) ||\n                        shopName?.toLowerCase().includes(name)) {\n                        if (process || shop) {\n                            if (process && shop) {\n                                if (processStore[m.processId + \"\"]?.processName === process &&\n                                    shopName === shop) {\n                                    const obj = {\n                                        partName: m.partName,\n                                        shopName,\n                                        partId: m._id,\n                                        MCode: w.MCode,\n                                        processName: processStore[m.processId + \"\"]?.processName,\n                                        itemConsumed,\n                                        itemProduced,\n                                        manualProduced,\n                                        numberOfItems,\n                                        inventory: itemProduced - itemConsumed,\n                                        rawMaterial,\n                                        numberOfSlips,\n                                        activeSlips,\n                                        cancelledSlips,\n                                        completedSlips,\n                                        cncSlips,\n                                        manualSlips,\n                                        serialNumber: count,\n                                    };\n                                    result.push(obj);\n                                }\n                                else {\n                                    return;\n                                }\n                            }\n                            else if (processStore[m.processId + \"\"]?.processName === process) {\n                                const obj = {\n                                    partName: m.partName,\n                                    shopName,\n                                    partId: m._id,\n                                    MCode: w.MCode,\n                                    processName: processStore[m.processId + \"\"]?.processName,\n                                    itemConsumed,\n                                    itemProduced,\n                                    manualProduced,\n                                    numberOfItems,\n                                    inventory: itemProduced - itemConsumed,\n                                    rawMaterial,\n                                    numberOfSlips,\n                                    activeSlips,\n                                    cancelledSlips,\n                                    completedSlips,\n                                    cncSlips,\n                                    manualSlips,\n                                    serialNumber: count,\n                                };\n                                result.push(obj);\n                            }\n                            else if (shopName === shop) {\n                                const obj = {\n                                    partId: m._id,\n                                    MCode: w.MCode,\n                                    shopName,\n                                    partName: m.partName,\n                                    processName: processStore[m.processId + \"\"]?.processName,\n                                    itemConsumed,\n                                    itemProduced,\n                                    manualProduced,\n                                    numberOfItems,\n                                    inventory: itemProduced - itemConsumed,\n                                    rawMaterial,\n                                    numberOfSlips,\n                                    activeSlips,\n                                    cancelledSlips,\n                                    completedSlips,\n                                    cncSlips,\n                                    manualSlips,\n                                    serialNumber: count,\n                                };\n                                result.push(obj);\n                            }\n                            else {\n                                return;\n                            }\n                        }\n                        else {\n                            const obj = {\n                                partId: m._id,\n                                MCode: w.MCode,\n                                shopName,\n                                partName: m.partName,\n                                processName: processStore[m.processId + \"\"]?.processName,\n                                itemConsumed,\n                                itemProduced,\n                                manualProduced,\n                                numberOfItems,\n                                inventory: itemProduced - itemConsumed,\n                                rawMaterial,\n                                numberOfSlips,\n                                activeSlips,\n                                cancelledSlips,\n                                completedSlips,\n                                cncSlips,\n                                manualSlips,\n                                serialNumber: count,\n                            };\n                            result.push(obj);\n                        }\n                    }\n                    else {\n                        return;\n                    }\n                }\n                else {\n                    if ((process\n                        ? processStore[m.processId + \"\"]?.processName === process\n                        : true) &&\n                        (shop ? shopName === shop : true)) {\n                        const obj = {\n                            numberOfSlips,\n                            MCode: w.MCode,\n                            shopName,\n                            partId: m._id,\n                            orderNumber: w.orderNumber,\n                            partName: m.partName,\n                            processName: processStore[m.processId + \"\"]?.processName,\n                            itemConsumed,\n                            itemProduced,\n                            manualProduced,\n                            numberOfItems,\n                            activeSlips,\n                            cancelledSlips,\n                            completedSlips,\n                            cncSlips,\n                            manualSlips,\n                            inventory: itemProduced - itemConsumed,\n                            rawMaterial,\n                            serialNumber: count,\n                        };\n                        result.push(obj);\n                    }\n                }\n                count++;\n            });\n        });\n        const newCombineResult = {};\n        result.forEach((r) => {\n            const name = r.partName + \"\";\n            if (!newCombineResult[name]) {\n                newCombineResult[name] = {\n                    data: [],\n                };\n            }\n            newCombineResult[name].data.push({ ...r });\n        });\n        const resultArray = [];\n        for (const partName in newCombineResult) {\n            if (newCombineResult.hasOwnProperty(partName)) {\n                resultArray.push(newCombineResult[partName].data);\n            }\n        }\n        const finalResultObj = {};\n        // breakpoint ------------------- here we are setting the mCode with the complete bom\n        resultArray.forEach((r) => {\n            const MCode = r[0].MCode + \"\";\n            if (!finalResultObj[MCode]) {\n                finalResultObj[MCode] = {\n                    MCode: r[0].MCode,\n                    items: [],\n                };\n            }\n            finalResultObj[MCode].items.push(r);\n        });\n        const resultArray1 = [];\n        for (const partName in finalResultObj) {\n            if (finalResultObj.hasOwnProperty(partName)) {\n                resultArray1.push(finalResultObj[partName]);\n            }\n        }\n        const newResult = [];\n        resultArray1.forEach((r) => {\n            const finishedItemData = [];\n            const MCode = r.MCode + \"\";\n            const planning = planningStore[MCode];\n            const orderValue = planning?.orderValue || 0;\n            const dispatchValue = planning?.dispatchValue || 0;\n            const requirement = orderValue - dispatchValue;\n            let numberOfSlips = 0;\n            let cancelledSlips = 0;\n            let activeSlips = 0;\n            let completedSlips = 0;\n            let cncSlips = 0;\n            let manualSlips = 0;\n            let manualProduced = 0;\n            let totalFinishedItem = 0;\n            let numberOfSlips1 = 0;\n            let cancelledSlips1 = 0;\n            let activeSlips1 = 0;\n            let completedSlips1 = 0;\n            let cncSlips1 = 0;\n            let manualSlips1 = 0;\n            let manualProduced1 = 0;\n            let numberOfFinishedItem = 0;\n            let finishedItemConsumed = 0;\n            let totalLoading = 0;\n            let numberOfloading = 0;\n            let finishedItemInventory = 0;\n            // console.log(r.items);\n            // for Loading\n            r.items[r.items.length - 1].forEach((r) => {\n                totalLoading += r.itemProduced;\n                numberOfloading += r.numberOfItems;\n                numberOfSlips += r.numberOfSlips;\n                cancelledSlips += r.cancelledSlips;\n                activeSlips += r.activeSlips;\n                completedSlips += r.completedSlips;\n                cncSlips += r.cncSlips;\n                manualSlips += r.manualSlips;\n                manualProduced += r.manualProduced;\n            });\n            const loading = {\n                ...r.items[r.items.length - 1][0],\n                itemProduced: totalLoading,\n                numberOfItems: numberOfloading,\n                planningRequirement: requirement,\n                numberOfSlips,\n                cancelledSlips,\n                activeSlips,\n                completedSlips,\n                cncSlips,\n                manualSlips,\n                manualProduced,\n            };\n            console.log(\"loading is...\", loading);\n            finishedItemData.push(loading);\n            // for finished Item\n            const finishedItem = r.items[r.items.length - 2];\n            r.items[r.items.length - 2]?.forEach((r) => {\n                totalFinishedItem += r.itemProduced;\n                numberOfFinishedItem += r.numberOfItems;\n                finishedItemConsumed += r.itemConsumed;\n                finishedItemInventory += r.inventory;\n                numberOfSlips1 += r.numberOfSlips;\n                cancelledSlips1 += r.cancelledSlips;\n                activeSlips1 += r.activeSlips;\n                completedSlips1 += r.completedSlips;\n                manualProduced1 += r.manualProduced;\n            });\n            const currentProductionRequirement = requirement - finishedItemInventory;\n            const partDetails = partStore[finishedItem[0].partId];\n            if (!partDetails) {\n                return;\n            }\n            partDetails.neededQuantity = currentProductionRequirement;\n            partDetails.itemProduced = totalFinishedItem;\n            const obj = {\n                ...r.items[r.items.length - 2][0],\n                parentName: r.items[r.items.length - 1][0].partName,\n                parentProduced: totalLoading,\n                numberOfItems: numberOfFinishedItem,\n                finishedItemConsumed: finishedItemConsumed,\n                inventory: finishedItemInventory,\n                planningRequirement: currentProductionRequirement,\n                numberOfSlips: numberOfSlips1,\n                cancelledSlips: cancelledSlips1,\n                activeSlips: activeSlips1,\n                completedSlips: completedSlips1,\n                cncSlips: cncSlips1,\n                manualSlips: manualSlips1,\n                singleQuantity: 1,\n                manualProduced: manualProduced1,\n            };\n            finishedItemData.push(obj);\n            for (let i = r.items.length - 3; i >= 0; i--) {\n                /////////////////\n                let numberOfSlips = 0;\n                let cancelledSlips = 0;\n                let activeSlips = 0;\n                let completedSlips = 0;\n                let itemConsumed = 0;\n                let itemProduced = 0;\n                let inventory = 0;\n                let numberOfItems = 0;\n                let cncSlips = 0;\n                let manualSlips = 0;\n                let manualProduced = 0;\n                r.items[i].forEach((r) => {\n                    itemProduced += r.itemProduced;\n                    numberOfItems += r.numberOfItems;\n                    itemConsumed += r.itemConsumed;\n                    inventory += r.inventory;\n                    numberOfSlips += r.numberOfSlips;\n                    cancelledSlips += r.cancelledSlips;\n                    activeSlips += r.activeSlips;\n                    completedSlips += r.completedSlips;\n                    cncSlips += r.cncSlips;\n                    manualSlips += r.manualSlips;\n                    manualProduced += r.manualProduced;\n                });\n                /////////////////\n                const partId = r.items[i][0].partId + \"\";\n                if (!partStore[partId]) {\n                    return;\n                }\n                const parentId = allChildPartStore[partId]?.parentId + \"\";\n                const parentDetails = partStore[parentId];\n                const parentName = parentDetails?.partName || \"\";\n                const parentProduced = parentDetails?.itemProduced;\n                const parentNeededQuantity = parentDetails?.neededQuantity || 0;\n                let childQuantityNeededPerSingle = 0;\n                parentDetails?.consumedItem.forEach((p) => {\n                    if (p.itemId + \"\" === partId + \"\") {\n                        childQuantityNeededPerSingle = p.consumedItemQuantity;\n                    }\n                });\n                partStore[partId].neededQuantity =\n                    parentNeededQuantity * childQuantityNeededPerSingle - inventory;\n                partStore[partId].itemProduced = itemProduced;\n                const obj = {\n                    ...r.items[i][0],\n                    itemProduced,\n                    parentName,\n                    parentProduced,\n                    numberOfItems,\n                    itemConsumed,\n                    inventory,\n                    numberOfSlips,\n                    cancelledSlips,\n                    activeSlips,\n                    completedSlips,\n                    cncSlips,\n                    manualSlips,\n                    singleQuantity: childQuantityNeededPerSingle,\n                    manualProduced,\n                    planningRequirement: parentNeededQuantity * childQuantityNeededPerSingle - inventory,\n                    parentNeeded: parentNeededQuantity,\n                };\n                finishedItemData.push(obj);\n            }\n            newResult.push(finishedItemData);\n        });\n        resp.status(200).json({\n            success: true,\n            message: \"Getting all the data for inventory.\",\n            // resultArray,\n            // result,\n            // resultArray: resultArray1,\n            newResult,\n            // partStore\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.getDataInventory = getDataInventory;\nconst getAllInventoryByWorkOrder = async (req, resp, next) => {\n    try {\n        let { workOrderNumbers, name, MCodes, date, nextDate, status, customers, process, shop, days = 7, minInventory, } = req.body;\n        let allProductionSlips;\n        name = name?.toLowerCase()?.trim();\n        const productionSlipStore = {};\n        allProductionSlips = await productionSlipModel_1.default.find({}).lean();\n        allProductionSlips.forEach((a) => {\n            const id = a.workOrderId + \"\";\n            if (!productionSlipStore[id]) {\n                productionSlipStore[id] = {\n                    slips: [],\n                };\n            }\n            productionSlipStore[id].slips.push({\n                ...a,\n            });\n        });\n        const month = new Date();\n        month.setDate(1);\n        month.setUTCHours(0, 0, 0, 0);\n        const currentDate = new Date();\n        currentDate.setUTCHours(0, 0, 0, 0);\n        const allFinishedItems = await finishedItemModel_1.default.find().lean();\n        const finishedItemStore = {};\n        allFinishedItems.forEach((a) => {\n            const id = a._id + \"\";\n            finishedItemStore[id] = { ...a };\n        });\n        const allChildParts = await childPartModel_1.default.find().lean();\n        const partStore = {};\n        allChildParts.forEach((a) => {\n            const id = a._id + \"\";\n            partStore[id] = {\n                ...a,\n                neededQuantity: 0,\n                totalProduced: 0,\n            };\n        });\n        const allChildPartStore = {};\n        allChildParts.forEach((a) => {\n            if (a.consumedItem) {\n                a.consumedItem.forEach((c) => {\n                    const id = c.itemId + \"\";\n                    allChildPartStore[id] = {\n                        parentId: a._id,\n                    };\n                });\n            }\n        });\n        const planning = await planningModel_1.default.find({ month }).lean();\n        const planningStore = {};\n        const maxDays = planning[0]?.dates.length;\n        for (let plan of planning) {\n            const finishedItem = finishedItemStore[plan.finishedItemId + \"\"];\n            const minimumInventory = plan?.minimumInventory\n                ? plan.minimumInventory\n                : 0;\n            const MCode = finishedItem?.MCode + \"\";\n            const lastDay = new Date().getDate() + days < maxDays\n                ? new Date().getDate() + days\n                : maxDays;\n            for (let i = 0; i < lastDay; i++) {\n                const p = plan?.dates[i];\n                if (!planningStore[MCode]) {\n                    planningStore[MCode] = {\n                        orderValue: (minInventory ? minimumInventory : 0) || 0,\n                        dispatchValue: 0,\n                    };\n                }\n                planningStore[MCode].orderValue += p.orderValue;\n                planningStore[MCode].dispatchValue += p.dispatchValue;\n            }\n        }\n        const query = {};\n        if (workOrderNumbers && workOrderNumbers.length > 0) {\n            query.orderNumber = { $in: workOrderNumbers };\n        }\n        if (MCodes && MCodes.length > 0) {\n            query.MCode = { $in: MCodes };\n        }\n        let newDate;\n        let newNextDate;\n        if (date) {\n            newDate = new Date(date);\n            newDate.setHours(0, 0, 0, 0);\n            if (nextDate) {\n                newNextDate = new Date(nextDate);\n                newNextDate.setHours(0, 0, 0, 0);\n                newNextDate.setDate(newNextDate.getDate() + 1);\n            }\n            else {\n                newNextDate = new Date(newDate);\n                newNextDate.setDate(newDate.getDate() + 1);\n            }\n            // query.date = {\n            //   $gte: newDate,\n            //   $lt: newNextDate,\n            // };\n        }\n        else {\n            newDate = new Date();\n            newDate.setHours(0, 0, 0, 0);\n            newNextDate = new Date(newDate);\n            newNextDate.setDate(newDate.getDate() + 1);\n        }\n        if (status && status.length > 0) {\n            query.status = { $in: status };\n        }\n        if (customers && customers.length > 0) {\n            query.customerName = { $in: customers };\n        }\n        const allProcesses = await globalProcessModel_1.default.find({}).lean();\n        const processStore = {};\n        allProcesses.forEach((a) => {\n            const id = a._id + \"\";\n            processStore[id] = {\n                ...a,\n            };\n        });\n        let workOrders = await workOrderModel_1.default\n            .find({ ...query, status: { $nin: [\"cancel\"] } })\n            .lean();\n        const finishedItemCountStore = {};\n        const newStore = {};\n        workOrders.forEach((w) => {\n            const id = w._id + \"\";\n            newStore[id] = {};\n            const store = newStore[id];\n            const MCode = w.MCode + \"\";\n            if (!finishedItemCountStore[MCode]) {\n                finishedItemCountStore[MCode] = { count: 1 };\n            }\n            else {\n                finishedItemCountStore[MCode].count += 1;\n            }\n            w.masterBom.forEach((w) => {\n                const numberOfItems = w.numberOfItem;\n                w.newChild.forEach((n) => {\n                    if (n.numberOfItem) {\n                        const singleConsumption = n.numberOfItem / numberOfItems;\n                        const id = n._id + \"\";\n                        store[id] = singleConsumption;\n                    }\n                });\n            });\n        });\n        const workOrderStore = {};\n        workOrders.forEach((w) => {\n            const orderNumber = w.orderNumber + \"\";\n            workOrderStore[orderNumber] = {\n                orderQuantity: w.orderQuantity,\n            };\n        });\n        const result = [];\n        workOrders.forEach((w) => {\n            const workOrderId = w._id + \"\";\n            const workOrderArray = [];\n            const productionSlips = productionSlipStore[workOrderId];\n            let check = false;\n            if (w.orderNumber?.toLowerCase().includes(name) ||\n                w.partCode?.toLowerCase().includes(name) ||\n                w.finishItemName?.toLowerCase().includes(name) ||\n                w.MCode?.toLowerCase().includes(name)) {\n                check = true;\n            }\n            w.masterBom.forEach((m) => {\n                const numberOfItems = m.numberOfItem;\n                const childPartId = m._id + \"\";\n                let itemProduced = 0;\n                let itemConsumed = 0;\n                let rawMaterial = [];\n                if (m.newChild) {\n                    m.newChild.forEach((c) => {\n                        if (c.unit) {\n                            if (c.numberOfItem) {\n                                const partId = c._id + \"\";\n                                const consumptionPerOneItem = newStore[workOrderId][partId];\n                                const obj = {\n                                    consumptionPerOneItem,\n                                    childPartName: c.partName,\n                                    unit: c.unit,\n                                    materialCode: c.materialCode,\n                                    consumptionGodown: c.consumptionGodownName,\n                                };\n                                rawMaterial.push(obj);\n                            }\n                        }\n                    });\n                }\n                let numberOfSlips = 0;\n                let activeSlips = 0;\n                let inactiveSlips = 0;\n                let shopName = \"\";\n                let currentProduction = 0;\n                productionSlips?.slips.forEach((p) => {\n                    if (p.consumedItem) {\n                        p.consumedItem.forEach((c) => {\n                            const id = c._id + \"\";\n                            if (id === childPartId) {\n                                const consumptionPerOneItem = newStore[workOrderId][id];\n                                itemConsumed += p.itemProduced * consumptionPerOneItem;\n                            }\n                        });\n                    }\n                    if (p.part._id + \"\" === childPartId) {\n                        if (p.status === \"active\") {\n                            activeSlips++;\n                        }\n                        if (p.status === \"inactive\") {\n                            inactiveSlips++;\n                        }\n                        shopName = p?.shop?.shopName;\n                        numberOfSlips++;\n                        itemProduced += p.itemProduced;\n                        if (new Date(p.updatedAt).getTime() >= new Date(newDate).getTime() &&\n                            new Date(p.updatedAt).getTime() <= new Date(newNextDate).getTime()) {\n                            currentProduction += p.itemProduced;\n                        }\n                    }\n                });\n                if (name && check === false) {\n                    if (m.partName?.toLowerCase().includes(name) ||\n                        processStore[m.processId + \"\"]?.processName\n                            ?.toLowerCase()\n                            .includes(name) ||\n                        shopName?.toLowerCase().includes(name)) {\n                        if (process || shop) {\n                            if (process && shop) {\n                                if (processStore[m.processId + \"\"]?.processName === process &&\n                                    shopName === shop) {\n                                    const obj = {\n                                        partId: m._id,\n                                        partName: m.partName,\n                                        processName: processStore[m.processId + \"\"]?.processName,\n                                        itemConsumed,\n                                        currentProduction,\n                                        itemProduced,\n                                        numberOfItems,\n                                        inventory: itemProduced - itemConsumed,\n                                        rawMaterial,\n                                        numberOfSlips,\n                                        activeSlips,\n                                        inactiveSlips,\n                                    };\n                                    workOrderArray.push(obj);\n                                }\n                                else {\n                                    return;\n                                }\n                            }\n                            else if (processStore[m.processId + \"\"]?.processName === process) {\n                                const obj = {\n                                    partId: m._id,\n                                    partName: m.partName,\n                                    processName: processStore[m.processId + \"\"]?.processName,\n                                    itemConsumed,\n                                    itemProduced,\n                                    currentProduction,\n                                    numberOfItems,\n                                    inventory: itemProduced - itemConsumed,\n                                    rawMaterial,\n                                    numberOfSlips,\n                                    activeSlips,\n                                    inactiveSlips,\n                                };\n                                workOrderArray.push(obj);\n                            }\n                            else if (shopName === shop) {\n                                const obj = {\n                                    partId: m._id,\n                                    partName: m.partName,\n                                    processName: processStore[m.processId + \"\"]?.processName,\n                                    itemConsumed,\n                                    itemProduced,\n                                    currentProduction,\n                                    numberOfItems,\n                                    inventory: itemProduced - itemConsumed,\n                                    rawMaterial,\n                                    numberOfSlips,\n                                    activeSlips,\n                                    inactiveSlips,\n                                };\n                                workOrderArray.push(obj);\n                            }\n                            else {\n                                return;\n                            }\n                        }\n                        else {\n                            const obj = {\n                                partId: m._id,\n                                partName: m.partName,\n                                processName: processStore[m.processId + \"\"]?.processName,\n                                itemConsumed,\n                                itemProduced,\n                                numberOfItems,\n                                currentProduction,\n                                inventory: itemProduced - itemConsumed,\n                                rawMaterial,\n                                numberOfSlips,\n                                activeSlips,\n                                inactiveSlips,\n                            };\n                            workOrderArray.push(obj);\n                        }\n                    }\n                    else {\n                        return;\n                    }\n                }\n                else if (check === true) {\n                    if (process || shop) {\n                        if (process && shop) {\n                            if (processStore[m.processId + \"\"]?.processName === process &&\n                                shopName === shop) {\n                                const obj = {\n                                    partId: m._id,\n                                    partName: m.partName,\n                                    processName: processStore[m.processId + \"\"]?.processName,\n                                    itemConsumed,\n                                    itemProduced,\n                                    currentProduction,\n                                    numberOfItems,\n                                    inventory: itemProduced - itemConsumed,\n                                    rawMaterial,\n                                    numberOfSlips,\n                                    activeSlips,\n                                    inactiveSlips,\n                                };\n                                workOrderArray.push(obj);\n                            }\n                            else {\n                                return;\n                            }\n                        }\n                        else if (processStore[m.processId + \"\"]?.processName === process) {\n                            const obj = {\n                                partId: m._id,\n                                partName: m.partName,\n                                processName: processStore[m.processId + \"\"]?.processName,\n                                itemConsumed,\n                                itemProduced,\n                                currentProduction,\n                                numberOfItems,\n                                inventory: itemProduced - itemConsumed,\n                                rawMaterial,\n                                numberOfSlips,\n                                activeSlips,\n                                inactiveSlips,\n                            };\n                            workOrderArray.push(obj);\n                        }\n                        else if (shopName === shop) {\n                            const obj = {\n                                partId: m._id,\n                                partName: m.partName,\n                                processName: processStore[m.processId + \"\"]?.processName,\n                                itemConsumed,\n                                itemProduced,\n                                currentProduction,\n                                numberOfItems,\n                                inventory: itemProduced - itemConsumed,\n                                rawMaterial,\n                                numberOfSlips,\n                                activeSlips,\n                                inactiveSlips,\n                            };\n                            workOrderArray.push(obj);\n                        }\n                        else {\n                            return;\n                        }\n                    }\n                    else {\n                        const obj = {\n                            partId: m._id,\n                            partName: m.partName,\n                            processName: processStore[m.processId + \"\"]?.processName,\n                            itemConsumed,\n                            itemProduced,\n                            currentProduction,\n                            numberOfItems,\n                            inventory: itemProduced - itemConsumed,\n                            rawMaterial,\n                            numberOfSlips,\n                            activeSlips,\n                            inactiveSlips,\n                        };\n                        workOrderArray.push(obj);\n                    }\n                }\n                else {\n                    if ((process\n                        ? processStore[m.processId + \"\"]?.processName === process\n                        : true) &&\n                        (shop ? shopName === shop : true)) {\n                        const obj = {\n                            partId: m._id,\n                            partName: m.partName,\n                            processName: processStore[m.processId + \"\"]?.processName,\n                            itemConsumed,\n                            itemProduced,\n                            currentProduction,\n                            numberOfItems,\n                            inventory: itemProduced - itemConsumed,\n                            rawMaterial,\n                            numberOfSlips,\n                            activeSlips,\n                            inactiveSlips,\n                        };\n                        workOrderArray.push(obj);\n                    }\n                    else {\n                        return;\n                    }\n                }\n            });\n            if (workOrderArray.length > 0) {\n                const obj = {\n                    MCode: w.MCode,\n                    status: w.status,\n                    orderNumber: w.orderNumber,\n                    childPart: workOrderArray,\n                    workOrderId: w._id\n                };\n                result.push(obj);\n            }\n        });\n        //--------------------------------------------------------------------------------------------------\n        const newResult = [];\n        result.forEach((r) => {\n            const finishedItemData = [];\n            const MCode = r.MCode + \"\";\n            const status = r.status;\n            const workOrderId = r.workOrderId;\n            const countWorkOrder = finishedItemCountStore[MCode].count;\n            const orderNumber = r.orderNumber;\n            const workOrderQuantity = workOrderStore[orderNumber + \"\"].orderQuantity;\n            const planning = planningStore[MCode];\n            const orderValue = planning?.orderValue || 0;\n            const dispatchValue = planning?.dispatchValue || 0;\n            const totalLoading = r.childPart[r.childPart.length - 1].itemProduced;\n            const requiredLoading = orderValue - dispatchValue;\n            let requirementWorkOrder;\n            requirementWorkOrder = workOrderQuantity - totalLoading;\n            if (countWorkOrder === 1 && requiredLoading > requirementWorkOrder) {\n                requirementWorkOrder = requiredLoading;\n            }\n            else if (requiredLoading < requirementWorkOrder) {\n                requirementWorkOrder = requiredLoading;\n            }\n            else {\n                requirementWorkOrder = workOrderQuantity - totalLoading;\n            }\n            finishedItemCountStore[MCode].count -= 1;\n            if (planningStore[MCode]) {\n                planningStore[MCode].orderValue =\n                    requiredLoading - requirementWorkOrder;\n            }\n            const loading = {\n                ...r.childPart[r.childPart.length - 1],\n                singleQuantity: 0,\n                planningRequirement: requirementWorkOrder,\n                parentNeeded: 0,\n            };\n            finishedItemData.push(loading);\n            // for finished Item\n            const finishedItemInventory = r.childPart[r.childPart.length - 2].inventory;\n            const totalFinishedItem = r.childPart[r.childPart.length - 2].itemProduced;\n            const currentProductionRequirement = requirementWorkOrder - finishedItemInventory;\n            const partDetails = partStore[r.childPart[r.childPart.length - 2].partId];\n            if (!partDetails) {\n                return;\n            }\n            partDetails.neededQuantity = currentProductionRequirement;\n            partDetails.itemProduced = totalFinishedItem;\n            const obj = {\n                ...r.childPart[r.childPart.length - 2],\n                singleQuantity: 1,\n                planningRequirement: currentProductionRequirement,\n                parentNeeded: 0,\n            };\n            finishedItemData.push(obj);\n            //-----------------------------loop --------------------------//\n            for (let i = r.childPart.length - 3; i >= 0; i--) {\n                const partId = r.childPart[i].partId + \"\";\n                if (!partStore[partId]) {\n                    return;\n                }\n                const itemProduced = r.childPart[i].itemProduced;\n                const inventory = r.childPart[i].inventory;\n                const parentId = allChildPartStore[partId]?.parentId + \"\";\n                const parentDetails = partStore[parentId];\n                const parentName = parentDetails?.partName || \"\";\n                const parentProduced = parentDetails?.itemProduced;\n                const parentNeededQuantity = parentDetails?.neededQuantity || 0;\n                let childQuantityNeededPerSingle = 0;\n                parentDetails?.consumedItem.forEach((p) => {\n                    if (p.itemId + \"\" === partId + \"\") {\n                        childQuantityNeededPerSingle = p.consumedItemQuantity;\n                    }\n                });\n                partStore[partId].neededQuantity =\n                    parentNeededQuantity * childQuantityNeededPerSingle - inventory;\n                partStore[partId].itemProduced = itemProduced;\n                const obj = {\n                    ...r.childPart[i],\n                    itemProduced,\n                    parentName,\n                    parentProduced,\n                    singleQuantity: childQuantityNeededPerSingle,\n                    planningRequirement: parentNeededQuantity * childQuantityNeededPerSingle - inventory,\n                    parentNeeded: parentNeededQuantity,\n                };\n                finishedItemData.push(obj);\n            }\n            const newObj = {\n                MCode,\n                workOrderId,\n                status,\n                orderNumber,\n                childPart: finishedItemData,\n            };\n            newResult.push(newObj);\n        });\n        resp.status(200).json({\n            success: true,\n            message: \"Getting all the data for inventory.\",\n            result,\n            newResult,\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.getAllInventoryByWorkOrder = getAllInventoryByWorkOrder;\n// // add process in childPart\n// export const testing = catchErrorAsync( async(req,resp,next)=>{\n//   const allFinishedItems = await FinishedItemModel.find({}).lean();\n//   const allProcesses = await globalProcessModel.find({}).lean();\n//   const processStore:any = {};\n//   allProcesses.forEach((a)=>{\n//     const id = a._id+\"\";\n//     processStore[id] = {...a};\n//   })\n//   const result:any = [];\n//   allFinishedItems.forEach(async (f)=>{\n//     f.masterBom?.forEach(async(m)=>{\n//      const childPartId = m.childPart?.id;\n//      const process = processStore[m.process?.id+\"\"];\n//      const childPart = await ChildPartModel.findOne({_id:childPartId});\n//      if(childPart){\n//      childPart.processId = process._id;\n//      childPart.processName = process.processName;\n//     }\n//     await childPart?.save();\n//     });\n//   });\n//   resp.status(200).json({\n//     success:true,\n//     message:\"getting all child\",\n//     result\n//   });\n// });\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/InventoryController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/childPartController.ts":
/*!***************************************************************!*\
  !*** ./src/controllers/bomControllers/childPartController.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.editChildPartName = exports.updateChildPart = exports.getChild = exports.getAllChildPart = exports.deleteChildPart = exports.addChildPart = void 0;\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst godownModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/godownModel */ \"./src/database/models/godownModel.ts\"));\nexports.addChildPart = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { partName, productionGodown, consumedItem } = req.body;\n    const godown = await godownModel_1.default.findById(productionGodown);\n    if (godown) {\n        const childPart = await childPartModel_1.default.create({\n            partName,\n            consumedItem,\n            productionGodown,\n        });\n        return resp.status(201).json({\n            success: true,\n            message: \"Child Part created successfully\",\n            childPart,\n        });\n    }\n    else {\n        return resp.status(201).json({\n            success: false,\n            message: \"godown not found\",\n        });\n    }\n});\nexports.deleteChildPart = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const part = await childPartModel_1.default.findById(id);\n    if (part) {\n        const childPart = await childPartModel_1.default.findByIdAndDelete(id);\n        return resp.status(201).json({\n            success: true,\n            message: \"Child Part deleted successfully\",\n            childPart,\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"Child Part not found\",\n        });\n    }\n});\nexports.getAllChildPart = (0, catchAsyncError_1.default)(async (req, resp) => {\n    // const allChild = await ChildPartModel.find({childPartType:undefined}).lean();\n    const allChild = await childPartModel_1.default.find({}).lean();\n    // const result:any = [];\n    // allChild.forEach((c)=>{\n    //  if( c.consumedItem &&c.consumedItem.length>0){\n    //   result.push({...c})\n    //  }\n    // })\n    return resp.status(201).json({\n        success: true,\n        message: \"Getting all ChildPart successfully\",\n        childParts: allChild,\n    });\n});\n// //single use\n// export const deleteUnwanted = catchErrorAsync(async(req,resp,next)=>{\n//   const data:any = await ChildPartModel.find({}).lean();\n//   let count = 1;\n//   for(let d of data){\n//     if(d.ID){\n//       const element:any = await ChildPartModel.findByIdAndDelete(d._id);\n//       count++;\n//     }\n//   };\n//   resp.status(200).json({\n//     success:true,\n//     count\n//   })\n// })\n// get child part with Id\nexports.getChild = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const childPart = await childPartModel_1.default.findById(id);\n    return resp.status(201).json({\n        success: true,\n        message: \"Getting Child Part successfully\",\n        childPart,\n    });\n});\n// update ChildPart\nexports.updateChildPart = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { productionGodown, itemConsumed, newName } = req.body;\n    const { id } = req.params;\n    const godown = await godownModel_1.default.findById(productionGodown);\n    if (!godown) {\n        return resp.status(201).json({\n            success: false,\n            message: \"godown not found\",\n        });\n    }\n    const childArray = [];\n    const childPartStore = {};\n    const childParts = await childPartModel_1.default.find().lean();\n    childParts.forEach((c) => {\n        const name = c.partName + \"\";\n        childPartStore[name] = {\n            ...c\n        };\n    });\n    // for checking childPart present or not\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n    });\n    const godownStore = {};\n    const godowns = await godownModel_1.default.find().lean();\n    godowns.forEach((g) => {\n        const name = g.godownName + \"\";\n        godownStore[name] = {\n            ...g\n        };\n    });\n    itemConsumed.forEach(async (i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n        const godown = godownStore[i.consumptionGodown];\n        childArray.push({\n            ...part,\n            quantity: i.quantity,\n            consumptionGodown: godown._id,\n        });\n    });\n    // updating the production according to consumptions \n    childArray.forEach(async (c) => {\n        const godown = c.consumptionGodown;\n        await childPartModel_1.default.findByIdAndUpdate({ _id: c._id }, { productionGodown: godown });\n    });\n    const newChildArray = [];\n    const newChildPart = await childPartModel_1.default.findById({ _id: id });\n    if (!newChildPart) {\n        return resp.status(404).json({\n            success: false,\n            message: \"ChildPart not found.\"\n        });\n    }\n    childArray.forEach((c) => {\n        const itemId = c._id;\n        const itemName = c.partName;\n        const itemType = \"child part\";\n        const consumedItemQuantity = c.quantity;\n        // const consumptionGodown = c.productionGodown ? c.productionGodown : c.consumptionGodown;\n        const consumptionGodown = c.consumptionGodown;\n        newChildArray.push({\n            itemId,\n            itemName,\n            itemType,\n            consumedItemQuantity,\n            consumptionGodown,\n        });\n    });\n    // console.log(newChildArray)\n    newChildPart.consumedItem = newChildArray;\n    newChildPart.productionGodown = godown._id;\n    if (newName && newName.trim() !== newChildPart.partName) {\n        const newChildNamePart = await childPartModel_1.default.findOne({ partName: newName });\n        if (newChildNamePart) {\n            return resp.status(400).json({\n                success: false,\n                message: `ChildPart with name ${newName} already present.`\n            });\n        }\n        newChildPart.partName = newName.trim();\n    }\n    await newChildPart.save();\n    return resp.status(201).json({\n        success: true,\n        message: \"Child Part updated successfully.\",\n        newChildPart\n    });\n});\n// edit childPart Name \nexports.editChildPartName = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const { newName } = req.body;\n    const childPart = await childPartModel_1.default.findOne({ _id: id });\n    if (!childPart) {\n        return resp.status(404).json({\n            success: false,\n            message: `ChildPart with `\n        });\n    }\n    const childPartWithName = await childPartModel_1.default.findOne({ partName: newName.trim() });\n    if (childPartWithName) {\n        return resp.status(400).json({\n            success: false,\n            message: `ChildPart with ${newName.trim()} already present.`\n        });\n    }\n    childPart.partName = newName.trim();\n    await childPart.save();\n    resp.status(200).json({\n        success: true,\n        message: \"Child part updated successfully.\",\n        childPart\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/childPartController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/customController.ts":
/*!************************************************************!*\
  !*** ./src/controllers/bomControllers/customController.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAllCustomer = exports.getCustomer = exports.deleteCustomer = exports.updateCoustomer = exports.addCustomer = void 0;\nconst customerModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/customerModel */ \"./src/database/models/customerModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nexports.addCustomer = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { customerName, code, date } = req.body;\n    const newDate = new Date(date);\n    const customer = await customerModel_1.default.create({ customerName, code, date: newDate });\n    return resp.status(201).json({\n        success: true,\n        message: \"customer created successfully\",\n        customer\n    });\n});\nexports.updateCoustomer = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    let { customerName, code } = req.body;\n    const customer = await customerModel_1.default.findById(id);\n    if (customer) {\n        const customer = await customerModel_1.default.findByIdAndUpdate({ _id: id }, { customerName, code });\n        return resp.status(201).json({\n            success: true,\n            message: \"customer updated successfully\",\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"customer not found\",\n        });\n    }\n});\n// delete customer \nexports.deleteCustomer = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const customer = await customerModel_1.default.findById(id);\n    if (!customer) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Customer not Found.\"\n        });\n    }\n    const customerId = customer._id + \"\";\n    const finishedItems = await finishedItemModel_1.default.find().lean();\n    const foundArray = [];\n    finishedItems.forEach((f) => {\n        const id = f.customer + \"\";\n        if (id == customerId) {\n            const string = `The Customer ${customer.customerName} is used in FinishedItem ${f.itemName}.`;\n            foundArray.push(string);\n        }\n    });\n    if (foundArray.length > 0) {\n        return resp.status(405).json({\n            success: false,\n            message: \"Found some items where customer is used.\",\n            foundArray\n        });\n    }\n    else {\n        await customerModel_1.default.findByIdAndDelete(id);\n        return resp.status(202).json({\n            success: true,\n            message: `Customer ${customer.customerName} deleted successfully.`\n        });\n    }\n});\n// get customer \nexports.getCustomer = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const customer = await customerModel_1.default.findById(id);\n    if (customer) {\n        return resp.status(201).json({\n            success: true,\n            message: \"getting customer successfully\",\n            customer: customer,\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"customer not found\",\n        });\n    }\n});\nexports.getAllCustomer = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, code, sort } = req.query;\n    const query = {};\n    if (name) {\n        query.$or = [\n            { customerName: { $regex: name, $options: \"i\" } },\n            { code: { $regex: name, $options: \"i\" } }\n        ];\n    }\n    ;\n    if (code) {\n        query.code = code;\n    }\n    let customer = await customerModel_1.default.find({ ...query });\n    if (sort) {\n        if (sort === \"asc\") {\n            customer = await customerModel_1.default.find({ ...query }).sort({ customerName: 1 }).lean();\n        }\n        else if (sort === \"dec\") {\n            customer = await customerModel_1.default.find({ ...query }).sort({ customerName: -1 }).lean();\n        }\n        else {\n            customer = await customerModel_1.default.find({ ...query }).sort({ customerName: 1 }).lean();\n        }\n    }\n    else {\n        customer = await customerModel_1.default.find({ ...query });\n    }\n    if (customer) {\n        return resp.status(201).json({\n            success: true,\n            message: \"getting all customer successfully\",\n            customer: customer,\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"customer not found\",\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/customController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/finishedItemController.ts":
/*!******************************************************************!*\
  !*** ./src/controllers/bomControllers/finishedItemController.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addFinishedItemInChildPart = exports.deleteGroup = exports.getAllGroup = exports.updateGroup = exports.AddGroup = exports.addProcessInEachChildPart = exports.addBomComplete = exports.updateFinishedItemStatus = exports.getFinished = exports.getAllFinished = exports.deleteFinishedItem = exports.DeleteChildPartFromFinishedItem = exports.updateProcess = exports.updateFinished = exports.getCNCProgramPerFinishedItem = exports.getBomItemWithQuantity = exports.getBomData = exports.addPartInBetweenBom = exports.addPartInBom = exports.addFinished = void 0;\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\nconst customerModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/customerModel */ \"./src/database/models/customerModel.ts\"));\nconst godownModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/godownModel */ \"./src/database/models/godownModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst CNCProgramModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/CNCProgramModel */ \"./src/database/models/CNCProgramModel.ts\"));\nconst finishItemGroupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishItemGroupModel */ \"./src/database/models/finishItemGroupModel.ts\"));\n// adding Finished Item\nexports.addFinished = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { itemName, MCode, partCode, customer, groupNames } = req.body;\n    itemName = itemName.trim();\n    MCode = MCode.trim();\n    partCode = partCode.trim();\n    const finishedItem = await finishedItemModel_1.default.findOne({\n        itemName,\n        MCode,\n        partCode,\n    });\n    if (finishedItem) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Finished Item already exsist.\",\n        });\n    }\n    const Customer = await customerModel_1.default.findOne({ customerName: customer });\n    if (!Customer) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Customer not found.\",\n        });\n    }\n    const array = [];\n    const groups = await finishItemGroupModel_1.default.find({ groupName: { $in: groupNames } }).lean();\n    if (groups) {\n        groups.forEach((g) => {\n            const obj = {\n                groupId: g._id,\n                groupName: g.groupName\n            };\n            array.push(obj);\n        });\n    }\n    ;\n    const finished = await finishedItemModel_1.default.create({\n        itemName,\n        MCode,\n        partCode,\n        customer: Customer._id,\n        finishItemGroups: array\n    });\n    return resp.status(201).json({\n        success: true,\n        message: \"Finished Item created successfully\",\n        finishedItem: finished,\n    });\n});\n// add Process In BOM\n// export const addPartInBom = catchErrorAsync(\n//   async (req: Request, resp: Response) => {\n//     const {\n//       itemName,\n//       processName,\n//       childPartName,\n//       productionGodown,\n//       itemConsumed,\n//     } = req.body;\n//     const childPartStore: any = {};\n//     const allChildPart = await ChildPartModel.find().lean();\n//     allChildPart.forEach((a) => {\n//       const name = a.partName;\n//       childPartStore[name] = {\n//         ...a,\n//       };\n//     });\n//     let finishedItem = await FinishedItemModel.findOne({ itemName });\n//     if (!finishedItem) {\n//       return resp.status(404).json({\n//         success: false,\n//         message: \"Finished Item not found.\",\n//       });\n//     }\n//     const Process = await globalProcessModel.findOne({ processName });\n//     if (!Process) {\n//       return resp.status(404).json({\n//         success: false,\n//         message: \"Global Process not found.\",\n//       });\n//     }\n//     const childPart = await ChildPartModel.findOne({ partName: childPartName });\n//     if (childPart) {\n//       return resp.status(400).json({\n//         success: false,\n//         message: \"Child Part with same name already present.\",\n//       });\n//     }\n//     const recFunction = async (id: any, quantity: number) => {\n//       const item = await ChildPartModel.findById({ _id: id });\n//       if (item) {\n//         if(item?.childPartType == \"raw\"){\n//            return\n//         }\n//         let newUnit = 1;\n//         if (item.numberOfItem !== undefined) {\n//           if (item.numberOfItem == 1) {\n//             newUnit = quantity;\n//           } else {\n//             newUnit = item.numberOfItem + quantity;\n//           }\n//         }\n//         if (item.consumedItem) {\n//           for (const f of item.consumedItem) {\n//             const quantity = f.consumedItemQuantity * newUnit;\n//             const id = f.itemId;\n//             await recFunction(id, quantity);\n//           }\n//         }\n//         item.numberOfItem = newUnit;\n//         await item.save();\n//       }\n//     };\n//     const childArray: any = [];\n//     // for checking childPart present or not\n//     itemConsumed.forEach((i: any) => {\n//       const name = i.childPart;\n//       const part = childPartStore[name];\n//       if (!part) {\n//         return resp.status(404).json({\n//           success: false,\n//           message: `Child Part with Name ${name} not found.`,\n//         });\n//       }\n//     });\n//     itemConsumed.forEach((i: any) => {\n//       const name = i.childPart;\n//       const part = childPartStore[name];\n//       if (!part) {\n//         return resp.status(404).json({\n//           success: false,\n//           message: `Child Part with Name ${name} not found.`,\n//         });\n//       }\n//       childArray.push({\n//         ...part,\n//         quantity: i.quantity,\n//         consumptionGodown: i.consumptionGodown,\n//       });\n//       recFunction(part._id, i.quantity);\n//     });\n//     const godown = await GodownModel.findOne({ godownName: productionGodown });\n//     const newChildPart = await ChildPartModel.create({\n//       partName: childPartName,\n//       productionGodown: godown?._id,\n//       numberOfItem: 1,\n//     });\n//     childArray.forEach((c: any) => {\n//       const itemId = c._id;\n//       const itemName = c.partName;\n//       const itemType = \"child part\";\n//       const consumedItemQuantity = c.quantity;\n//       const consumptionGodown = c.productionGodown;\n//       newChildPart.consumedItem.push({\n//         itemId,\n//         itemName,\n//         itemType,\n//         consumedItemQuantity,\n//         consumptionGodown,\n//       });\n//     });\n//     await newChildPart.save();\n//     finishedItem.masterBom?.push({\n//       childPart: { id: newChildPart._id, childPartName: newChildPart.partName },\n//       process: { id: Process._id, processName: Process.processName },\n//       quantity: 1,\n//     });\n//     await finishedItem.save();\n//     return resp.status(201).json({\n//       success: true,\n//       message: \"Finished Item created successfully\",\n//       finishedItem,\n//     });\n//   }\n// );\n// add Process In BOM\nexports.addPartInBom = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { itemName, processName, childPartName, productionGodown, itemConsumed, bomCompleted, } = req.body;\n    childPartName = childPartName.trim();\n    const childPartStore = {};\n    const allChildPart = await childPartModel_1.default.find().lean();\n    allChildPart.forEach((a) => {\n        const name = a.partName;\n        childPartStore[name] = {\n            ...a,\n        };\n    });\n    let finishedItem = await finishedItemModel_1.default.findOne({ itemName });\n    if (!finishedItem) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Finished Item not found.\",\n        });\n    }\n    ;\n    const Process = await globalProcessModel_1.default.findOne({ processName });\n    if (!Process) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Global Process not found.\",\n        });\n    }\n    ;\n    const childPart = await childPartModel_1.default.findOne({ partName: childPartName });\n    if (childPart) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Child Part with same name already present.\",\n        });\n    }\n    ;\n    const childArray = [];\n    // for checking childPart present or not\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n        ;\n    });\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n        ;\n        childArray.push({\n            ...part,\n            quantity: i.quantity,\n            consumptionGodown: i.consumptionGodown,\n        });\n    });\n    const godown = await godownModel_1.default.findOne({ godownName: productionGodown });\n    if (!godown) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Godown not found.\",\n        });\n    }\n    ;\n    const newChildPart = await childPartModel_1.default.create({\n        partName: childPartName,\n        productionGodown: godown?._id,\n        numberOfItem: 1,\n    });\n    childArray.forEach((c) => {\n        const itemId = c._id;\n        const itemName = c.partName;\n        const itemType = \"child part\";\n        const consumedItemQuantity = c.quantity;\n        const consumptionGodown = c.productionGodown;\n        newChildPart.consumedItem.push({\n            itemId,\n            itemName,\n            itemType,\n            consumedItemQuantity,\n            consumptionGodown,\n        });\n    });\n    newChildPart.finishedItemId = finishedItem._id;\n    newChildPart.processId = Process._id;\n    newChildPart.processName = Process.processName;\n    await newChildPart.save();\n    finishedItem.masterBom?.push({\n        childPart: { id: newChildPart._id, childPartName: newChildPart.partName },\n        process: { id: Process._id, processName: Process.processName },\n        productionGodown: {\n            id: newChildPart.productionGodown,\n            productionGodownName: godown.godownName,\n        },\n        quantity: 1,\n    });\n    finishedItem.bomCompleted = bomCompleted;\n    await finishedItem.save();\n    return resp.status(201).json({\n        success: true,\n        message: \"Finished Item created successfully\",\n        finishedItem,\n    });\n});\n// add Process In BOM\nexports.addPartInBetweenBom = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { itemName, processName, childPartName, productionGodown, itemConsumed, newIndex, } = req.body;\n    const childPartStore = {};\n    const allChildPart = await childPartModel_1.default.find().lean();\n    allChildPart.forEach((a) => {\n        const name = a.partName;\n        childPartStore[name] = {\n            ...a,\n        };\n    });\n    let finishedItem = await finishedItemModel_1.default.findOne({ itemName });\n    if (!finishedItem) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Finished Item not found.\",\n        });\n    }\n    const Process = await globalProcessModel_1.default.findOne({ processName });\n    if (!Process) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Global Process not found.\",\n        });\n    }\n    const childPart = await childPartModel_1.default.findOne({ partName: childPartName });\n    if (childPart) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Child Part with same name already present.\",\n        });\n    }\n    const childArray = [];\n    // for checking childPart present or not\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n    });\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n        childArray.push({\n            ...part,\n            quantity: i.quantity,\n            consumptionGodown: i.consumptionGodown,\n        });\n    });\n    const godown = await godownModel_1.default.findOne({ godownName: productionGodown });\n    const newChildPart = await childPartModel_1.default.create({\n        partName: childPartName,\n        productionGodown: godown?._id,\n        numberOfItem: 1,\n    });\n    childArray.forEach((c) => {\n        const itemId = c._id;\n        const itemName = c.partName;\n        const itemType = \"child part\";\n        const consumedItemQuantity = c.quantity;\n        const consumptionGodown = c.productionGodown;\n        newChildPart.consumedItem.push({\n            itemId,\n            itemName,\n            itemType,\n            consumedItemQuantity,\n            consumptionGodown,\n        });\n    });\n    newChildPart.finishedItemId = finishedItem._id;\n    newChildPart.processId = Process._id;\n    newChildPart.processName = Process.processName;\n    await newChildPart.save();\n    // finishedItem.masterBom?.push({\n    //   childPart: { id: newChildPart._id, childPartName: newChildPart.partName },\n    //   process: { id: Process._id, processName: Process.processName },\n    //   quantity: 1,\n    // });\n    if (!finishedItem.masterBom) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Master bom not added\",\n        });\n    }\n    const newItem = {\n        childPart: { id: newChildPart._id, childPartName: newChildPart.partName },\n        process: { id: Process._id, processName: Process.processName },\n        quantity: 1,\n    };\n    if (newIndex >= 0 && newIndex <= finishedItem.masterBom.length) {\n        finishedItem.masterBom.splice(newIndex - 1, 0, newItem);\n    }\n    ;\n    await finishedItem.save();\n    return resp.status(201).json({\n        success: true,\n        message: `Finished Item updated successfully with addition of child part ${childPartName}.`,\n        finishedItem,\n    });\n});\n// new api for showing the data according to backend changes\nexports.getBomData = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const id = req.params.finishedItemId;\n    const childPartStore = {};\n    const childParts = await childPartModel_1.default.find().lean();\n    childParts.forEach((c) => {\n        const id = c._id + \"\";\n        childPartStore[id] = {\n            ...c,\n        };\n    });\n    const finishedItem = await finishedItemModel_1.default.findById(id);\n    const masterBom = [];\n    if (finishedItem) {\n        finishedItem.masterBom?.forEach((f) => {\n            const id = f.childPart?.id + \"\";\n            const childPart = childPartStore[id];\n            const childParts = [];\n            if (childPart.consumedItem) {\n                childPart.consumedItem.forEach((c) => {\n                    const id = c.itemId + \"\";\n                    const childPart = childPartStore[id];\n                    childParts.push(childPart);\n                });\n            }\n            const obj = { process: f.process?.processName, childPart, childParts };\n            masterBom.push(obj);\n        });\n        const customer = await customerModel_1.default.findById({\n            _id: finishedItem.customer,\n        });\n        const finished = {\n            finishedItemName: finishedItem.itemName,\n            MCode: finishedItem.MCode,\n            partCode: finishedItem.partCode,\n            customer: customer?.customerName,\n            masterBom,\n        };\n        resp.status(200).json({\n            message: \"Getting data sucessfully.\",\n            success: true,\n            finished,\n        });\n    }\n});\n// get All bom items with the quantity\nconst getBomItemWithQuantity = async (req, resp, id, orderQuantity) => {\n    try {\n        const CNCPrograms = await CNCProgramModel_1.default.find().lean();\n        const cncChildStore = {};\n        CNCPrograms.forEach((c) => {\n            const programName = c.programName;\n            const programNumber = c.programNumber;\n            const id = c._id;\n            c.childParts.forEach((a) => {\n                const id = a.childPart.id + \"\";\n                if (!cncChildStore[id]) {\n                    cncChildStore[id] = {\n                        cncPrograms: []\n                    };\n                }\n                cncChildStore[id].cncPrograms.push({\n                    programName,\n                    programNumber,\n                    id\n                });\n            });\n        });\n        const childPartStore = {};\n        const childParts = await childPartModel_1.default.find().lean();\n        const godownStore = {};\n        const godowns = await godownModel_1.default.find().lean();\n        godowns.forEach((g) => {\n            const id = g._id + \"\";\n            godownStore[id] = {\n                ...g,\n            };\n        });\n        childParts.forEach((c) => {\n            const id = c._id;\n            childPartStore[id] = {\n                ...c,\n            };\n        });\n        const updatedChildPartStore = {};\n        const recFunc = (id, unit) => {\n            const child = childPartStore[id];\n            const qu = child?.unit;\n            const newChild = [];\n            if (child?.consumedItem) {\n                child.consumedItem.forEach((cc) => {\n                    const data = recFunc(cc.itemId, cc.consumedItemQuantity * unit);\n                    const id = data._id + \"\";\n                    updatedChildPartStore[id] = { ...data };\n                    newChild.push(data);\n                });\n            }\n            ;\n            const godownDetails = godownStore[child?.productionGodown];\n            const CNCPrograms = cncChildStore[child?._id + \"\"]?.cncPrograms || [];\n            return {\n                _id: child?._id,\n                partName: child?.partName,\n                materialCode: child?.materialCode,\n                typeOfMaterial: child?.typeOfMaterial,\n                childPartType: child?.childPartType,\n                productionGodownId: godownDetails?._id || \"\",\n                productionGodownName: godownDetails?.godownName || \"\",\n                unit: qu,\n                CNCPrograms: CNCPrograms || [],\n                numberOfItem: unit ? unit : 1,\n                newChild,\n            };\n        };\n        const finishedItem = await finishedItemModel_1.default.findById(id);\n        const items = [];\n        finishedItem?.masterBom?.forEach((f) => {\n            const unit = orderQuantity ? orderQuantity : 1;\n            const id = f.childPart?.id + \"\";\n            const process = f.process?.processName;\n            const processId = f.process?.id;\n            const itemData = recFunc(id, unit || 1);\n            const SrNumber = items.length + 1;\n            const obj = {\n                SrNumber,\n                partName: itemData.partName,\n                _id: itemData._id,\n                numberOfItem: itemData.numberOfItem,\n                productionGodownId: itemData.productionGodownId,\n                productionGodownName: itemData.productionGodownName,\n                newChild: itemData.newChild,\n                process,\n                processId: processId,\n            };\n            items.push(obj);\n        });\n        const newFinishItem = {\n            finishedItemName: finishedItem?.itemName,\n            customer: finishedItem?.customer,\n            partCode: finishedItem?.partCode,\n            MCode: finishedItem?.MCode,\n            bomCompleted: finishedItem?.bomCompleted,\n            items,\n        };\n        for (let item of newFinishItem.items) {\n            const itemId = item._id;\n            if (itemId in updatedChildPartStore) {\n                const updatedItem = updatedChildPartStore[itemId];\n                Object.assign(item, updatedItem);\n            }\n            ;\n        }\n        ;\n        return newFinishItem;\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ;\n};\nexports.getBomItemWithQuantity = getBomItemWithQuantity;\nconst getCNCProgramPerFinishedItem = async (id) => {\n    const result = [];\n    const finishedItem = await finishedItemModel_1.default.findById(id).lean();\n    if (!finishedItem) {\n        return [];\n    }\n    const allChildParts = await childPartModel_1.default.find({ finishedItemId: finishedItem._id }).lean();\n    const childPartIds = allChildParts.map((c) => c._id);\n    // console.log(childPartIds.length)\n    if (childPartIds && childPartIds.length) {\n        const allCNCProgram = await CNCProgramModel_1.default.find({ \"childParts.childPart.id\": { $in: childPartIds } }).lean();\n        allCNCProgram.forEach((c) => {\n            const obj = {\n                programName: c.programName,\n                programNumber: c.programNumber\n            };\n            result.push(obj);\n        });\n    }\n    return result;\n};\nexports.getCNCProgramPerFinishedItem = getCNCProgramPerFinishedItem;\nexports.updateFinished = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { itemName, groupNames, MCode, partCode, customer, bomCompleted } = req.body;\n    const finished = await finishedItemModel_1.default.findById(id);\n    if (!finished) {\n        return resp.status(404).json({\n            success: false,\n            message: `Finished Item with id ${id} not found.`\n        });\n    }\n    ;\n    if (customer) {\n        const Customer = await customerModel_1.default.findOne({ customerName: customer });\n        if (!Customer) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Customer not found.\",\n            });\n        }\n        finished.customer = Customer._id;\n    }\n    ;\n    if (itemName) {\n        finished.itemName = itemName;\n    }\n    ;\n    if (MCode) {\n        finished.MCode = MCode;\n    }\n    ;\n    if (partCode) {\n        finished.partCode = partCode;\n    }\n    ;\n    if (groupNames && groupNames.length) {\n        const groups = await finishItemGroupModel_1.default.find({ groupName: { $in: groupNames } }).lean();\n        if (groups) {\n            const array = [];\n            groups.forEach((g) => {\n                const obj = {\n                    groupId: g._id,\n                    groupName: g.groupName\n                };\n                array.push(obj);\n            });\n            finished.finishItemGroups = array;\n        }\n        ;\n    }\n    ;\n    if (bomCompleted) {\n        if (finished.masterBom) {\n            if (finished.itemName !== finished.masterBom[finished.masterBom?.length - 2].childPart?.childPartName) {\n                return resp.status(400).json({\n                    success: false,\n                    message: \"Finished Item is not completed with loading.\"\n                });\n            }\n            else {\n                finished.bomCompleted = bomCompleted;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    await finished.save();\n    resp.status(200).json({\n        success: true,\n        message: \"Finished Item updated .\",\n        finishedItem: finished\n    });\n});\n// change process in finishedItem\nexports.updateProcess = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { index, processName } = req.body;\n    const finished = await finishedItemModel_1.default.findById(id);\n    if (!finished) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Finished Item not found.\",\n        });\n    }\n    const process = await globalProcessModel_1.default.findOne({ processName });\n    if (!process) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Process not found.\",\n        });\n    }\n    let processData;\n    if (finished.masterBom) {\n        const obj = {\n            id: process._id,\n            processName: process.processName,\n        };\n        finished.masterBom[index].process = obj;\n        processData = finished.masterBom[index].process;\n        await childPartModel_1.default.findOneAndUpdate({ _id: finished.masterBom[index].childPart?.id }, { processId: process._id, processName: process.processName });\n    }\n    await finished.save();\n    return resp.status(200).json({\n        success: true,\n        message: \"Process Changed successfully.\",\n        processData,\n    });\n});\n// delete childPart in finishedItem\nexports.DeleteChildPartFromFinishedItem = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { index } = req.body;\n    const finished = await finishedItemModel_1.default.findById(id);\n    if (!finished) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Finished Item not found.\",\n        });\n    }\n    if (!finished.masterBom) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Master bom not found.\",\n        });\n    }\n    // Check if the index is valid\n    if (index < 0 || index >= finished.masterBom.length) {\n        return resp\n            .status(400)\n            .json({ success: false, message: \"Invalid index\" });\n    }\n    // if (index > finished.masterBom.length - 3) {\n    //   finished.bomCompleted = false\n    // }\n    finished.bomCompleted = false;\n    const item = finished.masterBom[index];\n    const childPartId = item.childPart?.id;\n    const isConsumed = await childPartModel_1.default.findOne({ 'consumedItem.itemId': childPartId });\n    if (isConsumed) {\n        return resp.status(400).json({\n            success: false,\n            message: `Item is consumed in ChildPart ${isConsumed.partName}.`\n        });\n    }\n    ;\n    const CNCProgram = await CNCProgramModel_1.default.find().lean();\n    const foundCNC = [];\n    CNCProgram.forEach((c) => {\n        if (c.childParts.length > 0) {\n            c.childParts.forEach((p) => {\n                if (p.childPart.id + \"\" === childPartId + \"\") {\n                    const string = `The Child Part is used in ${c.programName} CNC Program.`;\n                    foundCNC.push(string);\n                }\n                ;\n            });\n        }\n        ;\n    });\n    if (foundCNC.length > 0) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Child part is used in CNCProgram.\",\n            foundArray: foundCNC\n        });\n    }\n    ;\n    await childPartModel_1.default.findOneAndDelete({ _id: childPartId });\n    finished.masterBom.splice(index, 1);\n    await finished.save();\n    return resp.status(202).json({\n        success: true,\n        message: `Item at ${index + 1} with childPart ${item.childPart?.childPartName} deleted successfully.`,\n    });\n});\n// delete a finishedItem\nexports.deleteFinishedItem = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const item = await finishedItemModel_1.default.findOne({ _id: id });\n    if (!item) {\n        return resp.status(404).json({\n            success: false,\n            message: `Finished Item with Id ${id} not found.`,\n        });\n    }\n    if (!item.masterBom) {\n        await finishedItemModel_1.default.findByIdAndDelete(item._id);\n        return resp.status(202).json({\n            success: true,\n            message: `Finished Item ${item.itemName} deleted successfully.`,\n        });\n    }\n    if (item.masterBom?.length > 0) {\n        return resp.status(405).json({\n            success: false,\n            message: `Finished Item Have ${item.masterBom?.length} childParts First delete them.`,\n        });\n    }\n    else {\n        await finishedItemModel_1.default.findByIdAndDelete(item._id);\n        return resp.status(202).json({\n            success: true,\n            message: `Finished Item ${item.itemName} deleted successfully.`,\n        });\n    }\n});\n// get all finished items\nexports.getAllFinished = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, status, customers, groupNames, sort, shops, processes } = req.body;\n    const processStore = {};\n    if (shops && shops.length) {\n        const shopDetails = await shopModel_1.default.find({ shopName: { $in: shops } });\n        const shopIds = shopDetails.map((s) => s._id);\n        const process = await globalProcessModel_1.default\n            .find({ \"shop.shopId\": { $in: shopIds } })\n            .lean();\n        process.forEach((p) => {\n            const id = p._id + \"\";\n            processStore[id] = {\n                _id: id,\n            };\n        });\n    }\n    ;\n    if (processes && processes.length) {\n        const Processes = await globalProcessModel_1.default.find({\n            processName: { $in: processes },\n        });\n        Processes.forEach((p) => {\n            const id = p._id + \"\";\n            processStore[id] = {\n                _id: id,\n            };\n        });\n    }\n    ;\n    const query = {};\n    if (name) {\n        query.$or = [\n            { itemName: { $regex: name, $options: \"i\" } },\n            { MCode: { $regex: name, $options: \"i\" } },\n            { partCode: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    ;\n    // console.log(query)\n    if (status) {\n        if (status == \"true\") {\n            query.bomCompleted = true;\n        }\n        else if (status == \"false\") {\n            query.bomCompleted = false;\n        }\n        ;\n    }\n    ;\n    if (customers && customers.length) {\n        const cstmr = await customerModel_1.default.find({ customerName: { $in: customers } });\n        const customerIds = cstmr.map((c) => c._id);\n        query.customer = { $in: customerIds };\n    }\n    if (groupNames && groupNames.length) {\n        const group = await finishItemGroupModel_1.default.find({ groupName: { $in: groupNames } });\n        const groupIds = group.map((g) => g._id);\n        if (group) {\n            query[\"finishItemGroups.groupId\"] = { $in: groupIds };\n        }\n        ;\n    }\n    ;\n    let allFinished;\n    if (sort == \"asc\") {\n        allFinished = await finishedItemModel_1.default.find(query)\n            .sort({ itemName: 1 })\n            .populate(\"customer\")\n            .lean();\n    }\n    else if (sort == \"dec\") {\n        allFinished = await finishedItemModel_1.default.find(query)\n            .sort({ itemName: -1 })\n            .populate(\"customer\")\n            .lean();\n    }\n    else {\n        allFinished = await finishedItemModel_1.default.find(query)\n            .populate(\"customer\")\n            .lean();\n    }\n    const result = [];\n    // console.log(allFinished.length)\n    if ((shops && shops.length) || (processes && processes.length)) {\n        allFinished.forEach((a) => {\n            const length = a.masterBom?.length;\n            let obj;\n            let isTrue = false;\n            a.masterBom?.forEach((b) => {\n                const id = b.process?.id + \"\";\n                if (processStore[id]) {\n                    isTrue = true;\n                    return;\n                }\n            });\n            if (isTrue) {\n                obj = {\n                    _id: a._id,\n                    MCode: a.MCode,\n                    itemName: a.itemName,\n                    partCode: a.partCode,\n                    customer: a.customer,\n                    bomCompleted: a.bomCompleted,\n                    processes: length,\n                    groups: a.finishItemGroups\n                };\n                result.push(obj);\n            }\n        });\n    }\n    else {\n        allFinished.forEach((a) => {\n            const length = a.masterBom?.length;\n            let obj;\n            obj = {\n                _id: a._id,\n                MCode: a.MCode,\n                itemName: a.itemName,\n                partCode: a.partCode,\n                customer: a.customer,\n                bomCompleted: a.bomCompleted,\n                processes: length,\n                groups: a.finishItemGroups\n            };\n            result.push(obj);\n        });\n    }\n    ;\n    return resp.status(201).json({\n        success: true,\n        message: \"Getting all Finished Items successfully\",\n        finishedItems: result,\n    });\n});\nexports.getFinished = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const finished = await finishedItemModel_1.default.findById(id);\n    return resp.status(201).json({\n        success: true,\n        message: \"Getting Finished Item successfully\",\n        finished,\n    });\n});\nexports.updateFinishedItemStatus = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const finishedItems = await finishedItemModel_1.default.find().lean();\n    for (let i of finishedItems) {\n        const fItem = await finishedItemModel_1.default.findById({ _id: i._id });\n        if (fItem) {\n            fItem.bomCompleted = false;\n            await fItem.save();\n        }\n    }\n    resp.status(200).json({\n        success: true\n    });\n});\nexports.addBomComplete = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    // const {customerId} = req.body;\n    const finishedItem = await finishedItemModel_1.default.find({});\n    for (let i of finishedItem) {\n        const item = await finishedItemModel_1.default.findOne({ _id: i._id });\n        if (item) {\n            if (!item.bomCompleted) {\n                item.bomCompleted = false;\n                await item.save();\n            }\n        }\n        ;\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n    });\n});\nexports.addProcessInEachChildPart = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const allFinishedItems = await finishedItemModel_1.default.find().lean();\n    for (let f of allFinishedItems) {\n        if (f.masterBom) {\n            for (let m of f.masterBom) {\n                const processName = m.process.processName;\n                const processid = m.process.id;\n                const childPart = await childPartModel_1.default.findById(m.childPart?.id);\n                if (childPart) {\n                    childPart.processId = processid;\n                    childPart.processName = processName;\n                    await childPart.save();\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"Done\"\n    });\n});\n// -------------------------- Groups ----------------------------------------\nexports.AddGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupName, groupDescription } = req.body;\n    const group = await finishItemGroupModel_1.default.findOne({ groupName });\n    if (group) {\n        return resp.status(400).json({\n            success: false,\n            message: `Group with name ${group.groupName} already present.`\n        });\n    }\n    ;\n    const newGroup = await finishItemGroupModel_1.default.create({ groupName, groupDescription });\n    resp.status(201).json({\n        success: true,\n        message: \"Group created successfully.\",\n        newGroup\n    });\n});\n// update group\nexports.updateGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId } = req.params;\n    const { groupName, groupDescription } = req.body;\n    const group = await finishItemGroupModel_1.default.findById({ _id: groupId });\n    if (!group) {\n        return resp.status(400).json({\n            success: false,\n            message: `Group not found with id ${groupId}.`\n        });\n    }\n    ;\n    const newGroup = await finishItemGroupModel_1.default.findByIdAndUpdate(groupId, { groupName, groupDescription });\n    const finishedItems = await finishedItemModel_1.default.find({ finishItemGroupId: newGroup?._id });\n    for (let f of finishedItems) {\n        const finishedItem = await finishedItemModel_1.default.findByIdAndUpdate(f._id, { finishItemGroupName: newGroup?.groupName });\n    }\n    resp.status(201).json({\n        success: true,\n        message: \"Group created successfully.\",\n        newGroup\n    });\n});\n// get all group\nexports.getAllGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { sort, name } = req.body;\n    let query = {};\n    if (name) {\n        // Match 'name' against 'groupName', 'groupDescription'\n        query.$or = [\n            { groupName: { $regex: name, $options: \"i\" } },\n            { groupDescription: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    let groups;\n    if (sort) {\n        if (sort === \"asc\") {\n            groups = await finishItemGroupModel_1.default.find({ ...query }).sort({ groupName: 1 }).lean();\n        }\n        else if (sort === \"dec\") {\n            groups = await finishItemGroupModel_1.default.find({ ...query }).sort({ groupName: -1 }).lean();\n        }\n    }\n    else {\n        groups = await finishItemGroupModel_1.default.find({ ...query }).lean();\n    }\n    resp.status(201).json({\n        success: true,\n        message: \"Group created successfully.\",\n        groups\n    });\n});\nexports.deleteGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId } = req.params;\n    const finishedItems = await finishedItemModel_1.default.find({ \"finishItemGroups.groupId\": groupId }).lean();\n    if (finishedItems.length === 0) {\n        const group = await finishItemGroupModel_1.default.findByIdAndDelete({ _id: groupId }).lean();\n        if (!group) {\n            resp.status(404).json({\n                success: false,\n                message: \"group not found.\",\n            });\n        }\n        else {\n            resp.status(200).json({\n                success: true,\n                message: `${group.groupName} group deleted successfully.`,\n            });\n        }\n    }\n    else {\n        const foundArray = finishedItems.map(f => f.itemName);\n        resp.status(400).json({\n            success: false,\n            message: \"foundArray some where.\",\n            foundArray\n        });\n    }\n});\nconst addFinishedItemInChildPart = async (req, resp, next) => {\n    try {\n        const getAllFinishedItems = await finishedItemModel_1.default.find().lean();\n        for (let f of getAllFinishedItems) {\n            const id = f._id;\n            if (!f.masterBom) {\n                return;\n            }\n            for (let c of f.masterBom) {\n                const childPartId = c.childPart?.id;\n                const childPart = await childPartModel_1.default.findById(childPartId);\n                if (childPart) {\n                    childPart.finishedItemId = id;\n                    await childPart.save();\n                }\n            }\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"DONE\"\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.addFinishedItemInChildPart = addFinishedItemInChildPart;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/finishedItemController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/globalProcessController.ts":
/*!*******************************************************************!*\
  !*** ./src/controllers/bomControllers/globalProcessController.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAllGlobalProcess = exports.getGlobalProcess = exports.updateGlobalProcess = exports.deleteGlobalProcess = exports.addGlobalProcess = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst machineModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/machineModel */ \"./src/database/models/machineModel.ts\"));\nconst workOrderModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workOrderModel */ \"./src/database/models/workOrderModel.ts\"));\nconst CNCProgramModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/CNCProgramModel */ \"./src/database/models/CNCProgramModel.ts\"));\n// add godown\nexports.addGlobalProcess = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { processName, processCode, shopName } = req.body;\n    processName = processName.trim();\n    processCode = processCode.trim();\n    let shop = await shopModel_1.default.findOne({ shopName });\n    if (shop) {\n        // const newName = processName +\" \" +shop.shopName;\n        const process = await globalProcessModel_1.default.create({\n            processName: processName,\n            processCode,\n            shop: {\n                shopId: shop._id,\n                shopName: shop.shopName,\n            },\n        });\n        return resp.status(201).json({\n            success: true,\n            message: \"Global Process created successfully\",\n            process,\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"Shop not found\",\n        });\n    }\n});\n// delete global process\nexports.deleteGlobalProcess = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const process = await globalProcessModel_1.default.findById(id);\n    if (!process) {\n        return resp.json({\n            success: false,\n            message: `Process with id ${id} not found.`,\n        });\n    }\n    const processId = process._id + \"\";\n    const finishedItems = await finishedItemModel_1.default.find().lean();\n    const workOrders = await workOrderModel_1.default.find().lean();\n    const CNCPrograms = await CNCProgramModel_1.default.find().lean();\n    const machines = await machineModel_1.default.find().lean();\n    const foundArray = [];\n    finishedItems.forEach((f) => {\n        let i = 1;\n        f.masterBom?.forEach((m) => {\n            const id = m.process?.id + \"\";\n            if (id == processId) {\n                const string = `The ${process.processName} is used in finishedItem ${f.itemName} at index ${i}.`;\n                foundArray.push(string);\n            }\n            i++;\n        });\n    });\n    workOrders.forEach((w) => {\n        let i = 1;\n        w.masterBom.forEach((p) => {\n            if (p.processId + \"\" === processId) {\n                const string = `The ${process.processName} is used in workOrder with Number ${w.orderNumber} at index ${i}.`;\n                foundArray.push(string);\n            }\n            ;\n        });\n    });\n    CNCPrograms.forEach((c) => {\n        if (c.processId + \"\" === processId) {\n            const string = `The ${process.processName} is used in CNCProgram with programName ${c.programName}.`;\n            foundArray.push(string);\n        }\n        ;\n    });\n    machines.forEach((m) => {\n        m.process.forEach((p) => {\n            const id = p + \"\";\n            if (id == processId) {\n                const string = `The ${m.machineName} can process this ${process.processName}.`;\n                foundArray.push(string);\n            }\n            ;\n        });\n    });\n    if (foundArray.length > 0) {\n        return resp.status(405).json({\n            success: false,\n            message: \"Found item someWhere.\",\n            foundArray,\n        });\n    }\n    else {\n        const process = await globalProcessModel_1.default.findByIdAndDelete(id);\n        return resp.status(202).json({\n            success: true,\n            message: `Process with name ${process?.processName} deleted.`,\n        });\n    }\n    ;\n});\n// update global process\nexports.updateGlobalProcess = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { processName, processCode, shopName } = req.body;\n    let Process = await globalProcessModel_1.default.findById(id);\n    let shop = await shopModel_1.default.findOne({ shopName });\n    if (!shop) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Shop not found.\",\n        });\n    }\n    if (!Process) {\n        return resp.status(404).json({\n            success: false,\n            message: `Process not found with Id ${id}.`,\n        });\n    }\n    Process = await globalProcessModel_1.default.findByIdAndUpdate({ _id: id }, {\n        processName,\n        processCode,\n        shop: {\n            shopName: shop.shopName,\n            shopId: shop._id,\n        },\n    });\n    if (processName) {\n        const allFinishedItem = await finishedItemModel_1.default.find({\n            \"masterBom.process.id\": Process?._id,\n        });\n        allFinishedItem.forEach(async (a) => {\n            const fItem = await finishedItemModel_1.default.findById(a._id);\n            if (fItem) {\n                fItem?.masterBom?.forEach((f) => {\n                    if (f.process?.id + \"\" === id) {\n                        if (f.process?.processName && Process) {\n                            f.process.processName = Process.processName;\n                        }\n                    }\n                });\n                await fItem?.save();\n            }\n            ;\n        });\n    }\n    ;\n    return resp.status(201).json({\n        success: true,\n        message: \"process updated successfully\",\n    });\n});\nexports.getGlobalProcess = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const process = await globalProcessModel_1.default.findById(id).exec();\n    if (process) {\n        return resp.status(201).json({\n            success: true,\n            message: \"getting process successfully\",\n            process: process,\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"process not found\",\n        });\n    }\n});\nexports.getAllGlobalProcess = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, shops, sort } = req.body;\n    const query = {};\n    if (name) {\n        query.$or = [\n            { processName: { $regex: name, $options: \"i\" } },\n            { processCode: { $regex: name, $options: \"i\" } },\n            { \"shop.shopName\": { $regex: name, $options: \"i\" } },\n        ];\n    }\n    ;\n    if (shops && shops.length > 0) {\n        const shopsDetails = await shopModel_1.default.find({ shopName: { $in: shops } });\n        const shopIds = shopsDetails.map((s) => s._id);\n        query[\"shop.shopId\"] = { $in: shopIds };\n    }\n    ;\n    let process;\n    if (sort) {\n        if (sort === \"asc\") {\n            process = await globalProcessModel_1.default\n                .find({ ...query })\n                .sort({ processName: 1 })\n                .exec();\n        }\n        else if (sort === \"dec\") {\n            process = await globalProcessModel_1.default\n                .find({ ...query })\n                .sort({ processName: -1 })\n                .exec();\n        }\n        else {\n            process = await globalProcessModel_1.default\n                .find({ ...query })\n                .sort({ processName: 1 })\n                .exec();\n        }\n    }\n    else {\n        process = await globalProcessModel_1.default.find({ ...query }).exec();\n    }\n    if (process) {\n        // NEW CODE\n        const resultArr = [];\n        process.forEach((e) => {\n            resultArr.push({\n                _id: e._id,\n                createdAt: e.createdAt,\n                processCode: e.processCode,\n                processName: e.processName,\n                shop: e.shop,\n                updatedAt: e.updatedAt,\n                shopName: e.shop.shopName,\n            });\n        });\n        return resp.status(201).json({\n            success: true,\n            message: \"getting all process successfully\",\n            process: resultArr,\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"process not found\",\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/globalProcessController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/godownController.ts":
/*!************************************************************!*\
  !*** ./src/controllers/bomControllers/godownController.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateGodown = exports.getGodown = exports.getAllGodown = exports.deleteGodown = exports.addGodown = void 0;\nconst godownModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/godownModel */ \"./src/database/models/godownModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\n// add godown\nexports.addGodown = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { godownName, godownCode } = req.body;\n    godownName = godownName.trim();\n    godownCode = godownCode.trim();\n    const godown = await godownModel_1.default.create({ godownName, godownCode });\n    return resp.status(201).json({\n        success: true,\n        message: \"Godown created successfully\",\n        godown\n    });\n});\n// delete godown\nexports.deleteGodown = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const Godown = await godownModel_1.default.findById(id);\n    if (!Godown) {\n        return resp.status(404).json({\n            success: false,\n            message: `Godown with id ${id} not found.`,\n        });\n    }\n    const godownId = Godown._id + \"\";\n    const childParts = await childPartModel_1.default.find().lean();\n    const foundArray = [];\n    childParts.forEach((c) => {\n        const id = c.productionGodown + \"\";\n        if (godownId == id) {\n            const string = `Child Part ${c.partName} in Production using this ${Godown.godownName} .`;\n            foundArray.push(string);\n        }\n        c.consumedItem.forEach((i) => {\n            const id = i.consumptionGodown + \"\";\n            if (godownId == id) {\n                const string = `Child Part ${c.partName}'s part ${i.itemName} consumption godown using this ${Godown.godownName} .`;\n                foundArray.push(string);\n            }\n        });\n    });\n    if (foundArray.length > 0) {\n        return resp.status(405).json({\n            success: false,\n            message: \"Found Godown somewhere\",\n            foundArray,\n        });\n    }\n    else {\n        await godownModel_1.default.findByIdAndDelete(id);\n        return resp.status(202).json({\n            success: true,\n            message: `${Godown.godownName} deleted successfully.`,\n        });\n    }\n});\n// get all godown\nexports.getAllGodown = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, sort } = req.query;\n    const query = {};\n    if (name) {\n        query.$or = [\n            { godownName: { $regex: name, $options: \"i\" } },\n            { godownCode: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    let allGodown;\n    if (sort) {\n        if (sort === \"asc\") {\n            allGodown = await godownModel_1.default.find({ ...query })\n                .sort({ godownName: 1 })\n                .lean();\n        }\n        else if (sort === \"dec\") {\n            allGodown = await godownModel_1.default.find({ ...query })\n                .sort({ godownName: -1 })\n                .lean();\n        }\n        else {\n            allGodown = await godownModel_1.default.find({ ...query })\n                .sort({ godownName: 1 })\n                .lean();\n        }\n    }\n    else {\n        allGodown = await godownModel_1.default.find({ ...query }).lean();\n    }\n    return resp.status(200).json({\n        success: true,\n        message: \"Getting all godown successfully\",\n        allgodown: allGodown,\n    });\n});\nexports.getGodown = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const godown = await godownModel_1.default.findById(id);\n    return resp.status(201).json({\n        success: true,\n        message: \"Getting godown successfully\",\n        godown: godown,\n    });\n});\nexports.updateGodown = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { godownName, godownCode } = req.body;\n    const godown = await godownModel_1.default.findByIdAndUpdate({ _id: id }, { godownName, godownCode });\n    return resp.status(201).json({\n        success: true,\n        message: \"Getting godown successfully\",\n        godown: godown,\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/godownController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/machineController.ts":
/*!*************************************************************!*\
  !*** ./src/controllers/bomControllers/machineController.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uploadMachineImage = exports.uploadMachineProofImage = exports.getMachineByQrCode = exports.assignQrToMachine = exports.getAllMachine = exports.getMachine = exports.deleteMachine = exports.updateMachine = exports.addMachine = void 0;\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst machineModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/machineModel */ \"./src/database/models/machineModel.ts\"));\n// import { getIndianTime } from \"../../middleware/dateTimeConverter\";\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst QRCode = __importStar(__webpack_require__(/*! qrcode */ \"qrcode\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst machineQrCodeLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/machineQrCodeLogModel */ \"./src/database/models/machineQrCodeLogModel.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst adminModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/adminModel */ \"./src/database/models/adminModel.ts\"));\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_2 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\n(0, dotenv_1.config)({ path: path_2.default.join(__dirname, \"../../../\", \"public/.env\") });\naws_sdk_1.default.config.update({\n    secretAccessKey: process.env.ACCESS_SECRET,\n    accessKeyId: process.env.ACCESS_KEY,\n    region: process.env.REGION,\n});\nconst BUCKET = process.env.BUCKET;\nif (!BUCKET) {\n    console.error(\"No bucket specified in the environment configuration.\");\n    process.exit(1); // Exit the application or handle the error accordingly\n}\nconst s3 = new aws_sdk_1.default.S3();\nexports.addMachine = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { machineName, code, process } = req.body;\n    machineName = machineName.trim();\n    code = code.trim();\n    const arrayProcess = [];\n    for (const a of process) {\n        const getProcess = await globalProcessModel_1.default.findById(a);\n        if (getProcess) {\n            arrayProcess.push(a);\n        }\n        else {\n            return resp.status(201).json({\n                success: false,\n                message: \"process not found!\",\n            });\n        }\n    }\n    const customer = await machineModel_1.default.create({\n        machineName,\n        code,\n        process: arrayProcess,\n    });\n    return resp.status(201).json({\n        success: true,\n        message: \"machine created successfully\",\n        customer: customer,\n    });\n});\nexports.updateMachine = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { machineName, code, process } = req.body;\n    const machine = await machineModel_1.default.findById(id);\n    const arrayProcess = [];\n    for (const a of process) {\n        const getProcess = await globalProcessModel_1.default.findById(a);\n        if (getProcess) {\n            arrayProcess.push(a);\n        }\n        else {\n            return resp.status(201).json({\n                success: false,\n                message: \"process not found!\",\n            });\n        }\n    }\n    ;\n    if (machine) {\n        const machine = await machineModel_1.default.findByIdAndUpdate({ _id: id }, { machineName, code, process: arrayProcess });\n        return resp.status(201).json({\n            success: true,\n            message: \"machine updated successfully\",\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"machine not found\",\n        });\n    }\n});\nexports.deleteMachine = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const machine = await machineModel_1.default.findById(id);\n    if (machine) {\n        const machine = await machineModel_1.default.findByIdAndDelete(id);\n        return resp.status(201).json({\n            success: true,\n            message: \"machine delete successfully\",\n        });\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"machine not found\",\n        });\n    }\n});\nexports.getMachine = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const machine = await machineModel_1.default.findById(id).populate(\"process\").exec();\n    if (!machine) {\n        return resp.status(404).json({\n            success: false,\n            message: `Machine not found with id ${id}.`\n        });\n    }\n    ;\n    const barCodeslogs = await machineQrCodeLogModel_1.default.find({ \"machine.id\": machine._id }).lean();\n    if (barCodeslogs.length > 0) {\n        machine.proofPicture = barCodeslogs[barCodeslogs.length - 1].proofPicture;\n    }\n    return resp.status(201).json({\n        success: true,\n        message: \"getting machine successfully\",\n        machine: machine,\n    });\n});\nexports.getAllMachine = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, processes, sort, shops } = req.body;\n    const query = {};\n    if (name) {\n        const process = await globalProcessModel_1.default\n            .find({\n            $or: [\n                { processName: { $regex: name, $options: \"i\" } },\n                { processCode: { $regex: name, $options: \"i\" } },\n            ],\n        })\n            .lean();\n        const processIds = process.map((p) => p._id);\n        query.$or = [\n            { machineName: { $regex: name, $options: \"i\" } },\n            { code: { $regex: name, $options: \"i\" } },\n            { process: { $in: processIds } },\n        ];\n    }\n    if (processes && processes.length > 0) {\n        const Processes = await globalProcessModel_1.default.find({\n            processName: { $in: processes },\n        });\n        const processIds = Processes.map((p) => p._id);\n        query.process = { $in: processIds };\n    }\n    if (shops && shops.length) {\n        const Shops = await shopModel_1.default.find({ shopName: { $in: shops } }).lean();\n        const shopIds = Shops.map((s) => s._id);\n        const allProcesses = await globalProcessModel_1.default.find({ \"shop.shopId\": { $in: shopIds } }).lean();\n        if (!query.process) {\n            query.process = { $in: [] };\n        }\n        allProcesses.forEach((a) => {\n            query.process.$in.push(a._id);\n        });\n    }\n    ;\n    const allMachineBarCode = await machineQrCodeLogModel_1.default.find().lean();\n    const machineQRCodeStore = {};\n    allMachineBarCode.forEach((a) => {\n        const id = a.machine.id + \"\";\n        machineQRCodeStore[id] = { ...a };\n    });\n    let machine = await machineModel_1.default.find({ ...query }).populate(\"process\").lean();\n    if (sort) {\n        if (sort === \"asc\") {\n            machine = await machineModel_1.default\n                .find({ ...query })\n                .sort({ machineName: 1 })\n                .populate(\"process\")\n                .exec();\n        }\n        else if (sort === \"dec\") {\n            machine = await machineModel_1.default\n                .find({ ...query })\n                .populate(\"process\")\n                .sort({ machineName: -1 })\n                .exec();\n        }\n        else {\n            machine = await machineModel_1.default\n                .find({ ...query })\n                .populate(\"process\")\n                .sort({ machineName: 1 })\n                .exec();\n        }\n    }\n    else {\n        machine = await machineModel_1.default\n            .find({ ...query })\n            .populate(\"process\")\n            .exec();\n    }\n    ;\n    machine.forEach((m) => {\n        const id = m._id + \"\";\n        const barCode = machineQRCodeStore[id];\n        if (barCode) {\n            m.newProofPicture = barCode.proofPicture || \"\";\n        }\n        ;\n    });\n    return resp.status(200).json({\n        success: true,\n        message: \"getting all Machine successfully\",\n        machine: machine,\n    });\n});\n// add QrCode to machine\nexports.assignQrToMachine = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let _id;\n        if (req.employee) {\n            const employee = await employeeModel_1.default.findOne({ _id: req.employee._id });\n            if (!employee) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Logged in employee with name ${req.employee.name} not found.`,\n                });\n            }\n            _id = employee._id;\n        }\n        if (req.admin) {\n            const admin = await adminModel_1.default.findOne({ _id: req.admin._id });\n            if (!admin) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Logged in Admin with name ${req.admin.name} not found .`,\n                });\n            }\n            _id = admin._id;\n        }\n        const { id } = req.params;\n        const { data } = req.body;\n        const machine = await machineModel_1.default.findById(id);\n        if (!machine) {\n            return resp.status(404).json({\n                success: false,\n                message: `Machine with id ${id} not found.`,\n            });\n        }\n        ;\n        const date = new Date();\n        const updatedDate = date;\n        let qrCode;\n        try {\n            qrCode = await QRCode.toDataURL(data); // Using email as an example\n        }\n        catch (err) {\n            return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n        }\n        ;\n        const newData = {\n            machineName: machine.machineName,\n            id: machine._id,\n        };\n        let isAlreadyUsed = { is: false, value: \"\" };\n        const allMachines = await machineModel_1.default.find();\n        allMachines.forEach((m) => {\n            if (m?.QrCode === qrCode) {\n                isAlreadyUsed.is = true;\n                isAlreadyUsed.value = m.machineName;\n                return;\n            }\n            ;\n        });\n        if (isAlreadyUsed.is === true) {\n            return resp.status(409).json({\n                success: false,\n                message: `Same qr Code already assigned to ${isAlreadyUsed.value}.`,\n            });\n        }\n        machine.QrCode = qrCode;\n        await machine.save();\n        const machineLog = await machineQrCodeLogModel_1.default.create({\n            machine: newData,\n            date: updatedDate,\n            AssignBy: _id,\n            QrCode: data,\n        });\n        resp.status(201).json({\n            success: true,\n            message: `Qr code Assigned to machine ${machine.machineName}.`,\n            machine,\n        });\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: \"Login first.\",\n        });\n    }\n});\n// get machine details by qrCode\nexports.getMachineByQrCode = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { data } = req.body;\n    let qrCode;\n    try {\n        qrCode = await QRCode.toDataURL(data); // Using email as an example\n    }\n    catch (err) {\n        return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n    }\n    ;\n    const machine = await machineModel_1.default.findOne({ QrCode: qrCode });\n    if (!machine) {\n        return resp.status(404).json({\n            success: false,\n            message: `Machine not found with qrCode data of ${data}.`,\n        });\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"Machine found .\",\n        machine,\n    });\n});\n// export const uploadMachineProofImage = catchErrorAsync(\n//   async (req: Request, res: Response, next: NextFunction) => {\n//     try {\n//       const { machineId, data } = req.body;\n//       // Check if a machine with the given ID exists\n//       const machine = await machineModel.findById(machineId);\n//       if (!machine) {\n//         return res.status(404).json({\n//           success: false,\n//           message: `Machine with id ${machineId} not found.`,\n//         });\n//       }\n//       const file = req.file;\n//       const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n//       if (!file) {\n//         return res.status(400).json({\n//           success: false,\n//           message: \"No file uploaded.\",\n//         });\n//       }\n//       const fileExt = extname(file.originalname).toLowerCase();\n//       if (!allowedExtensions.includes(fileExt)) {\n//         return res.status(400).json({\n//           success: false,\n//           message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n//         });\n//       }\n//       const fileKey = `uploads/${uuidv4()}-${file.originalname}`;\n//       const uploadParams: S3.PutObjectRequest = {\n//         Bucket: BUCKET,\n//         Key: fileKey,\n//         Body: file.buffer,\n//         ACL: \"public-read\",\n//       };\n//       await s3.putObject(uploadParams).promise();\n//       const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n//       // Check if a MachineQrCodeModel with the same QR code (data) already exists\n//       let existing = await machineModel.findOne({ _id: machineId });\n//       let existingBarCodeModel = await MachineQrCodeModel.findOne({ QrCode: data });\n//       if (existing||existingBarCodeModel) {\n//         existingBarCodeModel.proofPicture = fileUrl;\n//         await existingBarCodeModel.save();\n//         existing.proofPicture = fileUrl;\n//         await existing.save();\n//         return res.status(200).json({\n//           success: true,\n//           message: \"Proof image updated successfully.\",\n//           machine,\n//         });\n//       }\n//       const newBarCodeModel = await MachineQrCodeModel.create({\n//         machine: {\n//           machineName: machine.machineName,\n//           id: machine._id,\n//         },\n//         QrCode: data,\n//         proofPicture: fileUrl,\n//         createdAt: new Date(),\n//       });\n//       // if (existingBarCodeModel) {\n//       //   // If an existing MachineQrCodeModel is found, update its proofPicture\n//       //   // Return a success response or any necessary information\n//       //   return res.status(200).json({\n//       //     success: true,\n//       //     message: \"Proof image updated successfully.\",\n//       //     barCodeModel: existingBarCodeModel,\n//       //     machine,\n//       //     newBarCodeModel\n//       //   });\n//       // }\n//       // If no existing MachineQrCodeModel is found, create a new one\n//       // Return a success response or any necessary information\n//       res.status(200).json({\n//         success: true,\n//         message: \"Proof image added successfully.\",\n//         barCodeModel: newBarCodeModel,\n//       });\n//     } catch (error) {\n//       // Handle unexpected errors\n//       console.error(error);\n//       res.status(500).json({\n//         success: false,\n//         message: \"An error occurred while processing your request.\",\n//       });\n//     }\n//   }\n// );\nexports.uploadMachineProofImage = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    try {\n        const { machineId, data } = req.body;\n        // Check if a machine with the given ID exists\n        const machine = await machineModel_1.default.findById(machineId);\n        if (!machine) {\n            return res.status(404).json({\n                success: false,\n                message: `Machine with id ${machineId} not found.`,\n            });\n        }\n        ;\n        const file = req.file;\n        const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n        if (!file) {\n            return res.status(400).json({\n                success: false,\n                message: \"No file uploaded.\",\n            });\n        }\n        ;\n        const fileExt = (0, path_1.extname)(file.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return res.status(400).json({\n                success: false,\n                message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n            });\n        }\n        ;\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        await s3.putObject(uploadParams).promise();\n        const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        // Check if a MachineQrCodeModel with the same QR code (data) already exists\n        let existing = await machineModel_1.default.findOne({ _id: machineId });\n        let existingBarCodeModel = await machineQrCodeLogModel_1.default.findOne({\n            QrCode: data,\n        });\n        if (existing || existingBarCodeModel) {\n            if (existingBarCodeModel) {\n                // If an existing MachineQrCodeModel is found, update its proofPicture\n                existingBarCodeModel.proofPicture = fileUrl;\n                await existingBarCodeModel.save();\n            }\n            ;\n            // Update the machine's proofPicture as well\n            if (existing) {\n                existing.proofPicture = fileUrl;\n                await existing.save();\n            }\n            ;\n        }\n        ;\n        // If no existing MachineQrCodeModel is found, create a new one\n        const newBarCodeModel = await machineQrCodeLogModel_1.default.create({\n            machine: {\n                machineName: machine.machineName,\n                id: machine._id,\n            },\n            QrCode: data,\n            proofPicture: fileUrl,\n            createdAt: new Date(),\n        });\n        // Return a success response or any necessary information\n        res.status(200).json({\n            success: true,\n            message: \"Proof image added successfully.\",\n            barCodeModel: newBarCodeModel,\n            machine,\n        });\n    }\n    catch (error) {\n        // Handle unexpected errors\n        console.error(error);\n        res.status(500).json({\n            success: false,\n            message: \"An error occurred while processing your request.\",\n        });\n    }\n});\nexports.uploadMachineImage = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    try {\n        const { machineId } = req.body;\n        // Check if a machine with the given ID exists\n        const machine = await machineModel_1.default.findById(machineId);\n        if (!machine) {\n            return res.status(404).json({\n                success: false,\n                message: `Machine with id ${machineId} not found.`,\n            });\n        }\n        ;\n        const file = req.file;\n        const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n        if (!file) {\n            return res.status(400).json({\n                success: false,\n                message: \"No file uploaded.\",\n            });\n        }\n        ;\n        const fileExt = (0, path_1.extname)(file.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return res.status(400).json({\n                success: false,\n                message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n            });\n        }\n        ;\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        await s3.putObject(uploadParams).promise();\n        const fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        machine.picture = fileUrl;\n        await machine.save();\n        // Return a success response or any necessary information\n        res.status(200).json({\n            success: true,\n            message: \"Proof image added successfully.\",\n            machine,\n        });\n    }\n    catch (error) {\n        // Handle unexpected errors\n        console.error(error);\n        res.status(500).json({\n            success: false,\n            message: \"An error occurred while processing your request.\",\n        });\n    }\n    ;\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/machineController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/planningController.ts":
/*!**************************************************************!*\
  !*** ./src/controllers/bomControllers/planningController.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deletePlanningPerMonth = exports.updatePlanning = exports.getAllPlanning = exports.addPlanningSheet = void 0;\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst planningModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/planningModel */ \"./src/database/models/planningModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst workOrderModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workOrderModel */ \"./src/database/models/workOrderModel.ts\"));\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst finishItemGroupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishItemGroupModel */ \"./src/database/models/finishItemGroupModel.ts\"));\nfunction getDayName(date) {\n    const days = [\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\",\n    ];\n    return days[date.getDay()];\n}\nexports.addPlanningSheet = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { month } = req.body;\n    const selectedMonth = new Date(month);\n    const nextDate = new Date(month);\n    nextDate.setDate(nextDate.getDate() + 2);\n    const lastDate = new Date(month);\n    nextDate.setDate(nextDate.getDate() - 1);\n    const daysInMonth = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth() + 1, 0).getDate();\n    const days = [];\n    for (let i = 1; i <= daysInMonth; i++) {\n        const date = new Date(month);\n        date.setDate(i);\n        const dayName = getDayName(date);\n        days.push({ day: dayName, date });\n    }\n    const finishedItems = await finishedItemModel_1.default.find().lean();\n    for (let item of finishedItems) {\n        const Planning = await planningModel_1.default.findOne({\n            finishedItemId: item._id,\n            month: selectedMonth,\n        });\n        if (!Planning) {\n            const planning = new planningModel_1.default({\n                finishedItemId: item._id,\n                finishedItemName: item.itemName,\n                month: selectedMonth,\n                dates: days,\n            });\n            await planning.save();\n        }\n    }\n    resp.status(200).json({\n        success: true,\n        message: `Created planning for ${month}`,\n        daysInMonth,\n    });\n});\nconst getAllPlanning = async (req, resp, next) => {\n    const { month, status, finishedItemArray, MCodeArray, partCodes, shops, processes, name, groupNames, minInventory } = req.body;\n    try {\n        const query = {};\n        const filter = {};\n        if (month) {\n            const newDate = new Date(month);\n            query.month = newDate;\n        }\n        if (status) {\n            query.status = status;\n        }\n        if (shops && shops.length > 0) {\n            const shopDetails = await shopModel_1.default.find({\n                shopName: { $in: shops },\n            }).lean();\n            const ids = shopDetails.map((s) => s._id);\n            const processes = await globalProcessModel_1.default\n                .find({ \"shop.shopId\": { $in: ids } })\n                .lean();\n            const processIds = processes.map((p) => p._id);\n            filter[\"masterBom.process.id\"] = { $in: processIds };\n        }\n        if (groupNames && groupNames.length) {\n            const group = await finishItemGroupModel_1.default.find({ groupName: { $in: groupNames } });\n            const groupIds = group.map((g) => g._id);\n            filter.finishItemGroupId = { $in: groupIds };\n        }\n        ;\n        if (processes && processes.length > 0) {\n            const Processes = await globalProcessModel_1.default\n                .find({ processName: { $in: processes } })\n                .lean();\n            if (!filter[\"masterBom.process.id\"]) {\n                filter[\"masterBom.process.id\"] = { $in: [] };\n            }\n            Processes.forEach((p) => {\n                filter[\"masterBom.process.id\"].$in.push(p._id);\n            });\n        }\n        if (MCodeArray && MCodeArray.length > 0) {\n            filter.MCode = { $in: MCodeArray };\n        }\n        if (partCodes && partCodes.length > 0) {\n            filter.partCode = { $in: partCodes };\n        }\n        if (finishedItemArray && finishedItemArray.length > 0) {\n            filter.itemName = { $in: finishedItemArray };\n        }\n        ;\n        if (name) {\n            filter.$or = [\n                { itemName: { $regex: name, $options: \"i\" } },\n                { MCode: { $regex: name, $options: \"i\" } },\n                { partCode: { $regex: name, $options: \"i\" } },\n            ];\n        }\n        ;\n        const finishedItems = await finishedItemModel_1.default.find({ ...filter }).lean();\n        if (finishedItems && finishedItems.length) {\n            const fIds = finishedItems.map((f) => f._id);\n            query.finishedItemId = { $in: fIds };\n        }\n        const allWorkOrders = await workOrderModel_1.default.find({ status: { $nin: [\"cancel\"] } }).lean();\n        const allProductionSlips = await productionSlipModel_1.default.find().lean();\n        const allFinishedItems = await finishedItemModel_1.default.find().lean();\n        const productionSlipWithWorkOrder = {};\n        const mcodeStore = {};\n        const finishedItemStore = {};\n        allFinishedItems.forEach((a) => {\n            const MCode = a.MCode + \"\";\n            const id = a._id + \"\";\n            finishedItemStore[id] = {\n                MCode\n            };\n            mcodeStore[MCode] = {\n                inventory: 0\n            };\n        });\n        allProductionSlips.forEach((a) => {\n            const workOrderId = a.workOrderId + \"\";\n            if (!productionSlipWithWorkOrder[workOrderId]) {\n                productionSlipWithWorkOrder[workOrderId] = {\n                    productionSlips: []\n                };\n            }\n            ;\n            productionSlipWithWorkOrder[workOrderId].productionSlips.push({ ...a });\n        });\n        allWorkOrders.forEach((a) => {\n            const workOrderId = a._id + \"\";\n            // console.log(workOrderId);\n            const MCode = a.MCode + \"\";\n            const loadingId = a.masterBom[a.masterBom.length - 1]._id + \"\";\n            const finishedItemId = a.masterBom[a.masterBom.length - 2]._id + \"\";\n            const productionSlips = productionSlipWithWorkOrder[workOrderId]?.productionSlips || [];\n            let totalLoading = 0;\n            let totalFinishedItem = 0;\n            // console.log(productionSlips.length);\n            productionSlips?.forEach((p) => {\n                // console.log(\"in productionSLip loop\",p.part._id+\"\");\n                if (p.part._id + \"\" === loadingId) {\n                    // console.log(\"item produced.\",p.itemProduced+\"\");\n                    totalLoading += p.itemProduced;\n                }\n                else if (p.part._id + \"\" === finishedItemId + \"\") {\n                    // console.log(\"item produced\" , p.itemProduced);\n                    totalFinishedItem += p.itemProduced;\n                }\n                ;\n            });\n            const totalInventory = totalFinishedItem - totalLoading;\n            if (mcodeStore[MCode]) {\n                mcodeStore[MCode].inventory += totalInventory;\n            }\n            ;\n        });\n        const getAllPlanning = await planningModel_1.default.find({ ...query }).lean();\n        const result = [];\n        getAllPlanning.forEach((g) => {\n            let totalDispatchValue = 0;\n            const finishedItemId = g.finishedItemId + \"\";\n            const MCode = finishedItemStore[finishedItemId]?.MCode + \"\" || \"\";\n            //  console.log(MCode)\n            const inventory = mcodeStore[MCode]?.inventory || 0;\n            //  console.log(inventory);\n            let totalOrderValue = minInventory ? g.minimumInventory : 0;\n            g.dates.forEach((d) => {\n                totalDispatchValue += d.dispatchValue ? d.dispatchValue : 0;\n                totalOrderValue += d.orderValue ? d.orderValue : 0;\n            });\n            const obj = {\n                totalDispatchValue,\n                totalOrderValue,\n                MCode,\n                currentInventory: inventory,\n                ...g,\n            };\n            result.push(obj);\n        });\n        const endDate = new Date();\n        endDate.setDate(1);\n        resp.status(200).json({\n            success: true,\n            message: \"Getting all Planning per month.\",\n            planningSheet: result,\n            endDate\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.getAllPlanning = getAllPlanning;\n// update planning\nexports.updatePlanning = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { planningId } = req.params;\n    const { status, inventory, days } = req.body;\n    console.log(inventory);\n    // console.log(days);\n    const daysStore = {};\n    if (days) {\n        days.forEach((d) => {\n            const date = new Date(d.date);\n            date.setHours(0, 0, 0, 0);\n            daysStore[date + \"\"] = {\n                ...d,\n            };\n        });\n    }\n    if (req.employee || req.admin) {\n        let name = \"\";\n        let employeeId;\n        if (req.employee) {\n            name = req.employee.name;\n            employeeId = req.employee._id;\n        }\n        if (req.admin) {\n            name = req.admin.name;\n            employeeId = req.admin._id;\n        }\n        const planningDetails = await planningModel_1.default.findById(planningId);\n        if (!planningDetails) {\n            return resp.status(404).json({\n                success: false,\n                message: `Planning not found with Id ${planningId} .`,\n            });\n        }\n        if (days) {\n            planningDetails.dates.forEach((i) => {\n                const date = new Date(i.date);\n                date.setHours(0, 0, 0, 0);\n                if (daysStore[date + \"\"]) {\n                    const data = daysStore[date + \"\"];\n                    i.orderValue = data.value;\n                    if (!i.by) {\n                        i.by = [];\n                    }\n                    i.by.push({\n                        orderValue: data.value,\n                        employeeId,\n                        name,\n                        date: new Date(),\n                    });\n                }\n            });\n        }\n        ;\n        if (inventory || inventory === 0) {\n            planningDetails.minimumInventory = inventory;\n        }\n        ;\n        if (status) {\n            planningDetails.status = status;\n        }\n        ;\n        await planningDetails.save();\n        resp.status(200).json({\n            success: true,\n            message: \"Updated planning sheet.\",\n            planningDetails,\n        });\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: \"Not Authorised.\",\n        });\n    }\n});\nexports.deletePlanningPerMonth = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { month } = req.query;\n    const record = await planningModel_1.default.deleteMany({ month });\n    resp.status(200).json({\n        success: false,\n        message: `Deleted data of month ${month}`,\n    });\n});\n// use this to destory planning.\n// export const checking = async ( req :Request,resp:Response ,next : NextFunction)=>{\n//       try {\n//         const firstDate = new Date();\n//         firstDate.setDate(1);\n//         firstDate.setHours(0,0,0,0);\n//      const productionSlips = await ProductionSlipModel.find({status:\"completed\",itemProduced:{$gt:0},createdAt:{\n//       $gte:firstDate\n//      }}).lean();\n//      const workOrders = await workOrderModel.find().lean();\n//      const finishedItems = await FinishedItemModel.find().lean();\n//      const lastPartStore:any = {};\n//      const finishedItemStore:any = {};\n//      finishedItems.forEach((f)=>{\n//         const MCode = f.MCode+\"\";\n//         finishedItemStore[MCode] = {_id :f._id};\n//      })\n//      workOrders.forEach((w)=>{\n//          const id = w._id+\"\";\n//          const MCode = w.MCode+\"\";\n//          lastPartStore[id] = { loadingId : w.masterBom[w.masterBom.length -1]._id, MCode};\n//      });\n//      for(let p of productionSlips){\n//       console.log(p.productionSlipNumber);\n//        const partId = p.part._id+\"\";\n//        const loadingId = lastPartStore[p.workOrderId+\"\"].loadingId+\"\";\n//        if(partId === loadingId){\n//           const MCode = lastPartStore[p.workOrderId+\"\"].MCode||\"\";\n//           const finishedItemId = finishedItemStore[MCode+\"\"]?._id;\n//           const month = new Date(p.durationFrom);\n//           month.setUTCDate(1);\n//           month.setUTCHours(0,0,0,0);\n//           const date = new Date(p.durationTo);\n//           date.setHours(0,0,0,0);\n//           if(finishedItemId){\n//           const planning = await PlanningModel.findOne({\n//             month,\n//             finishedItemId\n//           });\n//           if(!planning){\n//             return;\n//           }\n//           for(let d of planning.dates){\n//               const newDate = new Date(d.date);\n//               newDate.setHours(0,0,0,0);\n//               if(newDate+\"\" === date+\"\"){\n//                  if(!d.dispatchValue){\n//                   d.dispatchValue = 0;\n//                  }\n//                  console.log(\"Inside loop\",p.productionSlipNumber)\n//                  d.dispatchValue += p.itemProduced;\n//               }\n//           }\n//           await planning.save();\n//        }\n//       }\n//      }\n//      resp.status(200).json({\n//       success:false,\n//       message:\"Done\"\n//      })\n//     } catch (error) {\n//         console.log(error);\n//     }\n// }\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/planningController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/productionSlipController.ts":
/*!********************************************************************!*\
  !*** ./src/controllers/bomControllers/productionSlipController.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.statusCards = exports.getProductivityPerEmployee = exports.gettingHours = exports.addingOrderQuantity = exports.updateProductionSlipStatus = exports.EditProduction = exports.countPdfPrint = exports.multiProductionSlipEnglish = exports.multiProductionSlip = exports.getChildPartWithProductionSlipCount = exports.activeIdleEmployees = exports.activeIdleMachines = exports.productionSlipExcelPerWorkOrder = exports.productionSlipExcel2 = exports.productionSlipExcel = exports.gettingAllActiveProductionSlipAllWorkOrder = exports.gettingAllActiveProductionSlip = exports.getProductionSlipData = exports.getLastWorkingData = exports.addEmployeeAndMachine = exports.machineSuggestions = exports.employeeSuggestions = exports.addMultipleProductionSlips = exports.addProductionSlip = exports.addCompletedSlip = void 0;\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst workOrderModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workOrderModel */ \"./src/database/models/workOrderModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst QRCode = __importStar(__webpack_require__(/*! qrcode */ \"qrcode\"));\n// import { getIndianTime } from \"../../middleware/dateTimeConverter\";\nconst shopLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopLogModel */ \"./src/database/models/shopLogModel.ts\"));\nconst machineModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/machineModel */ \"./src/database/models/machineModel.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst planningModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/planningModel */ \"./src/database/models/planningModel.ts\"));\nconst translate_1 = __webpack_require__(/*! ../../translate */ \"./src/translate.ts\");\nfunction formatNumberWithLeadingZeros(number, desiredLength) {\n    // Convert the number to a string\n    let numberStr = number.toString();\n    // Calculate the number of zeros to add\n    const zerosToAdd = desiredLength - numberStr.length;\n    if (zerosToAdd > 0) {\n        // Add leading zeros\n        numberStr = \"0\".repeat(zerosToAdd) + numberStr;\n    }\n    return numberStr;\n}\nconst addCompletedSlip = async (data) => {\n    const { workOrderId, childPartId, employeeIds, machineIds, itemProduced, startTime, endTime, name, status, employeeId, remark } = data;\n    const workOrder = await workOrderModel_1.default.findById({ _id: workOrderId });\n    if (!workOrder) {\n        return {\n            success: false,\n            message: \"Work order not found.\",\n        };\n    }\n    ;\n    const lastPartId = workOrder.masterBom[workOrder.masterBom.length - 1]._id;\n    const finishedItem = await finishedItemModel_1.default.findOne({\n        MCode: workOrder.MCode,\n    });\n    if (!finishedItem) {\n        return {\n            success: false,\n            message: `FinishedItem not found with MCODE ${workOrder.MCode}`,\n        };\n    }\n    // if (employeeIds.length === 0) {\n    //   return {\n    //     success: false,\n    //     message: \"Employees array cannot be empty.\",\n    //   };\n    // }\n    // if (machineIds.length === 0) {\n    //   return {\n    //     success: false,\n    //     message: \"Machines array cannot be empty\",\n    //   };\n    // }\n    const employees = await employeeModel_1.default.find({ _id: { $in: employeeIds } });\n    const employeeData = [];\n    if (employees.length > 0) {\n        employees.forEach((e) => {\n            const obj = {\n                employeeId: e._id,\n                employeeName: e.name,\n            };\n            employeeData.push(obj);\n        });\n    }\n    const machines = await machineModel_1.default.find({ _id: { $in: machineIds } });\n    const machineData = [];\n    machines.forEach((m) => {\n        const obj = {\n            machineId: m._id,\n            machineName: m.machineName,\n        };\n        machineData.push(obj);\n    });\n    let partName;\n    let totalNumberOfItem;\n    let consumedItem;\n    let process;\n    let setindex = 0;\n    workOrder.masterBom.forEach((w, index) => {\n        const id = w._id + \"\";\n        if (childPartId == id) {\n            partName = w.partName;\n            totalNumberOfItem = w.numberOfItem;\n            consumedItem = w.newChild;\n            process = w.processId;\n            setindex = index;\n        }\n    });\n    const part = {\n        _id: childPartId,\n        partName,\n    };\n    const processDetails = await globalProcessModel_1.default.findOne({\n        _id: process,\n    });\n    if (!processDetails) {\n        return {\n            success: false,\n            message: \"Process not found. \",\n        };\n    }\n    if (!processDetails.shop) {\n        return {\n            success: false,\n            message: \"Process does not have a Shop , Process added without Shop .\",\n        };\n    }\n    const shop = await shopModel_1.default.findOne({ _id: processDetails.shop.shopId });\n    if (!shop || !shop.shopCode) {\n        return {\n            success: false,\n            message: `Shop not found with name ${processDetails.shop.shopName} or shopCode not available.`,\n        };\n    }\n    const allProductionSlips = await productionSlipModel_1.default.find({\n        \"shop.shopId\": shop._id,\n    });\n    let length = allProductionSlips.length;\n    let number = formatNumberWithLeadingZeros(length + 1, 4);\n    let productionSlipNumber = shop.shopCode + \"-\" + number;\n    let qrCode;\n    try {\n        qrCode = await QRCode.toDataURL(productionSlipNumber);\n    }\n    catch (err) {\n        return {\n            success: false,\n            message: `Error in QR generation.`,\n        };\n    }\n    let quantityLeft = 0;\n    const productionSlips = await productionSlipModel_1.default.find({\n        workOrderId: workOrder._id,\n        \"process.processId\": processDetails?._id,\n        \"part._id\": part._id,\n    }).lean();\n    productionSlips.forEach((p) => {\n        quantityLeft += p.itemProduced;\n    });\n    const productionSlip = await productionSlipModel_1.default.create({\n        productionSlipNumber,\n        workOrderId: workOrder._id,\n        QRCode: qrCode,\n        process: {\n            processId: processDetails?._id,\n            processName: processDetails?.processName,\n        },\n        shop: {\n            shopName: shop?.shopName,\n            shopId: shop?._id,\n        },\n        createdBy: {\n            name,\n            employeeId,\n        },\n        completedBy: {\n            name,\n            employeeId,\n        },\n        activatedBy: {\n            name,\n            employeeId,\n        },\n        part,\n        numberOfItems: quantityLeft,\n        itemPerWorkOrder: totalNumberOfItem,\n        consumedItem,\n    });\n    if (machineIds && machineIds.length > 0) {\n        for (let m of machineIds) {\n            const machine = await machineModel_1.default.findById(m);\n            if (machine) {\n                machine.logs.push({\n                    productionSlipId: productionSlip._id,\n                    time: startTime ? new Date(startTime) : new Date(),\n                });\n                await machine.save();\n            }\n        }\n    }\n    if (employeeIds && employeeIds.length > 0) {\n        for (let e of employeeIds) {\n            const employee = await employeeModel_1.default.findById(e);\n            if (employee) {\n                employee.productionLogs.push({\n                    productionSlipId: productionSlip._id,\n                    time: startTime ? new Date(startTime) : new Date(),\n                });\n                await employee.save();\n            }\n        }\n    }\n    const obj = {\n        updatedBy: {\n            name,\n            employeeId,\n        },\n        date: startTime ? new Date(startTime) : new Date(),\n        startTime: startTime ? new Date(startTime) : new Date(),\n        itemProduced: itemProduced,\n        employees: employeeData,\n        machines: machineData,\n        endTime: endTime ? new Date(endTime) : new Date(),\n    };\n    productionSlip.working.push(obj);\n    productionSlip.durationFrom = startTime ? new Date(startTime) : new Date();\n    productionSlip.durationTo = endTime ? new Date(endTime) : new Date();\n    productionSlip.itemProduced = itemProduced;\n    productionSlip.status = status || \"\";\n    productionSlip.manualRemark = remark || \"\";\n    await productionSlip.save();\n    const endDate = new Date(productionSlip.durationTo);\n    endDate.setHours(0, 0, 0, 0);\n    const month = new Date(productionSlip.durationTo);\n    month.setUTCDate(1);\n    month.setUTCHours(0, 0, 0, 0);\n    let planning;\n    if (productionSlip.part._id + \"\" === lastPartId + \"\") {\n        planning = await planningModel_1.default.findOne({\n            finishedItemId: finishedItem._id,\n            month: month,\n        });\n        planning?.dates.forEach((p) => {\n            const date = new Date(p.date);\n            date.setHours(0, 0, 0, 0);\n            if (date + \"\" === endDate + \"\") {\n                if (!p.dispatchValue) {\n                    p.dispatchValue = 0;\n                }\n                p.dispatchValue += itemProduced;\n            }\n        });\n        await planning?.save();\n    }\n    ;\n    return {\n        success: true,\n        message: `Created a completed Production slip with number ${productionSlipNumber}.`,\n        productionSlip,\n        planning,\n    };\n};\nexports.addCompletedSlip = addCompletedSlip;\nexports.addProductionSlip = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { workOrderId, childPartId } = req.body;\n    if (req.employee || req.admin) {\n        let name = \"\";\n        let employeeId;\n        if (req.employee) {\n            name = req.employee.name;\n            employeeId = req.employee._id;\n        }\n        if (req.admin) {\n            name = req.admin.name;\n            employeeId = req.admin._id;\n        }\n        const workOrder = await workOrderModel_1.default.findById({ _id: workOrderId });\n        if (!workOrder) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Work order not found.\",\n            });\n        }\n        if (workOrder.status == \"completed\") {\n            return resp.status(404).json({\n                success: false,\n                message: \"Work order already completed.\",\n            });\n        }\n        if (workOrder.status === \"pending\") {\n            workOrder.status = \"inProgress\";\n            await workOrder.save();\n        }\n        let partName;\n        let totalNumberOfItem;\n        let consumedItem;\n        let process;\n        let setindex = 0;\n        workOrder.masterBom.forEach((w, index) => {\n            const id = w._id + \"\";\n            if (childPartId == id) {\n                partName = w.partName;\n                totalNumberOfItem = w.numberOfItem;\n                consumedItem = w.newChild;\n                process = w.process;\n                setindex = index + 1;\n            }\n        });\n        const part = {\n            _id: childPartId,\n            partName,\n        };\n        const processDetails = await globalProcessModel_1.default.findOne({\n            processName: process,\n        });\n        if (!processDetails) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Process not found. \",\n            });\n        }\n        if (!processDetails.shop) {\n            return resp.status(400).json({\n                success: false,\n                message: \"Process does not have a Shop , Process added without Shop .\",\n            });\n        }\n        const shop = await shopModel_1.default.findOne({ _id: processDetails.shop.shopId });\n        if (!shop || !shop.shopCode) {\n            return resp.status(404).json({\n                success: false,\n                message: `Shop not found with name ${processDetails.shop.shopName} or shopCode not available.`,\n            });\n        }\n        const allProductionSlips = await productionSlipModel_1.default.find({\n            \"shop.shopId\": shop._id,\n        });\n        let length = allProductionSlips.length;\n        let number = formatNumberWithLeadingZeros(length + 1, 4);\n        let productionSlipNumber = shop?.shopCode + \"-\" + number;\n        let qrCode;\n        try {\n            qrCode = await QRCode.toDataURL(productionSlipNumber);\n        }\n        catch (err) {\n            return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n        }\n        let quantityLeft = 0;\n        const productionSlips = await productionSlipModel_1.default.find({\n            workOrderId: workOrder._id,\n            \"process.processId\": processDetails?._id,\n            \"part._id\": part._id,\n        });\n        productionSlips.forEach((p) => {\n            quantityLeft += p?.itemProduced;\n        });\n        const productionSlip = await productionSlipModel_1.default.create({\n            productionSlipNumber,\n            workOrderId: workOrder._id,\n            QRCode: qrCode,\n            process: {\n                processId: processDetails?._id,\n                processName: processDetails?.processName,\n            },\n            shop: {\n                shopName: shop?.shopName,\n                shopId: shop?._id,\n            },\n            createdBy: {\n                name,\n                employeeId,\n            },\n            part,\n            numberOfItems: totalNumberOfItem ? totalNumberOfItem : 0 - quantityLeft,\n            itemPerWorkOrder: totalNumberOfItem,\n            consumedItem,\n        });\n        resp.status(201).json({\n            success: true,\n            message: \"Production slip created.\",\n            productionSlip,\n        });\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: \"Not Authorised\",\n        });\n    }\n});\n// add multiple productionslips\nexports.addMultipleProductionSlips = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { workOrderId, childPartIds } = req.body;\n    if (req.employee || req.admin) {\n        let name = \"\";\n        let employeeId;\n        if (req.employee) {\n            name = req.employee.name;\n            employeeId = req.employee._id;\n        }\n        if (req.admin) {\n            name = req.admin.name;\n            employeeId = req.admin._id;\n        }\n        const workOrder = await workOrderModel_1.default.findById({ _id: workOrderId });\n        if (!workOrder) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Work order not found.\",\n            });\n        }\n        if (workOrder.status == \"completed\") {\n            return resp.status(404).json({\n                success: false,\n                message: \"Work order already completed.\",\n            });\n        }\n        if (workOrder.status === \"pending\") {\n            workOrder.status = \"inProgress\";\n            await workOrder.save();\n        }\n        const processes = await globalProcessModel_1.default.find().lean();\n        const processStore = {};\n        processes.forEach((p) => {\n            const id = p._id + \"\";\n            processStore[id] = { ...p };\n        });\n        const allShop = await shopModel_1.default.find().lean();\n        const shopStore = {};\n        allShop.forEach((a) => {\n            const id = a._id + \"\";\n            shopStore[id] = { ...a };\n        });\n        for (let childPartId of childPartIds) {\n            let partName;\n            let totalNumberOfItem;\n            let consumedItem;\n            let process;\n            let setindex = 0;\n            workOrder.masterBom.forEach((w, index) => {\n                const id = w._id + \"\";\n                if (childPartId == id) {\n                    partName = w.partName;\n                    totalNumberOfItem = w.numberOfItem;\n                    consumedItem = w.newChild;\n                    process = w.processId;\n                    setindex = index + 1;\n                }\n            });\n            const part = {\n                _id: childPartId,\n                partName,\n            };\n            const processDetails = processStore[process + \"\"];\n            if (!processDetails) {\n                return resp.status(404).json({\n                    success: false,\n                    message: \"Process not found. \",\n                });\n            }\n            if (!processDetails.shop) {\n                return resp.status(400).json({\n                    success: false,\n                    message: `Process ${processDetails.processName} added without Shop .`,\n                });\n            }\n            const shop = shopStore[processDetails.shop.shopId + \"\"];\n            if (!shop || !shop.shopCode) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `childPartName ${partName} ,Shop not found with name ${processDetails.shop.shopName} or shopCode not available.`,\n                });\n            }\n            const allProductionSlips = await productionSlipModel_1.default.find({\n                \"shop.shopId\": shop._id,\n            });\n            let length = allProductionSlips.length;\n            let number = formatNumberWithLeadingZeros(length + 1, 4);\n            let productionSlipNumber = shop?.shopCode + \"-\" + number;\n            let qrCode;\n            try {\n                qrCode = await QRCode.toDataURL(productionSlipNumber);\n            }\n            catch (err) {\n                return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n            }\n            let quantityLeft = 0;\n            const productionSlips = await productionSlipModel_1.default.find({\n                workOrderId: workOrder._id,\n                \"process.processId\": processDetails?._id,\n                \"part._id\": part._id,\n            }).lean();\n            productionSlips.forEach((p) => {\n                quantityLeft += p.itemProduced;\n            });\n            const productionSlip = await productionSlipModel_1.default.create({\n                productionSlipNumber,\n                workOrderId: workOrder._id,\n                QRCode: qrCode,\n                process: {\n                    processId: processDetails?._id,\n                    processName: processDetails?.processName,\n                },\n                shop: {\n                    shopName: shop?.shopName,\n                    shopId: shop?._id,\n                },\n                createdBy: {\n                    name,\n                    employeeId,\n                },\n                part,\n                numberOfItems: totalNumberOfItem ? totalNumberOfItem : 0 - quantityLeft,\n                itemPerWorkOrder: totalNumberOfItem,\n                consumedItem,\n            });\n        }\n        resp.status(201).json({\n            success: true,\n            message: \"Production slip created.\",\n        });\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: \"Not authorised.\",\n        });\n    }\n});\nexports.employeeSuggestions = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumber } = req.params;\n    let date = new Date();\n    let nextDay;\n    date = new Date(date);\n    date.setHours(0, 0, 0, 0);\n    // date.setHours(date.getHours() - (11.5));\n    date.setHours(date.getHours() - 6);\n    nextDay = new Date(date);\n    nextDay.setDate(nextDay.getDate() + 2);\n    nextDay.setHours(0, 0, 0, 0);\n    // nextDay.setHours(nextDay.getHours() - (11.5));\n    nextDay.setHours(nextDay.getHours() - 6);\n    const allEmployees = await employeeModel_1.default.find().lean();\n    const employeeStore = {};\n    allEmployees.forEach((a) => {\n        const id = a._id + \"\";\n        employeeStore[id] = {\n            ...a,\n        };\n    });\n    const productionSlip = await productionSlipModel_1.default.findOne({\n        productionSlipNumber,\n    });\n    if (!productionSlip) {\n        return resp.status(404).json({\n            success: false,\n            message: `Production Slip not found with number ${productionSlipNumber}.`,\n        });\n    }\n    if (!productionSlip.shop.shopId) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Production slip created without Shop details.\",\n        });\n    }\n    const shop = await shopModel_1.default.findById({ _id: productionSlip.shop.shopId });\n    if (!shop) {\n        return resp.status(404).json({\n            success: false,\n            message: `\"${productionSlip.shop.shopName}\" Shop not found.`,\n        });\n    }\n    const data = await shopLogModel_1.default.findOne({\n        date: {\n            $gte: date,\n            $lt: nextDay,\n        },\n        shopId: shop._id,\n    });\n    const result = [];\n    data?.employees.forEach((d) => {\n        const id = d.employeeId + \"\";\n        const data = employeeStore[id];\n        const obj = {\n            employeeName: data.name,\n            employeeId: d.employeeId,\n            employeeCode: data.employeeCode,\n        };\n        result.push(obj);\n    });\n    resp.status(200).json({\n        success: true,\n        message: `getting all employee of shop ${shop.shopName}`,\n        employee: result,\n    });\n});\nexports.machineSuggestions = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumber } = req.params;\n    const productionSlip = await productionSlipModel_1.default.findOne({\n        productionSlipNumber,\n    });\n    if (!productionSlip) {\n        return resp.status(404).json({\n            success: false,\n            message: `Production Slip not found with number ${productionSlipNumber}.`,\n        });\n    }\n    const process = await globalProcessModel_1.default.findById({\n        _id: productionSlip.process.processId,\n    });\n    const processId = process?._id;\n    // console.log(process);\n    const machinesWithProcess = await machineModel_1.default.find({\n        process: { $in: [processId] },\n    });\n    // console.log(machinesWithProcess);\n    const data = [];\n    machinesWithProcess.forEach((m) => {\n        const obj = {\n            machineName: m.machineName,\n            machineId: m._id,\n        };\n        data.push(obj);\n    });\n    resp.status(200).json({\n        success: true,\n        message: `getting all machine which can process ${process?.processName}`,\n        machines: data,\n    });\n});\nfunction convertTimeTo24HourFormat(timeString) {\n    // Split the time string into components\n    const [time, amOrPm] = timeString.split(\" \");\n    // Split the time into hours and minutes\n    let [hours, minutes] = time.split(\":\").map(Number);\n    // Convert to 24-hour format\n    if (amOrPm.toLowerCase() === \"pm\" && hours !== 12) {\n        hours += 12;\n    }\n    else if (amOrPm.toLowerCase() === \"am\" && hours === 12) {\n        hours = 0;\n    }\n    const obj = {\n        hour: hours,\n        min: minutes,\n    };\n    // Return the time in 24-hour format\n    return obj;\n}\n// add working in production slip\nexports.addEmployeeAndMachine = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumber, durationFrom, durationTo, employeeIds, machineIds, itemProduced, } = req.body;\n    //  console.log(itemProduced);\n    if (req.employee || req.admin) {\n        let name = \"\";\n        let employeeId1;\n        if (req.employee) {\n            name = req.employee.name;\n            employeeId1 = req.employee._id;\n        }\n        if (req.admin) {\n            name = req.admin.name;\n            employeeId1 = req.admin._id;\n        }\n        const productionSlip = await productionSlipModel_1.default.findOne({\n            productionSlipNumber,\n        });\n        if (!productionSlip) {\n            return resp.status(404).json({\n                success: false,\n                message: `Production Slip not found with number ${productionSlipNumber}.`,\n            });\n        }\n        if (productionSlip.status == \"completed\") {\n            return resp.status(400).json({\n                success: false,\n                message: `Production slip with number ${productionSlip.productionSlipNumber} already completed.`,\n            });\n        }\n        if (durationFrom) {\n            const timee = convertTimeTo24HourFormat(durationFrom);\n            const date = new Date();\n            date.setHours(0, 0, 0, 0);\n            date.setHours(timee.hour, timee.min);\n            date.setTime(date.getTime() - (330 * 60 * 1000));\n            if (employeeIds.length === 0) {\n                return resp.status(400).json({\n                    success: false,\n                    message: \"Employees array cannot be empty.\",\n                });\n            }\n            if (machineIds.length === 0) {\n                return resp.status(400).json({\n                    success: false,\n                    message: \"Machines array cannot be empty\",\n                });\n            }\n            // adding logs to machines\n            for (let m of machineIds) {\n                const machine = await machineModel_1.default.findById(m);\n                if (machine) {\n                    machine.logs.push({\n                        productionSlipId: productionSlip._id,\n                        time: date,\n                    });\n                    await machine.save();\n                }\n            }\n            for (let e of employeeIds) {\n                const employee = await employeeModel_1.default.findById(e);\n                if (employee) {\n                    employee.productionLogs.push({\n                        productionSlipId: productionSlip._id,\n                        time: date,\n                    });\n                    await employee.save();\n                }\n            }\n            const employees = await employeeModel_1.default.find({\n                _id: { $in: employeeIds },\n            });\n            const employeeData = [];\n            if (employees.length > 0) {\n                employees.forEach((e) => {\n                    const obj = {\n                        employeeId: e._id,\n                        employeeName: e.name,\n                    };\n                    employeeData.push(obj);\n                });\n            }\n            const machines = await machineModel_1.default.find({ _id: { $in: machineIds } });\n            const machineData = [];\n            machines.forEach((m) => {\n                const obj = {\n                    machineId: m._id,\n                    machineName: m.machineName,\n                };\n                machineData.push(obj);\n            });\n            const obj = {\n                updatedBy: { name, employeeId: employeeId1 },\n                date,\n                startTime: date,\n                employees: employeeData,\n                machines: machineData,\n            };\n            productionSlip.working.push(obj);\n            if (productionSlip.working.length == 1) {\n                productionSlip.activatedBy = {\n                    name,\n                    employeeId: employeeId1,\n                };\n                productionSlip.durationFrom = date;\n                productionSlip.status = \"active\";\n            }\n            if (productionSlip.working.length > 1 &&\n                (itemProduced === undefined ||\n                    itemProduced === null ||\n                    isNaN(itemProduced))) {\n                return resp.status(400).json({\n                    success: false,\n                    message: \"Item Produced field cannot be empty.\",\n                });\n            }\n            ;\n            if (itemProduced) {\n                productionSlip.working[productionSlip.working.length - 2].itemProduced = itemProduced;\n                productionSlip.working[productionSlip.working.length - 2].endTime =\n                    date;\n            }\n            ;\n            let totalProduced = 0;\n            productionSlip.working.forEach((w) => {\n                if (w.itemProduced) {\n                    totalProduced += w.itemProduced;\n                }\n            });\n            productionSlip.itemProduced = totalProduced;\n            await productionSlip.save();\n            resp.status(201).json({\n                success: true,\n                message: `Data added to production slip number ${productionSlip.productionSlipNumber}`,\n                productionSlip,\n            });\n        }\n        else if (durationTo) {\n            let durationToDate = new Date();\n            const toTime = convertTimeTo24HourFormat(durationTo);\n            durationToDate.setHours(0, 0, 0, 0);\n            durationToDate.setHours(toTime.hour, toTime.min);\n            durationToDate.setTime(durationToDate.getTime() - (330 * 60 * 1000));\n            productionSlip.durationTo = durationToDate;\n            productionSlip.completedBy = { name, employeeId: employeeId1 };\n            productionSlip.status = \"completed\";\n            productionSlip.working[productionSlip.working.length - 1].updatedBy = {\n                name,\n                employeeId: employeeId1,\n            };\n            productionSlip.working[productionSlip.working.length - 1].itemProduced =\n                itemProduced;\n            productionSlip.working[productionSlip.working.length - 1].endTime =\n                durationToDate;\n            let totalProduced = 0;\n            productionSlip.working.forEach((w) => {\n                if (w.itemProduced) {\n                    totalProduced += w.itemProduced;\n                }\n            });\n            const workOrder = await workOrderModel_1.default.findOne({\n                _id: productionSlip.workOrderId,\n            });\n            const finishedItem = await finishedItemModel_1.default.findOne({\n                MCode: workOrder?.MCode,\n            });\n            const lastPartId = workOrder?.masterBom[workOrder.masterBom.length - 1]._id;\n            productionSlip.itemProduced = totalProduced;\n            await productionSlip.save();\n            const month = new Date();\n            month.setUTCDate(1);\n            month.setUTCHours(0, 0, 0, 0);\n            const endDate = new Date(productionSlip.durationTo);\n            endDate.setHours(0, 0, 0, 0);\n            let planning;\n            if (productionSlip.part._id + \"\" === lastPartId + \"\") {\n                planning = await planningModel_1.default.findOne({\n                    finishedItemId: finishedItem?._id,\n                    month,\n                });\n                planning?.dates.forEach((p) => {\n                    const date = new Date(p.date);\n                    date.setHours(0, 0, 0, 0);\n                    if (date + \"\" === endDate + \"\") {\n                        if (!p.dispatchValue) {\n                            p.dispatchValue = 0;\n                        }\n                        p.dispatchValue += totalProduced;\n                    }\n                    ;\n                });\n                await planning?.save();\n            }\n            ;\n            resp.status(201).json({\n                success: true,\n                message: `Data added to production slip number ${productionSlip.productionSlipNumber}`,\n                productionSlip,\n            });\n        }\n        else {\n            return resp.status(400).json({\n                success: false,\n                message: \"Start time or End time is required.\",\n            });\n        }\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            messsage: \"Not Authorised.\",\n        });\n    }\n});\n//get employees and machines for auto select\nexports.getLastWorkingData = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumber } = req.params;\n    const productionSlip = await productionSlipModel_1.default.findOne({\n        productionSlipNumber,\n    });\n    if (!productionSlip) {\n        return resp.status(404).json({\n            success: false,\n            message: `Production slip with this number ${productionSlip}.`,\n        });\n    }\n    const employees = productionSlip.working[productionSlip.working.length - 1].employees;\n    const machines = productionSlip.working[productionSlip.working.length - 1].machines;\n    resp.status(200).json({\n        success: true,\n        message: \"Getting machines and employees.\",\n        employees,\n        machines,\n    });\n});\n//get employees and machines for auto select\nexports.getProductionSlipData = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        const { productionSlipNumber } = req.params;\n        const productionSlip = await productionSlipModel_1.default.findOne({\n            productionSlipNumber,\n        });\n        if (!productionSlip) {\n            return resp.status(404).json({\n                success: false,\n                message: `Production slip with this number ${productionSlip}.`,\n            });\n        }\n        const process = productionSlip.process.processId;\n        const processDetail = await globalProcessModel_1.default.findById(process);\n        const shop1 = await shopModel_1.default.findById(processDetail?.shop.shopId);\n        let shop;\n        if (req.employee) {\n            const jobProfile = await jobProfileModel_1.default.findById(req.employee.jobProfileId);\n            if (!jobProfile || jobProfile.isSupervisor === false) {\n                return resp.status(403).json({\n                    success: false,\n                    message: \"Not Authorized\",\n                });\n            }\n            shop = await shopModel_1.default.findOne({\n                \"jobProfile.jobProfileId\": jobProfile._id,\n            });\n            if (!shop) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Supervisior with jobProfile ${jobProfile.jobProfileName} not found.`,\n                });\n            }\n            //  console.log(shop?.shopName,processDetail?.shop.shopName);\n            if (shop?.shopName !== shop1?.shopName) {\n                return resp.status(403).json({\n                    success: false,\n                    message: `This is ${processDetail?.shop.shopName} shop slip.`,\n                });\n            }\n        }\n        const workOrder = await workOrderModel_1.default.findById({\n            _id: productionSlip.workOrderId,\n        });\n        resp.status(200).json({\n            success: true,\n            message: \"Getting machines and employees.\",\n            productionSlip,\n            workOrder,\n        });\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: \"Not auth\",\n        });\n    }\n});\n// export const editLogProductionSlip = catchErrorAsync(\n//   async (req: Request, resp: Response, next: NextFunction) => {\n//     const { productionSlipNumber } = req.params;\n//     const { itemProduced, endTime } = req.body;\n//     const productionSlip = await ProductionSlipModel.findOne({\n//       productionSlipNumber,\n//     });\n//     if (!productionSlip) {\n//       return resp.status(404).json({\n//         success: false,\n//         message: `Production slip with this number ${productionSlip}.`,\n//       });\n//     }\n//     productionSlip.itemProduced = itemProduced;\n//     await productionSlip.save();\n//     resp.status(200).json({\n//       success: true,\n//       message: \"Getting machines and employees.\",\n//       productionSlip,\n//     });\n//   }\n// );\n// get All Active Production\nexports.gettingAllActiveProductionSlip = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { workOrderId, status, date } = req.query; // date filter single date   // finished item name\n    if (req.employee || req.admin) {\n        const query = {};\n        if (date) {\n            const newDate = new Date(date);\n            newDate.setHours(0, 0, 0, 0);\n            const nextDate = new Date(newDate);\n            nextDate.setDate(newDate.getDate() + 1);\n            nextDate.setHours(0, 0, 0, 0);\n            query.createdAt = {\n                $gte: newDate,\n                $lt: nextDate,\n            };\n        }\n        const workOrders = await workOrderModel_1.default.find().lean();\n        const workOrderStore = {};\n        workOrders.forEach((w) => {\n            const id = w._id + \"\";\n            workOrderStore[id] = {\n                finishedItemName: w.finishItemName,\n            };\n        });\n        let jobProfile;\n        if (req.employee) {\n            jobProfile = await jobProfileModel_1.default.findById(req.employee.jobProfileId);\n            if (!jobProfile || jobProfile.isSupervisor === false) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `${req.employee}'s jobprofile not found.`,\n                });\n            }\n        }\n        if (req.employee && jobProfile?.jobProfileName.toLowerCase() !== \"hr\") {\n            const shop = await shopModel_1.default.findOne({\n                \"jobProfile.jobProfileId\": jobProfile?._id,\n            });\n            if (!shop) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Shop not found for jobProfile ${jobProfile?.jobProfileName}.`,\n                });\n            }\n            let data;\n            if (workOrderId) {\n                const workOrder = await workOrderModel_1.default.findOne({ _id: workOrderId });\n                if (!workOrder) {\n                    return resp.status(404).json({\n                        success: false,\n                        message: `Work order with id ${workOrderId} not found.`,\n                    });\n                }\n                data = await productionSlipModel_1.default.find({\n                    workOrderId: workOrder._id,\n                    status: status,\n                    \"shop.shopId\": shop._id,\n                    ...query,\n                }).lean();\n            }\n            else {\n                if (status == \"active\") {\n                    data = await productionSlipModel_1.default.find({\n                        status: \"active\" || 0,\n                        \"shop.shopId\": shop._id,\n                        ...query,\n                    }).lean();\n                }\n                else if (status == \"completed\") {\n                    data = await productionSlipModel_1.default.find({\n                        status: \"completed\",\n                        \"shop.shopId\": shop._id,\n                        ...query,\n                    }).lean();\n                }\n                else {\n                    data = await productionSlipModel_1.default.find({\n                        \"shop.shopId\": shop._id,\n                        ...query,\n                    }).lean();\n                }\n            }\n            data.forEach((d) => {\n                const workOrderId = d.workOrderId + \"\";\n                const finishedItemName = workOrderStore[workOrderId]?.finishedItemName;\n                d.finishedItemName = finishedItemName;\n            });\n            resp.status(200).json({\n                success: true,\n                message: `Getting all ${status} production slips.`,\n                data,\n            });\n        }\n        else {\n            let data;\n            if (workOrderId) {\n                const workOrder = await workOrderModel_1.default.findOne({ _id: workOrderId });\n                if (!workOrder) {\n                    return resp.status(404).json({\n                        success: false,\n                        message: `Work order with id ${workOrderId} not found.`,\n                    });\n                }\n                data = await productionSlipModel_1.default.find({\n                    workOrderId: workOrder._id,\n                    status: status,\n                    ...query,\n                }).lean();\n            }\n            else {\n                if (status == \"active\") {\n                    data = await productionSlipModel_1.default.find({\n                        status: \"active\" || 0,\n                        ...query,\n                    }).lean();\n                }\n                else if (status == \"completed\") {\n                    data = await productionSlipModel_1.default.find({\n                        status: \"completed\",\n                        ...query,\n                    }).lean();\n                }\n                else {\n                    data = await productionSlipModel_1.default.find({ ...query }).lean();\n                }\n            }\n            data.forEach((d) => {\n                const workOrderId = d.workOrderId + \"\";\n                const finishedItemName = workOrderStore[workOrderId]?.finishedItemName;\n                d.finishedItemName = finishedItemName;\n            });\n            resp.status(200).json({\n                success: true,\n                message: `Getting all ${status} production slips.`,\n                data,\n            });\n        }\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: `Not authorized.`,\n        });\n    }\n});\n// get All Active Production in all WorkOrder\nexports.gettingAllActiveProductionSlipAllWorkOrder = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { status, shops, sort, name, date, nextDate, processes, MCodes, page = 1, limit = 500 } = req.body;\n    const Page = parseInt(page + \"\");\n    const Limit = parseInt(limit + \"\");\n    const allJobProfile = await jobProfileModel_1.default.find().lean();\n    const jobProfileStore = {};\n    allJobProfile.forEach((a) => {\n        const id = a._id + \"\";\n        jobProfileStore[id] = {\n            ...a,\n        };\n    });\n    const allEmployee = await employeeModel_1.default.find().lean();\n    const employeeStore = {};\n    allEmployee.forEach((a) => {\n        const id = a._id + \"\";\n        employeeStore[id] = {\n            ...a,\n        };\n    });\n    const allEmployeeDocs = await employeeDocsModel_1.default.find().lean();\n    const employeeDocStore = {};\n    allEmployeeDocs.forEach((a) => {\n        const id = a.employeeId + \"\";\n        employeeDocStore[id] = {\n            ...a,\n        };\n    });\n    const query = {};\n    // search by productionSlipNumber , partName, processName ,workOrder,, sort by date, filter by shop\n    let shopIds = [];\n    if (shops) {\n        const shopDetails = await shopModel_1.default.find({ shopName: { $in: shops } });\n        shopIds = shopDetails.map((a) => a._id);\n    }\n    const allWorkOrders = await workOrderModel_1.default.find().lean();\n    const workOrderStore = {};\n    allWorkOrders.forEach((w) => {\n        const id = w._id + \"\";\n        workOrderStore[id] = {\n            orderNumber: w.orderNumber,\n            parCode: w.partCode,\n            MCode: w.MCode,\n            finishItemName: w.finishItemName,\n            customer: w.customerName,\n        };\n    });\n    let processIds = [];\n    if (processes) {\n        const process = await globalProcessModel_1.default.find({\n            processName: { $in: processes },\n        });\n        processIds = process.map((p) => p._id);\n    }\n    if (processIds.length > 0) {\n        query[\"process.processId\"] = { $in: processIds };\n    }\n    ;\n    if (MCodes) {\n        const allWorkOrders = await workOrderModel_1.default.find({\n            MCode: { $in: MCodes },\n        });\n        const orderIds = allWorkOrders.map((a) => a._id);\n        if (orderIds.length > 0) {\n            query.workOrderId = { $in: orderIds };\n        }\n    }\n    if (name) {\n        const workOrder = await workOrderModel_1.default\n            .find({\n            $or: [\n                { orderNumber: { $regex: name, $options: \"i\" } },\n                { finishItemName: { $regex: name, $options: \"i\" } },\n                { partCode: { $regex: name, $options: \"i\" } },\n                { MCode: { $regex: name, $options: \"i\" } },\n            ],\n        })\n            .lean();\n        const workOrderIds = workOrder.map((a) => a._id);\n        query.$or = [\n            { \"part.partName\": { $regex: name, $options: \"i\" } },\n            { productionSlipNumber: { $regex: name, $options: \"i\" } },\n            { workOrderId: { $in: workOrderIds } },\n        ];\n    }\n    if (status?.length > 0) {\n        query.status = { $in: status };\n    }\n    if (shopIds.length > 0) {\n        query[\"shop.shopId\"] = { $in: shopIds };\n    }\n    if (date || nextDate) {\n        const newDate = new Date(date);\n        newDate.setHours(0, 0, 0, 0);\n        let nextDate1;\n        if (nextDate) {\n            nextDate1 = new Date(nextDate);\n            nextDate1.setHours(0, 0, 0, 0);\n            nextDate1.setDate(nextDate1.getDate() + 1);\n        }\n        else {\n            nextDate1 = new Date(newDate);\n            nextDate1.setDate(nextDate1.getDate() + 1);\n        }\n        // console.log(newDate,nextDate1)\n        query.createdAt = {\n            $gte: newDate,\n            $lt: nextDate1,\n        };\n    }\n    let data;\n    let count;\n    if (sort) {\n        if (sort === \"newActive\") {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ durationFrom: -1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n        else if (sort === \"oldActive\") {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ durationFrom: 1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n        else if (sort === \"newCompleted\") {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ durationTo: -1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n        else if (sort === \"oldCompleted\") {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ durationTo: 1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n        else if (sort === \"newCreated\") {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ createdAt: -1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n        else if (sort === \"oldCreated\") {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ createdAt: 1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n        else {\n            count = await productionSlipModel_1.default.countDocuments({ ...query });\n            data = await productionSlipModel_1.default.find({\n                ...query,\n            }).select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1, printCount: 1 })\n                .sort({ createdAt: -1 })\n                .skip((Page - 1) * Limit)\n                .limit(Limit)\n                .lean();\n        }\n    }\n    else {\n        count = await productionSlipModel_1.default.countDocuments({ ...query });\n        data = await productionSlipModel_1.default.find({\n            ...query,\n        })\n            .select({ productionSlipNumber: 1, workOrderId: 1, working: 1, durationFrom: 1, durationTo: 1, createdAt: 1, status: 1, part: 1, process: 1, itemProduced: 1, numberOfItems: 1 })\n            .sort({ createdAt: -1 })\n            .skip((Page - 1) * Limit)\n            .limit(Limit)\n            .lean();\n    }\n    const result = [];\n    data.forEach((d) => {\n        const id = d.workOrderId + \"\";\n        const w = workOrderStore[id];\n        const obj = {\n            ...d,\n            orderNumber: w.orderNumber,\n            parCode: w.partCode,\n            MCode: w.MCode,\n            finishItemName: w.finishItemName,\n            customer: w.customerName,\n        };\n        result.push(obj);\n    });\n    result.forEach((r) => {\n        r.processName = r.process.processName;\n        r.partName = r.part.partName;\n        r.working.forEach((w) => {\n            w.employees.forEach((e) => {\n                const id = e.employeeId + \"\";\n                const employeeDetails = employeeStore[id];\n                const docs = employeeDocStore[id];\n                const jobProfile = jobProfileStore[employeeDetails?.jobProfileId + \"\"];\n                if (docs) {\n                    e.profilePicture = docs?.profilePicture;\n                }\n                ;\n                e.employeeCode = employeeDetails.employeeCode;\n                e.jobProfile = jobProfile.jobProfileName;\n            });\n        });\n    });\n    resp.status(200).json({\n        success: true,\n        message: `Getting all ${status} production slips.`,\n        data: result,\n        count\n    });\n});\nconst productionSlipExcel = async (req, resp, next) => {\n    const allProductionSlips = await productionSlipModel_1.default.find({ status: { $nin: \"cancel\" }, itemProduced: { $gt: 0 } }).lean();\n    const result = [];\n    for (let p of allProductionSlips) {\n        const partId = p.part._id;\n        const currentProduction = p.itemProduced;\n        const itemPerWorkOrder = p.itemPerWorkOrder;\n        const date = new Date(p.updatedAt);\n        const productionSlips = await productionSlipModel_1.default.find({ \"part._id\": partId, updatedAt: { $lte: date }, status: { $nin: \"cancel\" }, itemProduced: { $gt: 0 } }).lean();\n        let TotalProduction = 0;\n        for (let s of productionSlips) {\n            TotalProduction += s.itemProduced;\n        }\n        ;\n        const consumedItemForSingle = {};\n        for (let c of p.consumedItem) {\n            const id = c._id + \"\";\n            consumedItemForSingle[id] = {\n                forSingleQuantity: c.numberOfItem / itemPerWorkOrder\n            };\n        }\n        ;\n        let previousProduction = TotalProduction - currentProduction;\n        const childParts = [];\n        for (let c of p.consumedItem) {\n            const productionSlips = await productionSlipModel_1.default.find({ \"part._id\": c._id, updatedAt: { $lte: date }, status: { $nin: \"cancel\" }, itemProduced: { $gt: 0 } }).lean();\n            let totalProduction = 0;\n            for (let s of productionSlips) {\n                totalProduction += s.itemProduced;\n            }\n            ;\n            const singleRequired = consumedItemForSingle[c._id + \"\"].forSingleQuantity;\n            const currentlyLeft = (totalProduction / singleRequired) - previousProduction;\n            const obj = {\n                currentlyLeft: currentlyLeft * singleRequired,\n                inventory: currentlyLeft - TotalProduction,\n                totalProduction,\n                previousProduction: previousProduction * singleRequired,\n                singleRequired,\n                childPartName: c.partName,\n            };\n            childParts.push(obj);\n        }\n        ;\n        const obj = {\n            productionSlipNumber: p.productionSlipNumber,\n            workOrderId: p.workOrderId,\n            printCount: p.printCount,\n            partName: p.part.partName,\n            shopName: p.shop.shopName,\n            processName: p.process.processName,\n            numberOfItems: p.numberOfItems,\n            itemPerWorkOrder: p.itemPerWorkOrder,\n            itemProduced: p.itemProduced,\n            status: p.status,\n            consumedItem: p.consumedItem,\n            createdBy: p?.createdBy?.name,\n            activatedBy: p?.activatedBy?.name,\n            completedBy: p?.completedBy?.name,\n            createdAt: p.createdAt,\n            updatedAt: p.updatedAt,\n            durationFrom: p?.durationFrom,\n            durationTo: p?.durationTo,\n            childParts,\n        };\n        result.push(obj);\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"Getting slips for excel successfully.\",\n        result\n    });\n};\nexports.productionSlipExcel = productionSlipExcel;\nconst productionSlipExcel2 = async (req, resp, next) => {\n    const workOrders = await workOrderModel_1.default.find().lean();\n    const workOrderStore = {};\n    workOrders.forEach((w) => {\n        const id = w._id + \"\";\n        workOrderStore[id] = {\n            orderNumber: w.orderNumber,\n            finishedItemName: w.finishItemName,\n            MCode: w.MCode\n        };\n    });\n    const allProductionSlips = await productionSlipModel_1.default.find({ status: { $nin: \"cancel\" } }).lean();\n    const allProductionStore = {};\n    allProductionSlips.forEach((a) => {\n        const partId = a.part._id + \"\";\n        if (!allProductionStore[partId]) {\n            allProductionStore[partId] = {\n                productionSlips: []\n            };\n        }\n        ;\n        allProductionStore[partId].productionSlips.push({ ...a });\n    });\n    const result = [];\n    for (let p of allProductionSlips) {\n        const partId = p.part._id;\n        const workOrder = workOrderStore[p.workOrderId + \"\"];\n        const currentProduction = p.itemProduced;\n        const itemPerWorkOrder = p.itemPerWorkOrder;\n        const date = new Date(p.durationTo || p.updatedAt);\n        date.setTime(date.getTime() + (2 * 60 * 1000));\n        const newProductionSlips = [];\n        const slips = allProductionStore[partId + \"\"].productionSlips || [];\n        let TotalProduction = 0;\n        for (let s of slips) {\n            if (new Date(s.durationTo || s.updatedAt).getTime() <= date.getTime()) {\n                TotalProduction += s.itemProduced;\n                newProductionSlips.push({ ...s });\n            }\n            ;\n        }\n        ;\n        const consumedItemForSingle = {};\n        for (let c of p.consumedItem) {\n            const id = c._id + \"\";\n            consumedItemForSingle[id] = {\n                forSingleQuantity: c.numberOfItem / itemPerWorkOrder\n            };\n        }\n        ;\n        let previousProduction = TotalProduction - currentProduction;\n        const childParts = [];\n        for (let c of p.consumedItem) {\n            const newProductionSlips = [];\n            const slips = allProductionStore[c._id + \"\"]?.productionSlips || [];\n            let totalProduction = 0;\n            for (let s of slips) {\n                if (new Date(s.durationTo || s.updatedAt).getTime() <= date.getTime()) {\n                    totalProduction += s.itemProduced;\n                    newProductionSlips.push({ ...s });\n                }\n                ;\n            }\n            ;\n            const singleRequired = consumedItemForSingle[c._id + \"\"].forSingleQuantity;\n            const currentlyLeft = (totalProduction / singleRequired) - previousProduction;\n            const obj = {\n                currentlyLeft: currentlyLeft * singleRequired,\n                inventory: (currentlyLeft * singleRequired) - (currentProduction * singleRequired),\n                totalProduction,\n                previousProduction: previousProduction * singleRequired,\n                singleRequired,\n                childPartName: c.partName,\n            };\n            childParts.push(obj);\n        }\n        ;\n        const obj = {\n            workOrderNumber: workOrder.orderNumber,\n            MCode: workOrder.MCode,\n            FinishedItemName: workOrder.finishedItemName,\n            productionSlipNumber: p.productionSlipNumber,\n            workOrderId: p.workOrderId,\n            printCount: p.printCount,\n            partName: p.part.partName,\n            shopName: p.shop.shopName,\n            processName: p.process.processName,\n            numberOfItems: p.numberOfItems,\n            itemPerWorkOrder: p.itemPerWorkOrder,\n            itemProduced: p.itemProduced,\n            status: p.status,\n            consumedItem: p.consumedItem,\n            createdBy: p?.createdBy?.name,\n            activatedBy: p?.activatedBy?.name,\n            completedBy: p?.completedBy?.name,\n            createdAt: p.createdAt,\n            updatedAt: p.updatedAt,\n            durationFrom: p?.durationFrom,\n            durationTo: p?.durationTo,\n            childParts,\n        };\n        result.push(obj);\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"getting excel data for productionSlips\",\n        result\n    });\n};\nexports.productionSlipExcel2 = productionSlipExcel2;\n// excelReport as per workOrder in productionSLip\nconst productionSlipExcelPerWorkOrder = async (req, resp, next) => {\n    const workOrders = await workOrderModel_1.default.find().lean();\n    const workOrderStore = {};\n    workOrders.forEach((w) => {\n        const id = w._id + \"\";\n        workOrderStore[id] = {\n            orderNumber: w.orderNumber,\n            finishedItemName: w.finishItemName,\n            MCode: w.MCode\n        };\n    });\n    const allProductionSlips = await productionSlipModel_1.default.find({ status: { $nin: \"cancel\" }, itemProduced: { $gt: 0 } }).lean();\n    const allProductionStore = {};\n    allProductionSlips.forEach((a) => {\n        const partId = a.part._id + \"\";\n        if (!allProductionStore[partId]) {\n            allProductionStore[partId] = {\n                productionSlips: []\n            };\n        }\n        ;\n        allProductionStore[partId].productionSlips.push({ ...a });\n    });\n    const result = [];\n    for (let p of allProductionSlips) {\n        const partId = p.part._id;\n        const workOrder = workOrderStore[p.workOrderId + \"\"];\n        const currentProduction = p.itemProduced;\n        const itemPerWorkOrder = p.itemPerWorkOrder;\n        const date = new Date(p.durationTo || p.updatedAt);\n        date.setTime(date.getTime() + (2 * 60 * 1000));\n        const newProductionSlips = [];\n        const slips = allProductionStore[partId + \"\"].productionSlips || [];\n        let TotalProduction = 0;\n        for (let s of slips) {\n            if ((new Date(s.durationTo || s.updatedAt).getTime() <= date.getTime()) && (p.workOrderId + \"\" === s.workOrderId + \"\")) {\n                TotalProduction += s.itemProduced;\n                newProductionSlips.push({ ...s });\n            }\n            ;\n        }\n        ;\n        const consumedItemForSingle = {};\n        for (let c of p.consumedItem) {\n            const id = c._id + \"\";\n            consumedItemForSingle[id] = {\n                forSingleQuantity: c.numberOfItem / itemPerWorkOrder\n            };\n        }\n        ;\n        let previousProduction = TotalProduction - currentProduction;\n        const childParts = [];\n        for (let c of p.consumedItem) {\n            const newProductionSlips = [];\n            const slips = allProductionStore[c._id + \"\"]?.productionSlips || [];\n            let totalProduction = 0;\n            for (let s of slips) {\n                if ((new Date(s.durationTo || s.updatedAt).getTime() <= date.getTime()) && (p.workOrderId + \"\" === s.workOrderId + \"\")) {\n                    totalProduction += s.itemProduced;\n                    newProductionSlips.push({ ...s });\n                }\n                ;\n            }\n            ;\n            const singleRequired = consumedItemForSingle[c._id + \"\"].forSingleQuantity; // 1\n            const currentlyLeft = (totalProduction / singleRequired) - previousProduction; // \n            const obj = {\n                currentlyLeft: currentlyLeft * singleRequired,\n                inventory: (currentlyLeft * singleRequired) - (currentProduction * singleRequired),\n                totalProduction,\n                previousProduction: previousProduction * singleRequired,\n                singleRequired,\n                childPartName: c.partName,\n            };\n            childParts.push(obj);\n        }\n        ;\n        const obj = {\n            workOrderNumber: workOrder.orderNumber,\n            MCode: workOrder.MCode,\n            FinishedItemName: workOrder.finishedItemName,\n            productionSlipNumber: p.productionSlipNumber,\n            workOrderId: p.workOrderId,\n            printCount: p.printCount,\n            partName: p.part.partName,\n            shopName: p.shop.shopName,\n            processName: p.process.processName,\n            numberOfItems: p.numberOfItems,\n            itemPerWorkOrder: p.itemPerWorkOrder,\n            itemProduced: p.itemProduced,\n            status: p.status,\n            consumedItem: p.consumedItem,\n            createdBy: p?.createdBy?.name,\n            activatedBy: p?.activatedBy?.name,\n            completedBy: p?.completedBy?.name,\n            createdAt: p.createdAt,\n            updatedAt: p.updatedAt,\n            durationFrom: p?.durationFrom,\n            durationTo: p?.durationTo,\n            childParts,\n        };\n        result.push(obj);\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"getting excel data for productionSlips\",\n        result\n    });\n};\nexports.productionSlipExcelPerWorkOrder = productionSlipExcelPerWorkOrder;\n// get active machines and ideal machines And Active Employees\nexports.activeIdleMachines = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    if (req.employee || req.admin) {\n        const { processes, shop, name } = req.body;\n        const query = {};\n        if (processes && processes.length > 0) {\n            const Process = await globalProcessModel_1.default.find({\n                processName: { $in: processes },\n            });\n            if (!query.process) {\n                query.process = { $in: [] };\n            }\n            Process.forEach((p) => {\n                query.process[\"$in\"].push(p._id);\n            });\n        }\n        if (name) {\n            const process = await globalProcessModel_1.default\n                .find({\n                $or: [\n                    { processName: { $regex: name, $options: \"i\" } },\n                    { processCode: { $regex: name, $options: \"i\" } },\n                ],\n            })\n                .lean();\n            const processIds = process.map((p) => p._id);\n            query.$or = [\n                { machineName: { $regex: name, $options: \"i\" } },\n                { code: { $regex: name, $options: \"i\" } },\n                { process: { $in: processIds } },\n            ];\n        }\n        if (shop) {\n            if (!query.process) {\n                query.process = { $in: [] };\n            }\n            const shopDetails = await shopModel_1.default.findOne({ shopName: shop });\n            if (shopDetails) {\n                const processes = await globalProcessModel_1.default\n                    .find({ \"shop.shopId\": shopDetails._id })\n                    .lean();\n                processes.forEach((p) => {\n                    query.process.$in.push(p._id);\n                });\n            }\n        }\n        if (req.employee) {\n            jobProfile = await jobProfileModel_1.default.findById({\n                _id: req.employee?.jobProfileId,\n            });\n        }\n        if (jobProfile?.isSupervisor) {\n            const shop = await shopModel_1.default.findOne({\n                \"jobProfile.jobProfileId\": jobProfile?._id,\n            });\n            const processes = await globalProcessModel_1.default\n                .find({ \"shop.shopId\": shop?._id })\n                .lean();\n            const processIds = processes.map((p) => p._id);\n            const machinesWithProcess = await machineModel_1.default\n                .find({ ...query })\n                .lean();\n            const machinesWithProcessArray = [];\n            processIds.forEach((p) => {\n                const id = p + \"\";\n                machinesWithProcess.forEach((m) => {\n                    let productionSlipId = \"\";\n                    if (m.logs) {\n                        productionSlipId =\n                            m.logs[m.logs.length - 1]?.productionSlipId + \"\" || \"\";\n                    }\n                    const obj = {\n                        id,\n                        _id: m._id,\n                        machineName: m.machineName,\n                        code: m.code,\n                        picture: m.picture || \"\",\n                        active: false,\n                        productionSlipId: productionSlipId,\n                    };\n                    m.process.forEach((n) => {\n                        if (n + \"\" == id) {\n                            machinesWithProcessArray.push(obj);\n                        }\n                    });\n                });\n            });\n            const machinesStore = {};\n            machinesWithProcessArray.forEach((m) => {\n                const id = m.id;\n                machinesStore[id] = {\n                    ...m,\n                };\n            });\n            const newProductionSlips = await productionSlipModel_1.default.find({}).lean();\n            const productionSlipStore = {};\n            newProductionSlips.forEach((p) => {\n                const id = p._id + \"\";\n                productionSlipStore[id] = {\n                    ...p,\n                };\n            });\n            newProductionSlips.forEach((p) => {\n                if (p.status === \"active\") {\n                    if (p.working[p.working.length - 1]) {\n                        p.working[p.working.length - 1].machines.forEach((p) => {\n                            const id = p.machineId + \"\";\n                            if (machinesStore[id]) {\n                                machinesStore[id].active = true;\n                            }\n                        });\n                    }\n                }\n            });\n            const machineArray = [];\n            for (const key in machinesStore) {\n                if (machinesStore.hasOwnProperty(key)) {\n                    machineArray.push(machinesStore[key]);\n                }\n            }\n            machineArray.forEach((m) => {\n                const productionSlipId = m.productionSlipId + \"\";\n                let productionSlip = {};\n                if (productionSlipStore[productionSlipId]) {\n                    productionSlip = productionSlipStore[productionSlipId];\n                }\n                m.productionSlip = productionSlip;\n            });\n            resp.status(200).json({\n                success: true,\n                message: \"Getting all active and inactive machines .\",\n                machineArray,\n            });\n        }\n        else if (jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n            req.admin) {\n            // const allProductionSlip = await ProductionSlipModel.find({status:\"completed\"}).sort({createdAt:-1}).lean();\n            // console.log(allProductionSlip)\n            const allMachines = await machineModel_1.default.find({ ...query }).lean();\n            const machineStore = {};\n            allMachines.forEach((m) => {\n                const id = m._id + \"\";\n                let productionSlipId = \"\";\n                if (m.logs) {\n                    productionSlipId =\n                        m.logs[m.logs.length - 1]?.productionSlipId + \"\" || \"\";\n                }\n                // console.log({...m})\n                machineStore[id] = {\n                    id,\n                    _id: m._id,\n                    machineName: m.machineName,\n                    code: m.code,\n                    picture: m.picture || \"\",\n                    active: false,\n                    productionSlipId: productionSlipId,\n                };\n            });\n            const productionSlips = await productionSlipModel_1.default.find({}).lean();\n            const productionSlipStore = {};\n            productionSlips.forEach((p) => {\n                const id = p._id + \"\";\n                productionSlipStore[id] = { ...p };\n            });\n            productionSlips.forEach((p) => {\n                if (p.status === \"active\") {\n                    if (p.working[p.working.length - 1]) {\n                        p.working[p.working.length - 1].machines.forEach((p) => {\n                            const id = p.machineId + \"\";\n                            if (machineStore[id]) {\n                                machineStore[id].active = true;\n                            }\n                        });\n                    }\n                }\n            });\n            const machineArray = [];\n            for (const key in machineStore) {\n                if (machineStore.hasOwnProperty(key)) {\n                    machineArray.push(machineStore[key]);\n                }\n            }\n            machineArray.forEach((m) => {\n                const productionSlipId = m.productionSlipId + \"\";\n                let productionSlip = {};\n                if (productionSlipStore[productionSlipId]) {\n                    productionSlip = productionSlipStore[productionSlipId];\n                }\n                m.productionSlip = productionSlip;\n            });\n            resp.status(200).json({\n                success: true,\n                message: \"Getting all active and inactive machines .\",\n                machineArray,\n            });\n        }\n        else {\n            return resp.status(403).json({\n                success: false,\n                message: \"Not Authorized.\",\n            });\n        }\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"Login first\",\n        });\n    }\n});\n// getting active and idle employees\nexports.activeIdleEmployees = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    let date = new Date();\n    date.setHours(0, 0, 0, 0);\n    date.setHours(date.getHours() - (6 + 5.5));\n    let nextDay = new Date(date);\n    nextDay.setDate(nextDay.getDate() + 3);\n    nextDay.setHours(0, 0, 0, 0);\n    nextDay.setHours(nextDay.getHours() - (6 + 5.5));\n    date = date;\n    nextDay = nextDay;\n    // checking the jobProfile Name\n    if (req.employee || req.admin) {\n        if (req.employee) {\n            jobProfile = await jobProfileModel_1.default.findById({\n                _id: req.employee.jobProfileId,\n            });\n        }\n        if (jobProfile?.isSupervisor) {\n            const shop = await shopModel_1.default.findOne({\n                \"jobProfile.jobProfileId\": jobProfile?._id,\n            });\n            if (!shop) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Shop not found for jobProfile ${jobProfile.jobProfileName}`,\n                });\n            }\n            const shopLog = await shopLogModel_1.default.findOne({\n                date: { $gte: date, $lt: nextDay },\n                shopId: shop._id,\n            }).lean();\n            const allEmployees = await employeeModel_1.default.find().lean();\n            const allEmployeePictures = await employeeDocsModel_1.default.find().lean();\n            const allJobProfile = await jobProfileModel_1.default.find().lean();\n            const allEmployeeStore = {};\n            const allEmployeePicturesStore = {};\n            const allJobProfileStore = {};\n            allEmployees.forEach((a) => {\n                const id = a._id + \"\";\n                allEmployeeStore[id] = {\n                    ...a,\n                };\n            });\n            allJobProfile.forEach((a) => {\n                const id = a._id + \"\";\n                allJobProfileStore[id] = {\n                    ...a,\n                };\n            });\n            allEmployeePictures.forEach((a) => {\n                const id = a.employeeId + \"\";\n                allEmployeePicturesStore[id] = {\n                    profilePicture: a.profilePicture ? a.profilePicture : \"\",\n                };\n            });\n            const employeeStore = {};\n            shopLog?.employees.forEach((s) => {\n                const id = s.employeeId + \"\";\n                const lastProductionSlipId = allEmployeeStore[id].productionLogs[allEmployeeStore[id].productionLogs.length - 1]?.productionSlipId;\n                employeeStore[id] = {\n                    ...s,\n                    active: false,\n                    employeeCode: allEmployeeStore[id].employeeCode\n                        ? allEmployeeStore[id].employeeCode\n                        : \"\",\n                    jobProfile: allJobProfileStore[allEmployeeStore[id].jobProfileId + \"\"]\n                        .jobProfileName,\n                    profilePicture: allEmployeePicturesStore[id]?.profilePicture\n                        ? allEmployeePicturesStore[id].profilePicture\n                        : \"\",\n                    productionSlipId: lastProductionSlipId ? lastProductionSlipId : \"\",\n                };\n            });\n            const productionSlips = await productionSlipModel_1.default.find({}).lean();\n            const productionSlipStore = {};\n            productionSlips.forEach((p) => {\n                const id = p._id + \"\";\n                productionSlipStore[id] = { ...p };\n            });\n            productionSlips.forEach((p) => {\n                if (p.status === \"active\") {\n                    if (p.working) {\n                        p.working[p.working.length - 1].employees.forEach((w) => {\n                            const id = w.employeeId + \"\";\n                            if (employeeStore[id]) {\n                                employeeStore[id].active = true;\n                            }\n                        });\n                    }\n                }\n            });\n            const employeeArray = [];\n            for (const key in employeeStore) {\n                if (employeeStore.hasOwnProperty(key)) {\n                    employeeArray.push(employeeStore[key]);\n                }\n            }\n            employeeArray.forEach((e) => {\n                const productionId = e.productionSlipId;\n                if (productionId) {\n                    const productionSlip = productionSlipStore[productionId];\n                    e.productionSlip = productionSlip || {};\n                }\n            });\n            resp.status(200).json({\n                success: true,\n                message: `Getting all employee data under shop ${shop.shopName}`,\n                employeeArray,\n            });\n        }\n        else if (jobProfile?.jobProfileName === \"HR\" ||\n            jobProfile?.jobProfileName === \"hr\" ||\n            req.admin) {\n            const shopLogs = await shopLogModel_1.default.find({\n                date: { $gte: date, $lt: nextDay },\n            }).lean();\n            const allEmployees = await employeeModel_1.default.find().lean();\n            const allEmployeePictures = await employeeDocsModel_1.default.find().lean();\n            const allJobProfile = await jobProfileModel_1.default.find().lean();\n            const allEmployeeStore = {};\n            const allEmployeePicturesStore = {};\n            const allJobProfileStore = {};\n            allEmployees.forEach((a) => {\n                const id = a._id + \"\";\n                allEmployeeStore[id] = {\n                    ...a,\n                };\n            });\n            allJobProfile.forEach((a) => {\n                const id = a._id + \"\";\n                allJobProfileStore[id] = {\n                    ...a,\n                };\n            });\n            allEmployeePictures.forEach((a) => {\n                const id = a.employeeId + \"\";\n                allEmployeePicturesStore[id] = {\n                    profilePicture: a.profilePicture ? a.profilePicture : \"\",\n                };\n            });\n            const employeeStore = {};\n            shopLogs.forEach((s) => {\n                s.employees.forEach((e) => {\n                    const id = e.employeeId + \"\";\n                    const lastProductionSlipId = allEmployeeStore[id].productionLogs[allEmployeeStore[id].productionLogs.length - 1]?.productionSlipId;\n                    employeeStore[id] = {\n                        ...e,\n                        active: false,\n                        employeeCode: allEmployeeStore[id].employeeCode\n                            ? allEmployeeStore[id].employeeCode\n                            : \"\",\n                        jobProfile: allJobProfileStore[allEmployeeStore[id].jobProfileId + \"\"]\n                            .jobProfileName,\n                        profilePicture: allEmployeePicturesStore[id]?.profilePicture\n                            ? allEmployeePicturesStore[id].profilePicture\n                            : \"\",\n                        productionSlipId: lastProductionSlipId\n                            ? lastProductionSlipId\n                            : \"\",\n                    };\n                });\n            });\n            const productionSlips = await productionSlipModel_1.default.find({}).lean();\n            const productionSlipStore = {};\n            productionSlips.forEach((p) => {\n                const id = p._id + \"\";\n                productionSlipStore[id] = { ...p };\n            });\n            productionSlips.forEach((p) => {\n                if (p.status === \"active\") {\n                    if (p.working) {\n                        p.working[p.working.length - 1].employees.forEach((w) => {\n                            const id = w.employeeId + \"\";\n                            if (employeeStore[id]) {\n                                employeeStore[id].active = true;\n                            }\n                        });\n                    }\n                }\n            });\n            const employeeArray = [];\n            for (const key in employeeStore) {\n                if (employeeStore.hasOwnProperty(key)) {\n                    employeeArray.push(employeeStore[key]);\n                }\n            }\n            employeeArray.forEach((e) => {\n                const productionId = e.productionSlipId;\n                if (productionId) {\n                    const productionSlip = productionSlipStore[productionId];\n                    e.productionSlip = productionSlip || {};\n                }\n            });\n            return resp.status(200).json({\n                success: true,\n                message: \"Getting all the employee data \",\n                employeeArray,\n            });\n        }\n        else {\n            return resp.status(403).json({\n                success: false,\n                message: \"Not Authorized.\",\n            });\n        }\n    }\n    else {\n        return resp.status(400).json({\n            success: false,\n            message: \"Login first\",\n        });\n    }\n});\n// get all childPart With productionslip Count\nconst getChildPartWithProductionSlipCount = async (req, resp, next) => {\n    try {\n        const { workOrderId } = req.params;\n        const { processName } = req.body;\n        const workOrder = await workOrderModel_1.default.findById(workOrderId);\n        if (!workOrder) {\n            return resp.status(404).json({\n                success: false,\n                message: `WorkOrder not found with id ${workOrderId}.`,\n            });\n        }\n        const childParentStore = {};\n        for (let w of workOrder.masterBom) {\n            const partId = w._id + \"\";\n            const numberOfItem = w.numberOfItem;\n            for (let c of w.newChild) {\n                const childQuantity = c.numberOfItem || 0;\n                const childId = c._id + \"\";\n                if (!childParentStore[childId]) {\n                    childParentStore[childId] = {\n                        parentId: partId,\n                        perOnePart: childQuantity / numberOfItem\n                    };\n                }\n                ;\n            }\n        }\n        if (req.employee || req.admin) {\n            let jobProfile;\n            let shop;\n            if (req.employee) {\n                jobProfile = await jobProfileModel_1.default.findById(req.employee.jobProfileId);\n                if (!jobProfile || !jobProfile.isSupervisor)\n                    return next(new errorHandler_1.default(`Job Profile not found or not Supervisor of employee ${req.employee.employeeCode}`, 404));\n                shop = await shopModel_1.default.findOne({\n                    \"jobProfile.jobProfileId\": jobProfile._id,\n                });\n                if (!shop)\n                    return next(new errorHandler_1.default(`Shop not found for jobProfile ${jobProfile.jobProfileName}`, 404));\n            }\n            ;\n            if (req.employee && jobProfile?.jobProfileName.toLowerCase() !== \"hr\") {\n                const allProdctionSlips = await productionSlipModel_1.default.find({\n                    workOrderId: workOrder._id,\n                    \"shop.shopId\": shop?._id,\n                }).lean();\n                // const childParentStore :any = {};\n                const processes = await globalProcessModel_1.default.find({\n                    \"shop.shopId\": shop?._id,\n                }).lean();\n                const processStore = {};\n                processes.forEach((p) => {\n                    const id = p._id + \"\";\n                    processStore[id] = { ...p };\n                });\n                const productionSlipStore = {};\n                allProdctionSlips.forEach((a) => {\n                    const id = a.part._id + \"\";\n                    // const itemPerWorkOrder = a.itemPerWorkOrder;\n                    if (productionSlipStore[id]) {\n                        productionSlipStore[id].value.push({ ...a });\n                    }\n                    else {\n                        productionSlipStore[id] = {\n                            value: [{ ...a }],\n                        };\n                    }\n                    //  a.consumedItem.forEach((c)=>{\n                    //     const childId = c._id+\"\";\n                    //     if(!childParentStore[childId]){\n                    //       childParentStore[childId] = {\n                    //         parentId : id,\n                    //         perOnePart : c.numberOfItem/itemPerWorkOrder\n                    //       }\n                    //     };\n                    //  });\n                });\n                const result = [];\n                let count = 0;\n                workOrder.masterBom.forEach((w) => {\n                    const id = w._id + \"\";\n                    count++;\n                    const productionSlips = productionSlipStore[id];\n                    const parentId = childParentStore[id]?.parentId + \"\";\n                    // console.log(id,count)\n                    const perSingleItem = childParentStore[id]?.perOnePart || 0;\n                    const parentSlips = productionSlipStore[parentId];\n                    let itemProduced = 0;\n                    let itemPerWorkOrder = 0;\n                    if (productionSlips) {\n                        itemPerWorkOrder = productionSlips.value[0].itemPerWorkOrder || 0;\n                        productionSlips.value.forEach((p) => {\n                            itemProduced += p.itemProduced;\n                        });\n                    }\n                    ;\n                    let parentProduced = 0;\n                    if (parentSlips) {\n                        parentSlips.value.forEach((p) => {\n                            parentProduced += p.itemProduced;\n                        });\n                    }\n                    ;\n                    if (processStore[w.processId + \"\"]) {\n                        if (processName) {\n                            if (processName + \"\" === processStore[w.processId + \"\"].processName + \"\") {\n                                const obj = {\n                                    itemPerWorkOrder,\n                                    partName: w.partName,\n                                    process: w.process,\n                                    numberOfProductionSlips: productionSlips?.value.length || 0,\n                                    productionSlips: productionSlips?.value,\n                                    numberOfItems: w.numberOfItem,\n                                    itemProduced,\n                                    inventory: itemProduced - (parentProduced * perSingleItem)\n                                };\n                                result.push(obj);\n                            }\n                            else {\n                                return;\n                            }\n                        }\n                        else {\n                            const obj = {\n                                itemPerWorkOrder,\n                                partName: w.partName,\n                                process: w.process,\n                                numberOfProductionSlips: productionSlips?.value.length || 0,\n                                productionSlips: productionSlips?.value,\n                                numberOfItems: w.numberOfItem,\n                                itemProduced,\n                                inventory: itemProduced - (parentProduced * perSingleItem)\n                            };\n                            result.push(obj);\n                        }\n                    }\n                });\n                resp.status(200).json({\n                    success: true,\n                    message: \"Getting all the data for workOrder.\",\n                    result,\n                });\n            }\n            else {\n                const allProdctionSlips = await productionSlipModel_1.default.find({\n                    workOrderId: workOrder._id,\n                }).lean();\n                const allProcesses = await globalProcessModel_1.default.find().lean();\n                const allProcessStore = {};\n                const productionSlipStore = {};\n                // const childParentStore :any = {};\n                allProcesses.forEach((a) => {\n                    const id = a._id + \"\";\n                    allProcessStore[id] = { ...a };\n                });\n                allProdctionSlips.forEach((a) => {\n                    const id = a.part._id + \"\";\n                    const itemPerWorkOrder = a.itemPerWorkOrder;\n                    if (productionSlipStore[id]) {\n                        productionSlipStore[id].value.push({ ...a });\n                    }\n                    else {\n                        productionSlipStore[id] = {\n                            value: [{ ...a }],\n                        };\n                    }\n                    //  a.consumedItem.forEach((c)=>{\n                    //     const childId = c._id+\"\";\n                    //     if(!childParentStore[childId]){\n                    //       childParentStore[childId] = {\n                    //         parentId : id,\n                    //         perOnePart : c.numberOfItem/itemPerWorkOrder\n                    //       }\n                    //     };\n                    //  });\n                });\n                const result = [];\n                workOrder.masterBom.forEach((w) => {\n                    const id = w._id + \"\";\n                    const productionSlips = productionSlipStore[id];\n                    const parentId = childParentStore[id]?.parentId + \"\";\n                    const perSingleItem = childParentStore[id]?.perOnePart || 0;\n                    const parentSlips = productionSlipStore[parentId];\n                    let itemProduced = 0;\n                    let itemPerWorkOrder = 0;\n                    if (productionSlips) {\n                        itemPerWorkOrder = productionSlips.value[0].itemPerWorkOrder || 0;\n                        productionSlips.value.forEach((p) => {\n                            itemProduced += p.itemProduced;\n                        });\n                    }\n                    ;\n                    let parentProduced = 0;\n                    if (parentSlips) {\n                        parentSlips.value.forEach((p) => {\n                            parentProduced += p.itemProduced;\n                        });\n                    }\n                    ;\n                    if (processName) {\n                        if (processName === allProcessStore[w.processId + \"\"].processName) {\n                            const obj = {\n                                itemPerWorkOrder,\n                                partName: w.partName,\n                                process: w.process,\n                                numberOfProductionSlips: productionSlips?.value.length || 0,\n                                productionSlips: productionSlips?.value,\n                                numberOfItems: w.numberOfItem,\n                                itemProduced,\n                                consumed: (parentProduced * perSingleItem),\n                                inventory: itemProduced - (parentProduced * perSingleItem)\n                            };\n                            result.push(obj);\n                        }\n                        else {\n                            return;\n                        }\n                    }\n                    else {\n                        const obj = {\n                            itemPerWorkOrder,\n                            partName: w.partName,\n                            process: w.process,\n                            numberOfProductionSlips: productionSlips?.value.length || 0,\n                            productionSlips: productionSlips?.value,\n                            numberOfItems: w.numberOfItem,\n                            itemProduced,\n                            consumed: (parentProduced * perSingleItem),\n                            inventory: itemProduced - (parentProduced * perSingleItem)\n                        };\n                        result.push(obj);\n                    }\n                });\n                resp.status(200).json({\n                    success: true,\n                    message: \"Getting all the data for workOrder.\",\n                    result,\n                });\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(`Login First`, 403));\n        }\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.getChildPartWithProductionSlipCount = getChildPartWithProductionSlipCount;\n// get multiple ProductionSlips\nexports.multiProductionSlip = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumbers } = req.body;\n    const productionSlips = await productionSlipModel_1.default.find({\n        productionSlipNumber: { $in: productionSlipNumbers },\n    }).sort({ 'process.processName': 1 }).lean();\n    for (let p of productionSlipNumbers) {\n        const productionSlip = await productionSlipModel_1.default.findOne({\n            productionSlipNumber: p,\n        });\n        if (productionSlip) {\n            productionSlip.printCount += 1;\n            await productionSlip.save();\n        }\n    }\n    const allProcesses = await globalProcessModel_1.default.find().lean();\n    const processStore = {};\n    allProcesses.forEach((p) => {\n        const Id = p._id + \"\";\n        processStore[Id] = {\n            ...p,\n        };\n    });\n    const workOrderIds = productionSlips.map((p) => p.workOrderId);\n    const workOrders = await workOrderModel_1.default\n        .find({ _id: { $in: workOrderIds } })\n        .lean();\n    const workOrderStore = {};\n    workOrders.forEach((w) => {\n        const id = w._id + \"\";\n        workOrderStore[id] = {\n            ...w,\n        };\n    });\n    const result = [];\n    for (let p of productionSlips) {\n        const workOrderId = p.workOrderId + \"\";\n        const workOrder = workOrderStore[workOrderId];\n        const workOrderNumber = workOrder.orderNumber;\n        const finishItemName = (await (0, translate_1.translateEnglishToHindi)(workOrder.finishItemName)) ||\n            workOrder.finishItemName;\n        const partCode = workOrder.partCode;\n        const MCode = workOrder.MCode;\n        const processName = (await (0, translate_1.translateEnglishToHindi)(processStore[p.process.processId + \"\"].processName)) || processStore[p.process.processId + \"\"].processName;\n        const processCode = processStore[p.process.processId + \"\"].processCode;\n        const productionItem = (await (0, translate_1.translateEnglishToHindi)(p.part.partName)) || p.part.partName;\n        const shopName = (await (0, translate_1.translateEnglishToHindi)(processStore[p.process.processId + \"\"].shop.shopName)) || processStore[p.process.processId + \"\"].shop.shopName;\n        for (let i of p.consumedItem) {\n            i.partName = (await (0, translate_1.translateEnglishToHindi)(i.partName)) || i.partName;\n        }\n        const obj = {\n            workOrderNumber,\n            finishItemName,\n            orderAt: workOrder.date,\n            partCode,\n            MCode,\n            orderQuantity: workOrder.orderQuantity,\n            QRCode: p.QRCode,\n            processName,\n            processCode,\n            shopName,\n            productionItem,\n            itemPerWorkOrder: p.itemPerWorkOrder,\n            productionSlipNumber: p.productionSlipNumber,\n            numberOfItems: p.numberOfItems,\n            consumptionItem: p.consumedItem,\n            createdAt: p.createdAt,\n        };\n        result.push(obj);\n    }\n    resp.json({\n        success: true,\n        message: \"Getting all productionSlip successfully.\",\n        result,\n    });\n});\n// for English\n// get multiple ProductionSlips\nexports.multiProductionSlipEnglish = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumbers } = req.body;\n    const productionSlips = await productionSlipModel_1.default.find({\n        productionSlipNumber: { $in: productionSlipNumbers },\n    }).sort({ 'process.processName': 1 }).lean();\n    for (let p of productionSlipNumbers) {\n        const productionSlip = await productionSlipModel_1.default.findOne({\n            productionSlipNumber: p,\n        });\n        if (productionSlip) {\n            productionSlip.printCount += 1;\n            await productionSlip.save();\n        }\n        ;\n    }\n    ;\n    const allProcesses = await globalProcessModel_1.default.find().lean();\n    const processStore = {};\n    allProcesses.forEach((p) => {\n        const Id = p._id + \"\";\n        processStore[Id] = {\n            ...p,\n        };\n    });\n    const workOrderIds = productionSlips.map((p) => p.workOrderId);\n    const workOrders = await workOrderModel_1.default\n        .find({ _id: { $in: workOrderIds } })\n        .lean();\n    const workOrderStore = {};\n    workOrders.forEach((w) => {\n        const id = w._id + \"\";\n        workOrderStore[id] = {\n            ...w,\n        };\n    });\n    const result = [];\n    for (let p of productionSlips) {\n        const workOrderId = p.workOrderId + \"\";\n        const workOrder = workOrderStore[workOrderId];\n        const workOrderNumber = workOrder.orderNumber;\n        const finishItemName = workOrder.finishItemName;\n        const partCode = workOrder.partCode;\n        const MCode = workOrder.MCode;\n        const processName = processStore[p.process.processId + \"\"]?.processName;\n        const processCode = processStore[p.process.processId + \"\"]?.processCode;\n        const productionItem = p.part.partName;\n        const shopName = processStore[p.process.processId + \"\"]?.shop.shopName;\n        const obj = {\n            workOrderNumber,\n            finishItemName,\n            orderAt: workOrder.date,\n            partCode,\n            MCode,\n            orderQuantity: workOrder.orderQuantity,\n            QRCode: p.QRCode,\n            processName,\n            processCode,\n            shopName,\n            productionItem,\n            itemPerWorkOrder: p.itemPerWorkOrder,\n            productionSlipNumber: p.productionSlipNumber,\n            numberOfItems: p.numberOfItems,\n            consumptionItem: p.consumedItem,\n            createdAt: p.createdAt,\n        };\n        result.push(obj);\n    }\n    ;\n    resp.json({\n        success: true,\n        message: \"Getting all productionSlip successfully.\",\n        result,\n    });\n});\n// Pdf print Count\nexports.countPdfPrint = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumbers } = req.body;\n    const result = [];\n    for (let p of productionSlipNumbers) {\n        const productionSlip = await productionSlipModel_1.default.findOne({\n            productionSlipNumber: p,\n        });\n        if (productionSlip) {\n            productionSlip.printCount += 1;\n            await productionSlip.save();\n            result.push(productionSlip.productionSlipNumber);\n        }\n        ;\n    }\n    ;\n    resp.json({\n        success: true,\n        message: `Pdf Count updated.`,\n        slipNumber: result,\n    });\n});\n// edit Production\nexports.EditProduction = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumber } = req.params;\n    const { itemProduced, index } = req.body;\n    const productionSlip = await productionSlipModel_1.default.findOne({\n        productionSlipNumber,\n    });\n    if (!productionSlip) {\n        return resp.status(404).json({\n            success: false,\n            message: `Production Slip not found with number ${productionSlip}.`,\n        });\n    }\n    ;\n    const workOrder = await workOrderModel_1.default.findById(productionSlip.workOrderId);\n    if (!workOrder) {\n        return resp.status(404).json({\n            success: false,\n            message: `Work order not found for slipNumber ${productionSlipNumber}.`\n        });\n    }\n    ;\n    const lastPartId = workOrder.masterBom[workOrder.masterBom.length - 1]._id;\n    const finishedItem = await finishedItemModel_1.default.findOne({ MCode: workOrder.MCode });\n    if (!finishedItem) {\n        return resp.status(404).json({\n            success: false,\n            message: `Finish Item not found with name ${workOrder.finishItemName}.`\n        });\n    }\n    ;\n    let count = 0;\n    let oldProduction = 0;\n    const completeOldProduction = productionSlip.itemProduced;\n    productionSlip.working.forEach((p) => {\n        if (count === index) {\n            oldProduction = p.itemProduced || 0;\n            p.itemProduced = itemProduced;\n        }\n        ;\n        count++;\n    });\n    productionSlip.itemProduced = productionSlip.itemProduced - oldProduction + itemProduced;\n    await productionSlip.save();\n    const completeNewproduction = productionSlip.itemProduced;\n    const endDate = new Date(productionSlip.durationTo);\n    endDate.setHours(0, 0, 0, 0);\n    const month = new Date(productionSlip.durationTo);\n    month.setUTCDate(1);\n    month.setUTCHours(0, 0, 0, 0);\n    let planning;\n    if (productionSlip.part._id + \"\" === lastPartId + \"\") {\n        planning = await planningModel_1.default.findOne({\n            finishedItemId: finishedItem._id,\n            month: month,\n        });\n        planning?.dates.forEach((p) => {\n            const date = new Date(p.date);\n            date.setHours(0, 0, 0, 0);\n            if (date + \"\" === endDate + \"\") {\n                if (!p.dispatchValue) {\n                    p.dispatchValue = 0;\n                }\n                ;\n                p.dispatchValue = p.dispatchValue - completeOldProduction + completeNewproduction;\n            }\n            ;\n        });\n        await planning?.save();\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"Production Slip updated successfully.\",\n        productionSlip,\n    });\n});\n// update status of production slip\nexports.updateProductionSlipStatus = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { productionSlipNumber } = req.params;\n    const { status } = req.body;\n    const productionSlip = await productionSlipModel_1.default.findOne({\n        productionSlipNumber,\n    });\n    if (!productionSlip) {\n        return resp.status(404).json({\n            success: false,\n            message: `Production Slip with number ${productionSlipNumber} not found.`,\n        });\n    }\n    ;\n    productionSlip.status = status;\n    await productionSlip.save();\n    resp.status(200).json({\n        success: true,\n        message: `Status updated to ${status}`,\n        productionSlip,\n    });\n});\nexports.addingOrderQuantity = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const allProductionSlips = await productionSlipModel_1.default.find();\n    const allWorkOrders = await workOrderModel_1.default.find().lean();\n    const workOrderStore = {};\n    allWorkOrders.forEach((w) => {\n        const id = w._id + \"\";\n        workOrderStore[id] = {\n            ...w,\n        };\n    });\n    for (let i of allProductionSlips) {\n        const workOrder = workOrderStore[i.workOrderId + \"\"];\n        const partId = i.part._id + \"\";\n        let totalNumberOfItems = 0;\n        workOrder?.masterBom.forEach((w) => {\n            const id = w._id + \"\";\n            if (partId === id) {\n                totalNumberOfItems = w.numberOfItem;\n            }\n        });\n        const productionSlip = await productionSlipModel_1.default.findById(i._id);\n        if (productionSlip) {\n            productionSlip.itemPerWorkOrder = totalNumberOfItems;\n            await productionSlip.save();\n        }\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"All work done.\",\n    });\n});\n// function calculateTotalHours(timeIntervals:any) {\n//   let totalHours = 0;\n//   // Iterate through the time intervals\n//   for (let i = 0; i < timeIntervals.length; i++) {\n//       const interval = timeIntervals[i];\n//       const startTime = new Date(interval.startTime);\n//       const endTime = new Date(interval.endTime);\n//       // Calculate the duration in milliseconds\n//       const durationMs = endTime - startTime;\n//       // Convert duration to hours\n//       const durationHours = durationMs / (1000 * 60 * 60);\n//       // Subtract common intervals (if not the first interval)\n//       if (i > 0) {\n//           const commonStart = Math.max(startTime, new Date(timeIntervals[i - 1].endTime));\n//           const commonEnd = Math.min(endTime, new Date(timeIntervals[i - 1].endTime));\n//           const commonDurationMs = commonEnd - commonStart;\n//           const commonDurationHours = commonDurationMs / (1000 * 60 * 60);\n//           durationHours -= commonDurationHours;\n//       }\n//       // Add the duration to the total\n//       totalHours += durationHours;\n//   }\n//   return totalHours;\n// }\nfunction sortEventsByStartTime(events) {\n    return events.slice().sort((a, b) => {\n        const startTime = new Date(a.startTime);\n        const endTime = new Date(b?.startTime);\n        return startTime - endTime;\n    });\n}\nfunction gettingHours(timeArray) {\n    let newArray;\n    if (timeArray.length === 0) {\n        return 0;\n    }\n    if (timeArray.length > 1) {\n        newArray = sortEventsByStartTime(timeArray);\n    }\n    else {\n        newArray = timeArray;\n    }\n    ;\n    let startTime = new Date(newArray[0].startTime);\n    let endTime = new Date(newArray[newArray.length - 1].endTime)\n        ? new Date(newArray[newArray.length - 1].endTime)\n        : new Date();\n    const timeDifference = endTime - startTime;\n    const totalHours = timeDifference / (1000 * 60 * 60);\n    let idleHours = 0;\n    let lastestEndTime = new Date(newArray[0].endTime);\n    for (let i = 1; i < newArray.length - 1; i++) {\n        const start = new Date(newArray[i].startTime);\n        if (start > lastestEndTime) {\n            const difference = start - lastestEndTime;\n            idleHours += difference / (1000 * 60 * 60);\n        }\n        ;\n        lastestEndTime = new Date(newArray[i].endTime);\n    }\n    ;\n    return totalHours - idleHours;\n}\nexports.gettingHours = gettingHours;\n;\n// get employee productivity\nconst getProductivityPerEmployee = async (employeeId, firstPunchIn, lastPunchOut) => {\n    try {\n        // const { employeeId } = req.params;\n        // const { date, nextDate } = req.query as { date: string; nextDate: string };\n        // let newDate;\n        // let newNextDate;\n        // if (date) {\n        //   newDate = new Date(date);\n        //   newDate.setHours(0, 0, 0, 0);\n        // } else {\n        //   newDate = new Date(\"2023-10-16\");\n        //   newDate.setHours(0, 0, 0, 0);\n        // }\n        // if (nextDate) {\n        //   newNextDate = new Date(nextDate);\n        //   newNextDate.setHours(0, 0, 0, 0);\n        // } else {\n        //   newNextDate = new Date();\n        //   newNextDate.setHours(0, 0, 0, 0);\n        // }\n        // const employeeDetails = await EmployeeModel.findById(employeeId);\n        console.log(\"First punchin ........................................\", firstPunchIn);\n        console.log(\"current punch Out.....................................\", lastPunchOut);\n        // const EmployeeId = employeeDetails?._id + \"\";\n        const productionSlips = await productionSlipModel_1.default.find({\n            durationFrom: {\n                $gte: new Date(firstPunchIn),\n                $lte: new Date(lastPunchOut),\n            },\n            // \"working.employees.employeeId\": employeeId,\n            status: { $nin: [\"cancel\"] },\n        }).lean();\n        // console.log(\"productionSlips\",productionSlips)\n        const allDetails = [];\n        const productionSlipNumbers = [];\n        productionSlips?.forEach((p) => {\n            if (p.working && p.working.length > 0) {\n                p.working.forEach((w) => {\n                    w?.employees.forEach((e) => {\n                        if (e.employeeId + \"\" === employeeId + \"\") {\n                            const obj = {\n                                startTime: w.startTime,\n                                endTime: w.endTime ? w.endTime : new Date(),\n                                // itemProduced : w.itemProduced,\n                                // productionSlipNumber : p.productionSlipNumber,\n                                // timeSpend : new Date(w.endTime) - new Date(w.startTime);\n                            };\n                            const productionSlipNumber = p.productionSlipNumber;\n                            productionSlipNumbers.push(productionSlipNumber);\n                            allDetails.push(obj);\n                        }\n                        ;\n                    });\n                });\n            }\n            ;\n        });\n        // const data = [\n        //   {\n        //     startTime: \"2023-10-16T09:00:00.000Z\",\n        //     endTime: \"2023-10-16T12:22:00.000Z\",\n        //   },\n        //   {\n        //     startTime: \"2023-10-16T08:00:00.000Z\",\n        //     endTime: \"2023-10-16T10:48:00.000Z\",\n        //   },\n        //   {\n        //     startTime: \"2023-10-16T14:00:00.000Z\",\n        //     endTime: \"2023-10-16T14:32:00.000Z\",\n        //   },\n        //   {\n        //     startTime: \"2023-10-16T16:58:00.000Z\",\n        //     endTime: \"2023-10-16T20:00:00.000Z\",\n        //   },\n        //   {\n        //     startTime: \"2023-10-16T15:32:00.000Z\",\n        //     endTime: \"2023-10-16T18:28:00.000Z\",\n        //   },\n        // ];\n        return {\n            productionSlipNumbers,\n            productiveHours: gettingHours(allDetails),\n        };\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.getProductivityPerEmployee = getProductivityPerEmployee;\n// STATUS CARDS\nexports.statusCards = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const activeSlips = await productionSlipModel_1.default.countDocuments({ status: \"active\" });\n    const inActiveSlips = await productionSlipModel_1.default.countDocuments({ status: \"inactive\" });\n    const completedSlips = await productionSlipModel_1.default.countDocuments({ status: \"completed\" });\n    const cancelledSlips = await productionSlipModel_1.default.countDocuments({ status: \"cancel\" });\n    const manualSlips = await productionSlipModel_1.default.countDocuments({ status: \"manual\" });\n    const cncSlips = await productionSlipModel_1.default.countDocuments({ status: \"cnc\" });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting Status Successfully\",\n        data: {\n            activeSlips,\n            inActiveSlips,\n            completedSlips,\n            cancelledSlips,\n            manualSlips,\n            cncSlips\n        }\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/productionSlipController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/productivityReportController.ts":
/*!************************************************************************!*\
  !*** ./src/controllers/bomControllers/productivityReportController.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MachineReport = exports.EmployeeReport = exports.SingleEmployeeReport = exports.singleMachineReport = exports.getNewReportPerMachine = exports.getReportPerMachine = exports.getReportPerEmployee = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst v2attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/v2attendanceModel */ \"./src/database/models/v2attendanceModel.ts\"));\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst productionSlipController_1 = __webpack_require__(/*! ./productionSlipController */ \"./src/controllers/bomControllers/productionSlipController.ts\");\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst shopLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopLogModel */ \"./src/database/models/shopLogModel.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst machineModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/machineModel */ \"./src/database/models/machineModel.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\n// getting employee report\nexports.getReportPerEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeIds, jobProfileNames, groupNames, shops, date, nextDate, shifts, } = req.body;\n    let newDate;\n    let newNextDate;\n    if (date && nextDate) {\n        newDate = new Date(date);\n        newNextDate = new Date(nextDate);\n        newNextDate.setDate(newNextDate.getDate() + 1);\n    }\n    else if (date) {\n        newDate = new Date(date);\n        newNextDate = new Date(newDate);\n        newNextDate.setDate(newNextDate.getDate() + 1);\n    }\n    else {\n        newDate = new Date(new Date());\n        newNextDate = new Date(newDate);\n        newNextDate.setDate(newNextDate.getDate() + 1);\n    }\n    const EmployeeIds = [];\n    if (employeeIds && employeeIds.length > 0 && shops && shops.length == 0) {\n        employeeIds.forEach((e) => {\n            EmployeeIds.push(e);\n        });\n    }\n    else if (shops && shops.length) {\n        const selectedShops = await shopModel_1.default.find({\n            shopName: { $in: shops },\n        }).lean();\n        const shopIds = selectedShops.map((s) => s._id);\n        if (employeeIds && employeeIds.length > 0) {\n            const shopLogs = await shopLogModel_1.default.find({\n                shopId: shopIds,\n                \"employees.employeeId\": { $in: employeeIds },\n                date: {\n                    $gte: newDate,\n                    $lt: newNextDate,\n                },\n            });\n            for (let s of shopLogs) {\n                for (let e of s.employees) {\n                    if (employeeIds.includes(e.employeeId + \"\")) {\n                        const id = e.employeeId;\n                        EmployeeIds.push(id);\n                    }\n                }\n            }\n        }\n        else {\n            const shopLogs = await shopLogModel_1.default.find({\n                shopId: shopIds,\n                date: {\n                    $gte: newDate,\n                    $lt: newNextDate,\n                },\n            });\n            for (let s of shopLogs) {\n                for (let e of s.employees) {\n                    const id = e.employeeId;\n                    EmployeeIds.push(id);\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    if (jobProfileNames && jobProfileNames.length > 0) {\n        const jobProfileDetails = await jobProfileModel_1.default.find({\n            jobProfileName: { $in: jobProfileNames },\n        }).lean();\n        const jobProfileIds = jobProfileDetails.map((j) => j._id);\n        const employees = await employeeModel_1.default.find({\n            jobProfileId: { $in: jobProfileIds },\n        });\n        employees.forEach((e) => {\n            EmployeeIds.push(e._id);\n        });\n    }\n    if (groupNames && groupNames.length > 0) {\n        const Groups = await groupModel_1.default\n            .find({ groupName: { $in: groupNames } })\n            .lean();\n        const groupIds = Groups.map((g) => g._id);\n        const employees = await employeeModel_1.default.find({\n            groupId: { $in: groupIds },\n        }).lean();\n        employees.forEach((e) => {\n            const id = e._id;\n            EmployeeIds.push(id);\n        });\n    }\n    const allProductionSlips = await productionSlipModel_1.default.find()\n        .select({ productionSlipNumber: 1, shop: 1, process: 1, working: 1 })\n        .lean();\n    const productionSlipStore = {};\n    allProductionSlips.forEach((p) => {\n        const productionSlipNumber = p.productionSlipNumber + \"\";\n        productionSlipStore[productionSlipNumber] = {\n            ...p,\n        };\n    });\n    const jobProfiles = await jobProfileModel_1.default.find().lean();\n    const jobProfileStore = {};\n    jobProfiles.forEach((j) => {\n        const id = j._id + \"\";\n        jobProfileStore[id] = {\n            ...j,\n        };\n    });\n    const employeeDocs = await employeeDocsModel_1.default.find({\n        employeeId: { $in: EmployeeIds },\n    }).lean();\n    const docsStore = {};\n    employeeDocs.forEach((e) => {\n        const id = e.employeeId + \"\";\n        docsStore[id] = {\n            ...e,\n        };\n    });\n    const employees = await employeeModel_1.default.find({\n        _id: { $in: EmployeeIds },\n    }).lean();\n    const employeeStore = {};\n    employees.forEach((e) => {\n        const id = e._id + \"\";\n        employeeStore[id] = { ...e };\n    });\n    const allAttendance = await v2attendanceModel_1.default\n        .find({\n        employeeId: { $in: EmployeeIds },\n        date: {\n            $gte: newDate,\n            $lte: newNextDate,\n        },\n        shift: { $in: shifts },\n    })\n        .lean();\n    const result = [];\n    let shopNewField = 0;\n    let shopProductiveHours = 0;\n    let shopTotalProductionSlipHours = 0;\n    for (let a of allAttendance) {\n        const employeeId = a.employeeId + \"\";\n        const employee = employeeStore[employeeId];\n        const punchIn = new Date(a.punches[0].punchIn);\n        const shift = a.shift;\n        let punchOut;\n        let totalhours = 0;\n        if (a.punches[a.punches.length - 1].punchOut) {\n            punchOut = new Date(a.punches[a.punches.length - 1].punchOut);\n            totalhours =\n                (punchOut.getTime() - punchIn.getTime()) / (60 * 60 * 1000);\n        }\n        else {\n            const currentTime = new Date();\n            currentTime.setTime(currentTime.getTime() + 330 * 60 * 1000);\n            totalhours = (currentTime.getTime() - punchIn.getTime()) / (60 * 60 * 1000);\n        }\n        let totalProductiveHours;\n        let slipNumbers = [];\n        totalProductiveHours = a.productiveHours;\n        slipNumbers = a.productionSlipNumbers;\n        if (!slipNumbers.length) {\n            continue;\n        }\n        const productionSlips = [];\n        if (slipNumbers) {\n            for (let p of slipNumbers) {\n                const productionSlip = productionSlipStore[p];\n                if (productionSlip) {\n                    productionSlips.push(productionSlip);\n                }\n                ;\n            }\n            ;\n        }\n        ;\n        let totalProductionSlipHours = 0;\n        for (let p of productionSlips) {\n            for (let w of p.working) {\n                if (w.endTime && w.startTime) {\n                    for (let e of w.employees) {\n                        if (e.employeeId + \"\" === employeeId + \"\") {\n                            const startTime = new Date(w.startTime || new Date);\n                            const endTime = new Date(w.endTime || new Date);\n                            totalProductionSlipHours += (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);\n                        }\n                        ;\n                    }\n                    ;\n                }\n                ;\n            }\n            ;\n        }\n        ;\n        const data = await (0, exports.SingleEmployeeReport)({\n            employeeId: employee._id + \"\",\n            date,\n            shift,\n        });\n        const newResult = data?.result?.newResult || [];\n        let totalNewField = 0;\n        if (newResult.length) {\n            let index = 0;\n            for (let n of newResult) {\n                let totalProductiveTime = 0;\n                let totalProduction = 0;\n                let actualTime = 0;\n                for (let d of n.data) {\n                    totalProductiveTime += d.actualTime || 0;\n                    totalProduction += d.actualPartPerHour * d.actualTime || 0;\n                }\n                const weightedAverage = totalProduction / totalProductiveTime;\n                n.weightedAverage = weightedAverage;\n                let productivityPercentage = 0;\n                for (let d of n.data) {\n                    const percentage = (((d.actualPartPerHour || 0) - weightedAverage) / weightedAverage) * 100;\n                    d.percentage = percentage;\n                    if (slipNumbers[index] === d.productionSlipNumber) {\n                        productivityPercentage = d.percentage;\n                        actualTime = d.actualTime || 0;\n                    }\n                }\n                index++;\n                n.productivityPercentage = productivityPercentage || 0;\n                n.newField = productivityPercentage * actualTime;\n                totalNewField += n.newField;\n            }\n        }\n        totalNewField = totalNewField / totalProductiveHours;\n        const obj = {\n            date: a.date,\n            shift: a?.shift,\n            employeeName: employee.name,\n            employeeId: employee._id,\n            employeeCode: employee.employeeCode,\n            jobProfileName: jobProfileStore[employee.jobProfileId + \"\"].jobProfileName,\n            profilePicture: docsStore[employee._id + \"\"]?.profilePicture || \"\",\n            productionSlips,\n            totalhours,\n            totalProductionSlipHours,\n            totalNewField,\n            totalProductiveHours,\n            slipNumbers,\n            newResult,\n        };\n        shopTotalProductionSlipHours += totalProductionSlipHours;\n        shopNewField += totalNewField * totalProductiveHours;\n        shopProductiveHours += totalProductiveHours;\n        result.push(obj);\n    }\n    resp.status(200).json({\n        success: true,\n        message: `Getting report successfully.`,\n        shopReport: {\n            shopTotalProductionSlipHours,\n            shopProductiveHours,\n            shopNewField,\n        },\n        result,\n    });\n});\n// MACHINE REPORT\nexports.getReportPerMachine = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { date, shop, machinesArr } = req.body;\n    let startDate = new Date(date);\n    startDate.setUTCHours(0, 0, 0, 0);\n    let endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n    let query = {};\n    if (machinesArr && machinesArr.length > 0) {\n        query[\"machineName\"] = {\n            $in: machinesArr,\n        };\n    }\n    // SHOP FILTER\n    if (shop && shop.length > 0) {\n        let shopIds = [];\n        const shops = await shopModel_1.default.find({ shopName: { $in: shop } });\n        shops.forEach((s) => {\n            shopIds.push(s._id);\n        });\n        if (shopIds.length > 0) {\n            let processIds = [];\n            const processes = await globalProcessModel_1.default.find({\n                \"shop.shopId\": { $in: shopIds },\n            });\n            processes.forEach((p) => {\n                processIds.push(p._id);\n            });\n            if (processIds.length > 0) {\n                query[\"process\"] = {\n                    $in: processIds,\n                };\n            }\n        }\n    }\n    const machines = await machineModel_1.default.find({\n        ...query,\n    });\n    const machineStore = {};\n    let machineIds = [];\n    machines.forEach((m) => {\n        machineStore[m._id] = {\n            _id: m._id,\n            machineName: m.machineName,\n            productiveTimeArr: [],\n            productiveHour: 0,\n            totalWorkingHours: 0,\n            productionSlips: [],\n            process: [],\n            shop: [],\n            totalProductionSlipTime: 0\n        };\n        machineIds.push(m._id);\n    });\n    const productionSlips = await productionSlipModel_1.default.find({\n        durationFrom: {\n            $gte: startDate,\n            $lte: endDate,\n        },\n        status: { $nin: \"cancel\" },\n        \"working.machines.machineId\": {\n            $in: machineIds,\n        },\n    }).lean();\n    productionSlips.forEach((p) => {\n        p.working.forEach((w) => {\n            w.machines.forEach((m) => {\n                const startTime = w.startTime\n                    ? new Date(w.startTime).getTime()\n                    : new Date().getTime();\n                const endTime = w.endTime\n                    ? new Date(w.endTime).getTime()\n                    : new Date().getTime();\n                const workingTime = (endTime - startTime) / (1000 * 60 * 60);\n                if (machineStore[m.machineId + \"\"]) {\n                    const obj = {\n                        startTime: new Date(startTime),\n                        endTime: new Date(endTime),\n                    };\n                    machineStore[m.machineId + \"\"] = {\n                        ...machineStore[m.machineId + \"\"],\n                        totalWorkingHours: machineStore[m.machineId + \"\"].totalWorkingHours + workingTime,\n                        productionSlips: machineStore[m.machineId + \"\"].productionSlips.includes(p.productionSlipNumber) ? [...machineStore[m.machineId + \"\"].productionSlips] : [...machineStore[m.machineId + \"\"].productionSlips, p.productionSlipNumber,],\n                        process: machineStore[m.machineId + \"\"].productionSlips.includes(p.productionSlipNumber)\n                            ? [...machineStore[m.machineId + \"\"].process]\n                            : [\n                                ...machineStore[m.machineId + \"\"].process,\n                                p.process.processName,\n                            ],\n                        shop: machineStore[m.machineId + \"\"].productionSlips.includes(p.productionSlipNumber)\n                            ? [...machineStore[m.machineId + \"\"].shop]\n                            : [...machineStore[m.machineId + \"\"].shop, p.shop.shopName],\n                    };\n                    machineStore[m.machineId + \"\"].productiveTimeArr.push(obj);\n                    machineStore[m.machineId + \"\"].productiveHour = (0, productionSlipController_1.gettingHours)(machineStore[m.machineId + \"\"].productiveTimeArr);\n                }\n            });\n        });\n    });\n    const result = [];\n    for (let m in machineStore) {\n        const data = await (0, exports.MachineReport)({ machineId: machineStore[m]._id + \"\", date });\n        result.push({\n            percentage: data.newData,\n            machineId: machineStore[m]._id,\n            machineName: machineStore[m].machineName,\n            productiveHour: machineStore[m].productiveHour,\n            totalWorkingHours: machineStore[m].totalWorkingHours,\n            productionSlips: machineStore[m].productionSlips,\n            process: machineStore[m].process,\n            shop: machineStore[m].shop,\n        });\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Getting Machine Report Successfully\",\n        result,\n    });\n});\n// MACHINE REPORT\nexports.getNewReportPerMachine = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { date, shop, machinesArr } = req.body;\n    let startDate = new Date(date);\n    startDate.setUTCHours(0, 0, 0, 0);\n    let endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n    let query = {};\n    if (machinesArr && machinesArr.length > 0) {\n        query[\"machineName\"] = {\n            $in: machinesArr,\n        };\n    }\n    // SHOP FILTER\n    if (shop && shop.length > 0) {\n        let shopIds = [];\n        const shops = await shopModel_1.default.find({ shopName: { $in: shop } });\n        shops.forEach((s) => {\n            shopIds.push(s._id);\n        });\n        if (shopIds.length > 0) {\n            let processIds = [];\n            const processes = await globalProcessModel_1.default.find({\n                \"shop.shopId\": { $in: shopIds },\n            });\n            processes.forEach((p) => {\n                processIds.push(p._id);\n            });\n            if (processIds.length > 0) {\n                query[\"process\"] = {\n                    $in: processIds,\n                };\n            }\n        }\n    }\n    const machines = await machineModel_1.default.find({\n        ...query,\n    }).lean();\n    let machineIds = [];\n    const machineDetailStore = {};\n    machines.forEach((m) => {\n        machineIds.push(m._id);\n        machineDetailStore[m._id + \"\"] = { ...m };\n    });\n    const productionSlips = await productionSlipModel_1.default.find({\n        durationFrom: {\n            $gte: startDate,\n            $lte: endDate,\n        },\n        status: { $nin: \"cancel\" },\n        \"working.machines.machineId\": {\n            $in: machineIds,\n        },\n    }).lean();\n    const machineStore = {};\n    for (let p of productionSlips) {\n        const newMachineArray = [];\n        for (let w of p.working) {\n            for (let m of w.machines) {\n                newMachineArray.push(m.machineId + \"\");\n            }\n        }\n        const uniqueMachineArray = [...new Set(newMachineArray)];\n        for (let u of uniqueMachineArray) {\n            if (!machineStore[u]) {\n                machineStore[u] = {\n                    slips: []\n                };\n            }\n            machineStore[u].slips.push({ ...p });\n        }\n    }\n    const result = [];\n    for (let m of machineIds) {\n        const slips = machineStore[m + \"\"]?.slips || [];\n        const machineDetails = machineDetailStore[m + \"\"];\n        if (!slips.length) {\n            continue;\n        }\n        ;\n        let totalHours = 0;\n        let timeArray = [];\n        const productionSlipNumbers = [];\n        const shopNames = [];\n        const processName = [];\n        for (let s of slips) {\n            for (let w of s.working) {\n                if (w.startTime && w.endTime) {\n                    for (let machine of w.machines) {\n                        if (machine.machineId + \"\" === m + \"\") {\n                            const startTime = new Date(w.startTime);\n                            const endTime = new Date(w.endTime);\n                            timeArray.push({ startTime, endTime });\n                            totalHours += (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);\n                        }\n                        ;\n                    }\n                    ;\n                }\n                ;\n            }\n            ;\n            productionSlipNumbers.push(s.productionSlipNumber);\n            processName.push(s.process.processName);\n            shopNames.push(s.shop.shopName);\n        }\n        ;\n        const data = await (0, exports.MachineReport)({ machineId: m + \"\", date });\n        const productiveHours = (0, productionSlipController_1.gettingHours)(timeArray);\n        const obj = {\n            percentage: data.newData,\n            machineId: machineDetails._id,\n            machineName: machineDetails.machineName,\n            productiveHour: productiveHours,\n            totalWorkingHours: totalHours,\n            productionSlips: productionSlipNumbers,\n            process: processName,\n            shop: shopNames,\n        };\n        result.push(obj);\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Getting Machine Report Successfully\",\n        result\n    });\n});\nconst singleMachineReport = async (req, resp, next) => {\n    try {\n        const { machineId } = req.body;\n        const productionSlips = await productionSlipModel_1.default.find({\n            \"working.machines.machineId\": machineId,\n        }).lean();\n        const result = [];\n        for (let p of productionSlips) {\n            const startDay = new Date(p.durationFrom);\n            const data = await machineReport(machineId, startDay, productionSlips);\n            result.push(data);\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"Getting data successfully.\",\n            result,\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.singleMachineReport = singleMachineReport;\nconst machineReport = async (machineId, date, productionSlips) => {\n    const newDate = new Date(date);\n    newDate.setUTCHours(0, 0, 0, 0);\n    const nextDate = new Date(newDate);\n    nextDate.setDate(nextDate.getDate() + 1);\n    const productionSlipArray = [];\n    const timeArray = [];\n    const productivityArray = [];\n    for (let p of productionSlips) {\n        const startDate = new Date(p.durationFrom);\n        if (newDate.getTime() < startDate.getTime() &&\n            nextDate.getTime() > startDate.getTime()) {\n            productionSlipArray.push(p);\n        }\n    }\n    for (let p of productionSlipArray) {\n        for (let t of p.working) {\n            if (t.startTime && t.endTime) {\n                for (let m of t.machines) {\n                    if (m.machineId + \"\" === machineId + \"\") {\n                        const startTime = new Date(t.startTime);\n                        const endTime = new Date(t.endTime);\n                        const obj = {\n                            startTime,\n                            endTime,\n                        };\n                        timeArray.push(obj);\n                    }\n                }\n            }\n        }\n        const totalHours = (new Date(p.durationTo).getTime() - new Date(p.durationFrom).getTime()) /\n            (60 * 60 * 1000);\n        const obj = {\n            totalHours,\n            date: newDate,\n            nextDate,\n            itemProduced: p.itemProduced,\n            productiveTime: 0,\n            productionSlipNumber: p.productionSlipNumber,\n        };\n        productivityArray.push(obj);\n    }\n    const productiveTime = (0, productionSlipController_1.gettingHours)(timeArray) || 0;\n    let totalHours = 0;\n    let totalProduction = 0;\n    for (let p of productivityArray) {\n        totalHours += p.totalHours || 0;\n        totalProduction += p.itemProduced || 0;\n    }\n    const perHourProduction = totalProduction / productiveTime;\n    return {\n        perHourProduction,\n        productiveTime: productiveTime,\n        productivityArray: productivityArray,\n    };\n};\n// single employee report\nconst SingleEmployeeReport = async (data) => {\n    try {\n        const { employeeId, date, shift } = data;\n        let newDate;\n        let newNextDate;\n        newDate = new Date(date);\n        newNextDate = new Date(newDate);\n        newNextDate.setDate(newNextDate.getDate() + 1);\n        const employeeDocs = await employeeDocsModel_1.default.find({\n            employeeId: { $in: employeeId },\n        }).lean();\n        const docsStore = {};\n        employeeDocs.forEach((e) => {\n            const id = e.employeeId + \"\";\n            docsStore[id] = {\n                ...e,\n            };\n        });\n        const allProductionSlips = await productionSlipModel_1.default.find({\n            status: { $in: [\"completed\", \"cnc\"] }, itemProduced: { $gt: 0 }\n        }).lean();\n        const productionSlipStore = {};\n        const partSlipStore = {};\n        allProductionSlips.forEach((p) => {\n            const id = p.part._id + \"\";\n            const productionSlipNumber = p.productionSlipNumber + \"\";\n            if (!partSlipStore[id]) {\n                partSlipStore[id] = { slips: [] };\n            }\n            partSlipStore[id].slips.push({ ...p });\n            productionSlipStore[productionSlipNumber] = { ...p };\n        });\n        const employee = await employeeModel_1.default.findOne({\n            _id: { $in: employeeId },\n        }).lean();\n        if (!employee) {\n            return {\n                success: false,\n                message: `Employee with id ${employeeId} not found.`,\n            };\n        }\n        const allAttendance = await v2attendanceModel_1.default\n            .find({\n            employeeId: employee?._id,\n            date: {\n                $gte: newDate,\n                $lte: newNextDate,\n            },\n            shift: { $in: shift },\n        }).lean();\n        let result = {};\n        for (let a of allAttendance) {\n            const punchIn = new Date(a.punches[0].punchIn);\n            let punchOut;\n            let totalhours = 0;\n            if (a.punches[a.punches.length - 1].punchOut) {\n                punchOut = new Date(a.punches[a.punches.length - 1].punchOut);\n                totalhours = (punchOut.getTime() - punchIn.getTime()) / (60 * 60 * 1000);\n            }\n            else {\n                const currentTime = new Date();\n                currentTime.setTime(currentTime.getTime() + 330 * 60 * 1000);\n                totalhours = (currentTime.getTime() - punchIn.getTime()) / (60 * 60 * 1000);\n            }\n            let totalProductiveHours;\n            let slipNumbers = [];\n            totalProductiveHours = a.productiveHours;\n            slipNumbers = a.productionSlipNumbers;\n            const productionSlips = [];\n            if (slipNumbers) {\n                for (let p of slipNumbers) {\n                    const productionSlip = productionSlipStore[p];\n                    if (productionSlip) {\n                        productionSlips.push(productionSlip);\n                    }\n                }\n            }\n            const newResult = [];\n            for (let p of productionSlips) {\n                const partId = p.part._id + \"\";\n                const partSlips = partSlipStore[partId];\n                const data = await childPartReport(partSlips, productionSlipStore);\n                let totalProduction = 0;\n                let totalActualTime = 0;\n                // --------------------------------- pending\n                if (data) {\n                    for (let d of data) {\n                        totalProduction += (d.actualPartPerHour * d.actualTime);\n                        totalActualTime += d.actualTime;\n                    }\n                }\n                const obj = { data, partName: p.part.partName, partId };\n                newResult.push(obj);\n            }\n            const obj = {\n                date: a.date,\n                shift: a?.shift,\n                employeeName: employee.name,\n                employeeId: employee._id,\n                employeeCode: employee.employeeCode,\n                profilePicture: docsStore[employee._id + \"\"]?.profilePicture || \"\",\n                productionSlips,\n                newResult,\n                totalhours,\n                totalProductiveHours,\n                slipNumbers,\n            };\n            result = obj;\n        }\n        return {\n            success: true,\n            message: \"Getting Per employee report successfully.\",\n            result,\n        };\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.SingleEmployeeReport = SingleEmployeeReport;\nconst childPartReport = async (partSlips, productionSlipStore) => {\n    const productionSlips = partSlips.slips;\n    const result = [];\n    for (let p of productionSlips) {\n        const partId = p.part._id + \"\";\n        for (let w of p.working) {\n            let startTime;\n            let endTime;\n            if (w.startTime) {\n                startTime = new Date(w.startTime);\n                startTime.setHours(0, 0, 0, 0);\n            }\n            else {\n                return;\n            }\n            for (let e of w.employees) {\n                const employeeId = e.employeeId + \"\";\n                const data = await employeeReportPerPart(employeeId, partId, startTime, productionSlipStore);\n                if (data && data.totalProductiveTime > 0) {\n                    result.push({ ...data, employeeName: e.employeeName, employeeId });\n                }\n            }\n        }\n    }\n    return result;\n};\nconst employeeReportPerPart = async (employeeId, partId, startTime, productionSlipStore) => {\n    const attendance = await v2attendanceModel_1.default.findOne({\n        employeeId,\n        date: {\n            $gte: new Date(startTime),\n        },\n    });\n    if (!attendance) {\n        return;\n    }\n    const productionSlipNumbers = attendance.productionSlipNumbers;\n    const totalProductiveTime = attendance.productiveHours || 0;\n    let totalTime = 0;\n    let childPartTime = 0;\n    let totalProductionPerChildPart = 0;\n    let totalNumberOfEmployee = 0;\n    let productionSlipNumber = \"\";\n    for (let p of productionSlipNumbers) {\n        const productionSlip = productionSlipStore[p];\n        if (!productionSlip) {\n            return;\n        }\n        if (productionSlip.part._id + \"\" === partId + \"\") {\n            productionSlipNumber = productionSlip.productionSlipNumber;\n            for (let w of productionSlip.working) {\n                totalNumberOfEmployee = w.employees.length;\n                if (w.startTime && w.endTime) {\n                    for (let e of w.employees) {\n                        if (employeeId + \"\" === e.employeeId + \"\") {\n                            totalProductionPerChildPart +=\n                                w.itemProduced / totalNumberOfEmployee;\n                            childPartTime =\n                                (new Date(w.endTime).getTime() -\n                                    new Date(w.startTime).getTime()) /\n                                    (60 * 60 * 1000);\n                        }\n                    }\n                }\n            }\n        }\n        for (let w of productionSlip.working) {\n            if (w.startTime && w.endTime) {\n                for (let e of w.employees) {\n                    if (employeeId + \"\" === e.employeeId + \"\") {\n                        totalTime +=\n                            (new Date(w.endTime).getTime() -\n                                new Date(w.startTime).getTime()) /\n                                (60 * 60 * 1000);\n                    }\n                }\n            }\n        }\n    }\n    const ratio = childPartTime / totalTime || 0;\n    const actualTime = ratio * totalProductiveTime || 0;\n    const actualPartPerHour = totalProductionPerChildPart / actualTime || 0;\n    return {\n        totalTime,\n        actualTime,\n        actualPartPerHour,\n        ratio,\n        productionSlipNumber,\n        date: attendance.date,\n        totalProductiveTime,\n    };\n};\n// employee report for APP\nexports.EmployeeReport = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeIds, newDate } = req.body;\n    const employeeDetails = await employeeModel_1.default.find({\n        _id: { $in: employeeIds },\n    }).lean();\n    const employeeStore = {};\n    const ids = [];\n    employeeDetails.forEach((e) => {\n        const id = e._id + \"\";\n        ids.push(id);\n        employeeStore[id] = {\n            ...e,\n        };\n    });\n    let date;\n    let nextDate;\n    if (newDate) {\n        date = new Date(newDate);\n        date.setHours(0, 0, 0, 0);\n        nextDate = new Date(date);\n        nextDate.setDate(nextDate.getDate() + 1);\n        nextDate.setHours(0, 0, 0, 0);\n    }\n    else {\n        date = new Date();\n        date.setHours(0, 0, 0, 0);\n        nextDate = new Date(date);\n        nextDate.setDate(nextDate.getDate() + 1);\n        nextDate.setHours(0, 0, 0, 0);\n    }\n    const attendanceDetails = await v2attendanceModel_1.default\n        .find({\n        employeeId: { $in: ids },\n        date: {\n            $gte: date,\n            $lt: nextDate,\n        },\n    })\n        .lean();\n    const result = {};\n    for (let a of attendanceDetails) {\n        const employeeId = a.employeeId + \"\";\n        const firstPunchIn = new Date(a.punches[0].punchIn);\n        firstPunchIn.setTime(firstPunchIn.getTime() - 330 * 60 * 1000);\n        const date = new Date();\n        date.setTime(date.getTime() + 330 * 60 * 1000);\n        const lastPunchOut = a.punches[a.punches.length - 1]?.punchOut\n            ? a.punches[a.punches.length - 1]?.punchOut\n            : date;\n        const newLastPunch = new Date(lastPunchOut);\n        newLastPunch.setTime(newLastPunch.getTime() - 330 * 60 * 1000);\n        const totalHours = (newLastPunch.getTime() - firstPunchIn.getTime()) / (60 * 60 * 1000);\n        const data = await (0, productionSlipController_1.getProductivityPerEmployee)(employeeId, firstPunchIn, newLastPunch);\n        const obj = {\n            productivity: data?.productiveHours || 0,\n            totalHours,\n            employeeId,\n        };\n        result[employeeId] = obj;\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Getting productivity per employee.\",\n        result,\n    });\n});\n//\nconst MachineReport = async (data) => {\n    const { machineId, date } = data;\n    const newDate = new Date(date);\n    const nextDate = new Date(newDate);\n    nextDate.setDate(nextDate.getDate() + 1);\n    const productionSlipsMachine = await productionSlipModel_1.default.find({\n        \"working.machines.machineId\": machineId,\n        durationFrom: {\n            $gte: newDate,\n            $lt: nextDate,\n        },\n        status: { $in: [\"completed\", \"cnc\"] },\n    }).lean();\n    const result = [];\n    for (let p of productionSlipsMachine) {\n        const partId = p.part._id + \"\";\n        const data = await singleMachine(partId);\n        let totalActualHours = 0;\n        let totalProduction = 0;\n        for (let d of data) {\n            totalActualHours += d.actualTimePart || 0;\n            totalProduction += d.totalPartProduction;\n        }\n        const weightedAverage = totalProduction / totalActualHours;\n        let totalPercentage = 0;\n        let currentDayPercentage = 0;\n        let currentDayTime = 0;\n        for (let d of data) {\n            const percentage = ((d.perHourProduction - weightedAverage) / weightedAverage) * 100;\n            if (isFinite(percentage)) {\n                d.percentage = percentage;\n            }\n            else {\n                d.percentage = 0;\n            }\n            if ((d.newDate.getTime() === newDate.getTime()) && machineId + \"\" === d.machineId + \"\") {\n                currentDayPercentage += d.percentage * d.actualTimePart;\n                currentDayTime += d.actualTimePart;\n            }\n            totalPercentage += (d.percentage * d.actualTimePart);\n        }\n        result.push({ partName: p.part.partName, weightedAverage, singleMachinePerDay: {\n                currentDayPercentage,\n                currentDayTime\n            }, perMachineProduction: totalPercentage / totalActualHours, data });\n    }\n    let newData = 0;\n    let totalActualHours = 0;\n    for (let r of result) {\n        // console.log(r.singleMachinePerDay.currentDayPercentage ,r.singleMachinePerDay.currentDayTime)\n        newData += r.singleMachinePerDay.currentDayPercentage;\n        totalActualHours += r.singleMachinePerDay.currentDayTime;\n    }\n    const newResult = newData / totalActualHours;\n    return {\n        success: true,\n        message: \"Getting machine report.\",\n        result,\n        newData: newResult\n    };\n};\nexports.MachineReport = MachineReport;\nconst singleMachine = async (partId) => {\n    const productionSlips = await productionSlipModel_1.default.find({\n        \"part._id\": partId,\n        status: { $in: [\"completed\", \"cnc\"] },\n    });\n    const result = [];\n    for (let p of productionSlips) {\n        for (let w of p.working) {\n            for (let m of w.machines) {\n                const date = new Date(p.durationFrom);\n                date.setUTCHours(0, 0, 0, 0);\n                const machineId = m.machineId + \"\";\n                const data = await lastResultMachine(machineId, partId, date);\n                result.push({\n                    ...data,\n                    machineName: m.machineName,\n                    machineId\n                });\n            }\n        }\n    }\n    return result;\n};\nconst lastResultMachine = async (machineId, partId, date) => {\n    const newDate = new Date(date);\n    const nextDate = new Date(newDate);\n    nextDate.setDate(nextDate.getDate() + 1);\n    const productionSlips = await productionSlipModel_1.default.find({\n        durationFrom: { $gte: newDate, $lt: nextDate },\n        \"working.machines.machineId\": machineId,\n        status: { $in: [\"completed\", \"cnc\"] },\n    }).lean();\n    const timeArray = [];\n    let totalTime = 0;\n    let totalPartHours = 0;\n    let totalPartProduction = 0;\n    let partName = \"\";\n    const productionSlipNumbers = [];\n    for (let p of productionSlips) {\n        if (p.part._id + \"\" === partId + \"\") {\n            partName = p.part.partName;\n            productionSlipNumbers.push(p.productionSlipNumber);\n            for (let w of p.working) {\n                if (w.startTime && w.endTime) {\n                    const totalMachines = w.machines.length;\n                    const itemProduced = w.itemProduced || 0;\n                    const productionPerMachine = itemProduced / totalMachines;\n                    totalPartProduction += productionPerMachine;\n                    const startTime = new Date(w.startTime);\n                    const endTime = new Date(w.endTime);\n                    const hours = (endTime.getTime() - startTime.getTime()) / (60 * 60 * 1000);\n                    totalPartHours += hours;\n                }\n                ;\n            }\n            ;\n        }\n        ;\n        for (let w of p.working) {\n            if (w.startTime && w.endTime) {\n                const startTime = new Date(w.startTime);\n                const endTime = new Date(w.endTime);\n                timeArray.push({ startTime, endTime });\n                const hours = (endTime.getTime() - startTime.getTime()) / (60 * 60 * 1000);\n                totalTime += hours;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    const totalProductiveTime = (0, productionSlipController_1.gettingHours)(timeArray);\n    const ratio = totalPartHours / totalTime || 0;\n    const actualTimePart = ratio * totalProductiveTime || 0;\n    return {\n        newDate,\n        totalTime,\n        totalProductiveTime,\n        ratio,\n        actualTimePart,\n        percentage: 0,\n        perHourProduction: totalPartProduction / actualTimePart,\n        totalPartProduction,\n        productionSlipNumbers,\n        partName,\n    };\n};\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/productivityReportController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/rawMaterialController.ts":
/*!*****************************************************************!*\
  !*** ./src/controllers/bomControllers/rawMaterialController.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deleteGroup = exports.getAllGroup = exports.updateGroup = exports.createGroup = exports.getChildPartByRawMaterial = exports.updateRawMaterial = exports.getAllRawMaterial = exports.getRawMaterial = exports.deleteRawMaterial = exports.addRawMaterial = void 0;\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst rawMaterialGroup_1 = __importDefault(__webpack_require__(/*! ../../database/models/rawMaterialGroup */ \"./src/database/models/rawMaterialGroup.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\n// add\nexports.addRawMaterial = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { name, materialType, code, unit, groupName } = req.body;\n    name = name.trim();\n    materialType = materialType.trim();\n    code = code.trim();\n    unit = unit.trim();\n    const rawMaterial = await childPartModel_1.default.findOne({ partName: name });\n    if (rawMaterial) {\n        return resp.status(400).json({\n            success: false,\n            message: \"raw material already present.\",\n        });\n    }\n    else {\n        const rawMaterial = await childPartModel_1.default.create({\n            childPartType: \"raw\",\n            partName: name,\n            typeOfMaterial: materialType,\n            materialCode: code,\n            unit,\n            numberOfItem: 1,\n        });\n        if (groupName) {\n            const groupDetails = await rawMaterialGroup_1.default.findOne({ groupName });\n            if (!groupDetails) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Group with nam ${groupName} not found.`\n                });\n            }\n            ;\n            rawMaterial.group.groupId = groupDetails._id;\n            rawMaterial.group.groupName = groupDetails.groupName;\n            await rawMaterial.save();\n        }\n        return resp.status(201).json({\n            success: true,\n            message: \"raw material created successfully\",\n            rawMaterial,\n        });\n    }\n    ;\n});\n// delete  raw material\nexports.deleteRawMaterial = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const rawMaterial = await childPartModel_1.default.findById(id);\n    if (!rawMaterial) {\n        return resp.status(404).json({\n            success: false,\n            message: `Raw Material with Id ${id} not found.`,\n        });\n    }\n    const materialId = rawMaterial._id + \"\";\n    const allChildParts = await childPartModel_1.default.find().lean();\n    const foundArray = [];\n    allChildParts.forEach((a) => {\n        if (a.consumedItem) {\n            a.consumedItem.forEach((c) => {\n                const id = c.itemId + \"\";\n                if (materialId == id) {\n                    const string = `Raw Material ${rawMaterial.partName} is used in ChildPart ${a.partName}.`;\n                    foundArray.push(string);\n                }\n            });\n        }\n    });\n    if (foundArray.length > 0) {\n        return resp.status(405).json({\n            success: false,\n            message: \"Child part already present which consuming this raw material.\",\n            foundArray,\n        });\n    }\n    else {\n        await childPartModel_1.default.findByIdAndDelete({ _id: rawMaterial._id });\n        return resp.status(202).json({\n            success: true,\n            message: `Raw material deleted with name ${rawMaterial.partName}.`,\n        });\n    }\n    ;\n});\n// get\nexports.getRawMaterial = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const rawMaterial = await childPartModel_1.default.findById(id);\n    if (rawMaterial) {\n        return resp.status(200).json({\n            success: true,\n            message: \"getting raw material successfully\",\n            rawMaterial: rawMaterial,\n        });\n    }\n    else {\n        return resp.status(201).json({\n            success: true,\n            message: \"raw material not found\",\n        });\n    }\n});\n// get all\nexports.getAllRawMaterial = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, unit, sort, groupName } = req.query;\n    const query = {};\n    if (name) {\n        query.$or = [\n            { partName: { $regex: name, $options: \"i\" } },\n            { materialCode: { $regex: name, $options: \"i\" } },\n            { unit: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    ;\n    if (groupName) {\n        const group = await rawMaterialGroup_1.default.findOne({ groupName: groupName }).lean();\n        if (!group) {\n            resp.status(400).json({\n                success: false,\n                message: `${groupName} group not found`,\n            });\n        }\n        else {\n            query['group.groupId'] = group._id;\n        }\n    }\n    if (unit) {\n        query.unit = unit;\n    }\n    ;\n    let allRawMaterial;\n    if (sort) {\n        if (sort === \"asc\") {\n            allRawMaterial = await childPartModel_1.default.find({ ...query, childPartType: \"raw\" })\n                .sort({ partName: 1 })\n                .lean();\n        }\n        else if (sort === \"dec\") {\n            allRawMaterial = await childPartModel_1.default.find({ ...query, childPartType: \"raw\" })\n                .sort({ partName: -1 })\n                .lean();\n        }\n        else {\n            allRawMaterial = await childPartModel_1.default.find({ ...query, childPartType: \"raw\" })\n                .sort({ partName: 1 })\n                .lean();\n        }\n    }\n    else {\n        allRawMaterial = await childPartModel_1.default.find({ ...query, childPartType: \"raw\" }).lean();\n    }\n    ;\n    return resp.status(201).json({\n        success: true,\n        message: \"getting all  raw material\",\n        allRawMaterial: allRawMaterial,\n    });\n});\nexports.updateRawMaterial = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, materialType, code, unit, groupName } = req.body;\n    const { id } = req.params;\n    const rawMaterial = await childPartModel_1.default.findById(id);\n    if (!rawMaterial) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Raw material not found\",\n        });\n    }\n    if (name) {\n        rawMaterial.partName = name;\n    }\n    if (materialType) {\n        rawMaterial.typeOfMaterial = materialType;\n    }\n    if (code) {\n        rawMaterial.materialCode = code;\n    }\n    if (unit) {\n        rawMaterial.unit = unit;\n    }\n    if (groupName) {\n        const groupDetails = await rawMaterialGroup_1.default.findOne({ groupName });\n        if (!groupDetails) {\n            return resp.status(404).json({\n                success: false,\n                message: `Group with name ${groupName} not found.`\n            });\n        }\n        ;\n        rawMaterial.group.groupId = groupDetails._id;\n        rawMaterial.group.groupName = groupDetails.groupName;\n    }\n    await rawMaterial.save();\n    return resp.status(200).json({\n        success: true,\n        message: \"Raw material updated successfully\",\n        rawMaterial: rawMaterial,\n    });\n});\n// get all childPart which consumed this raw material\nexports.getChildPartByRawMaterial = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const rawMaterial = await childPartModel_1.default.findOne({ _id: id });\n    if (!rawMaterial) {\n        return resp.status(404).json({\n            success: false,\n            message: `Raw material not found with id ${id}.`,\n        });\n    }\n    const allFinishedItem = await finishedItemModel_1.default.find().lean();\n    const finisheditemStore = {};\n    allFinishedItem.forEach((f) => {\n        f.masterBom?.forEach((m) => {\n            const id = m.childPart?.id + \"\";\n            finisheditemStore[id] = {\n                finishedItemName: f.itemName\n            };\n        });\n    });\n    const childPartArray = [];\n    const allChildParts = await childPartModel_1.default.find().lean();\n    allChildParts.forEach((a) => {\n        const childPartId = a._id + \"\";\n        a.consumedItem.forEach((c) => {\n            if (c.itemId + \"\" === rawMaterial._id + \"\") {\n                childPartArray.push({\n                    ...a,\n                    finishItemName: finisheditemStore[childPartId]?.finishedItemName\n                });\n            }\n        });\n    });\n    resp.status(200).json({\n        success: true,\n        message: `Getting all childParts which consumed ${rawMaterial.partName}`,\n        childPartArray,\n    });\n});\n// // get all finished Item where the Raw material is used \n// export const getfinishedItemByRawMaterial = catchErrorAsync(async (req,resp,next)=>{\n//   const {id} = req.params;\n//   const rawmaterialDetails = await ChildPartModel.findById(id);\n//   if(!rawmaterialDetails){\n//     return resp.status(404).json({\n//       success:false,\n//       message:`Raw material not found with id ${id}.`\n//     });\n//   };\n//   const finishedItem = await \n// })\n// create a group\nexports.createGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupName, description } = req.body;\n    const groupDetails = await rawMaterialGroup_1.default.findOne({ groupName });\n    if (groupDetails) {\n        return resp.status(404).json({\n            success: false,\n            message: `Group with name ${groupName} already present.`\n        });\n    }\n    ;\n    const newGroup = await rawMaterialGroup_1.default.create({ groupName, description });\n    resp.status(201).json({\n        success: true,\n        message: `${groupName} group created successfully.`,\n        group: newGroup\n    });\n});\n// update group\nexports.updateGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId } = req.params;\n    const { groupName, description } = req.body;\n    const groupDetails = await rawMaterialGroup_1.default.findOne({ _id: groupId });\n    if (!groupDetails) {\n        return resp.status(404).json({\n            success: false,\n            message: `Group with name ${groupId} not found.`\n        });\n    }\n    ;\n    if (groupName) {\n        groupDetails.groupName = groupName;\n    }\n    if (description) {\n        groupDetails.description = description;\n    }\n    await groupDetails.save();\n    const rawMaterials = await childPartModel_1.default.find({ \"group.groupId\": groupDetails._id }).lean();\n    for (let r of rawMaterials) {\n        await childPartModel_1.default.findByIdAndUpdate(r._id, { \"group.groupName\": groupDetails.groupName });\n    }\n    resp.status(200).json({\n        success: true,\n        message: `${groupName} updated successfully.`,\n        group: groupDetails\n    });\n});\n// get all groups\nexports.getAllGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { sort, name } = req.body;\n    let query = {};\n    if (name) {\n        // Match 'name' against 'groupName', 'groupDescription'\n        query.$or = [\n            { groupName: { $regex: name, $options: \"i\" } },\n            { description: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    let groups;\n    if (sort) {\n        if (sort === \"asc\") {\n            groups = await rawMaterialGroup_1.default.find({ ...query }).sort({ groupName: 1 }).lean();\n        }\n        else if (sort === \"dec\") {\n            groups = await rawMaterialGroup_1.default.find({ ...query }).sort({ groupName: -1 }).lean();\n        }\n    }\n    else {\n        groups = await rawMaterialGroup_1.default.find({ ...query }).lean();\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Getting all group successfully.\",\n        groups\n    });\n});\n// DELETE GROUP\nexports.deleteGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId } = req.params;\n    const rawMaterials = await childPartModel_1.default.find({ 'group.groupId': groupId, childPartType: \"raw\" }).lean();\n    if (rawMaterials.length === 0) {\n        let group = await rawMaterialGroup_1.default.findByIdAndDelete({ _id: groupId }).lean();\n        if (!group) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Group Not Found\",\n            });\n        }\n        return resp.status(200).json({\n            success: true,\n            message: `${group.groupName} group deleted successfully`,\n        });\n    }\n    else {\n        const foundArray = rawMaterials.map(f => f.partName);\n        return resp.status(400).json({\n            success: false,\n            message: `Found somewhere includes this group`,\n            foundArray\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/rawMaterialController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/salaryReportController.ts":
/*!******************************************************************!*\
  !*** ./src/controllers/bomControllers/salaryReportController.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSinglePartCostReport = exports.getSalaryReport = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst v2attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/v2attendanceModel */ \"./src/database/models/v2attendanceModel.ts\"));\nexports.getSalaryReport = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { date } = req.body;\n    let startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n    let endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n    const attandenceEmployees = await v2attendanceModel_1.default.find({\n        date: {\n            $gte: startDate,\n            $lte: endDate,\n        },\n        productiveHours: {\n            $gt: 0,\n        }\n    }).select({ employeeId: 1, date: 1, shift: 1, productionSlipNumbers: 1, productiveHours: 1, punches: 1 }).lean();\n    const employeeIds = [];\n    const productionSlipNumbers = [];\n    const attandenceStore = {};\n    attandenceEmployees.forEach((a) => {\n        const startTime = new Date(a.punches[0].punchIn).getTime();\n        let endTime;\n        if (a.punches[a.punches.length - 1].punchOut) {\n            endTime = new Date(a.punches[a.punches.length - 1].punchOut).getTime();\n        }\n        else {\n            endTime = new Date().getTime();\n        }\n        attandenceStore[a.employeeId + \"\"] = {\n            productionSlipNumbers: a.productionSlipNumbers,\n            totalWorkingTime: (endTime - startTime) / (1000 * 60 * 60)\n        };\n        employeeIds.push(a.employeeId + \"\");\n        a.productionSlipNumbers.forEach((p) => {\n            !productionSlipNumbers.includes(p) && productionSlipNumbers.push(p);\n        });\n    });\n    const productionSlips = await productionSlipModel_1.default.find({\n        productionSlipNumber: {\n            $in: productionSlipNumbers\n        }\n    }).lean();\n    const productionSlipStore = {};\n    productionSlips.forEach(p => {\n        productionSlipStore[p.productionSlipNumber] = p;\n    });\n    const employees = await employeeModel_1.default.find({\n        _id: {\n            $in: employeeIds,\n        }\n    }).lean();\n    const result = [];\n    employees.forEach(e => {\n        let totalTimeSpend = 0;\n        const productionSlips = [];\n        attandenceStore[e._id].productionSlipNumbers.forEach((p) => {\n            if (productionSlipStore[p].status !== \"cancel\") {\n                let itemProduced = 0;\n                let timeSpend = 0;\n                const employeeIdsInThisSlip = [];\n                productionSlipStore[p].working.forEach((w) => {\n                    w.employees.forEach((eId) => {\n                        if (eId.employeeId + \"\" === e._id + \"\") {\n                            w.employees.forEach((emp) => {\n                                !employeeIdsInThisSlip.includes(emp.employeeId + \"\") && employeeIdsInThisSlip.push(emp.employeeId + \"\");\n                            });\n                            const startTime = new Date(w.startTime).getTime();\n                            const endTime = new Date(w.endTime).getTime();\n                            totalTimeSpend += (endTime - startTime) / (1000 * 60 * 60);\n                            timeSpend += (endTime - startTime) / (1000 * 60 * 60);\n                            itemProduced += w.itemProduced / w.employees.length;\n                        }\n                    });\n                });\n                productionSlips.push({\n                    partName: productionSlipStore[p].part.partName,\n                    partId: productionSlipStore[p].part._id,\n                    productionSlipnumber: p,\n                    timeSpend: timeSpend,\n                    itemProduced: itemProduced\n                });\n            }\n        });\n        // RATIO\n        let totalActualTime = 0;\n        productionSlips.forEach((p, i) => {\n            productionSlips[i].ratio = p.timeSpend / totalTimeSpend;\n            productionSlips[i].actualTime = (p.timeSpend / totalTimeSpend) * p.timeSpend;\n            productionSlips[i].ppe = p.itemProduced / ((p.timeSpend / totalTimeSpend) * p.timeSpend);\n            totalActualTime += (p.timeSpend / totalTimeSpend) * p.timeSpend;\n        });\n        // PER PEICE COST\n        productionSlips.forEach((p, i) => {\n            productionSlips[i].perPeiceCost = ((e.salary / 26) / totalActualTime) / productionSlips[i].ppe;\n        });\n        if (productionSlips.length > 0) {\n            result.push({\n                employeeId: e._id,\n                employeeName: e.name,\n                monthlySalary: e.salary,\n                perDaySalary: e.salary / 26,\n                productionSlips: productionSlips,\n                totalTimeSpend: totalTimeSpend,\n                totalActualTime: totalActualTime,\n                totalWorkingTime: attandenceStore[e._id].totalWorkingTime,\n                salaryPerActualHour: (e.salary / 26) / totalActualTime\n            });\n        }\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Salary Report fetch successfully\",\n        result\n    });\n});\n// SINGLE EMPLOYEE SALARY REPORT\nexports.getSinglePartCostReport = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { partId } = req.params;\n    const allProductionSlips = await productionSlipModel_1.default.find({}).lean();\n    const allEmployeeDetails = await employeeModel_1.default.find().lean();\n    const employeeSalaryStore = {};\n    allEmployeeDetails.forEach((e) => {\n        const id = e._id + \"\";\n        employeeSalaryStore[id] = {\n            salary: e.salary,\n            workingHours: e.workingHours\n        };\n    });\n    const productionSlipStore = {};\n    allProductionSlips.forEach((a) => {\n        const number = a.productionSlipNumber + \"\";\n        productionSlipStore[number] = { ...a };\n    });\n    const productionSlips = await productionSlipModel_1.default.find({ \"part._id\": partId, status: { $in: [\"completed\", \"cnc\"] }, itemProduced: { $gt: 0 } }).lean();\n    const result = [];\n    for (let p of productionSlips) {\n        const date = p.durationFrom;\n        const partId = p.part._id + \"\";\n        for (let w of p.working) {\n            for (let e of w.employees) {\n                const employeeId = e.employeeId + \"\";\n                const salary = employeeSalaryStore[employeeId].salary;\n                const workingHours = employeeSalaryStore[employeeId].workingHours;\n                const data = await employeeSalaryReport(employeeId, partId, date, productionSlipStore);\n                if (data) {\n                    const totalWorkingHours = data.totalWorkingHours;\n                    const perDaySalary = salary / 26;\n                    const perHourRate = (perDaySalary / workingHours);\n                    const totalSalary = perHourRate * totalWorkingHours;\n                    const perHourCost = (totalSalary / data.productiveTime);\n                    const perPartCost = perHourCost / data.perHourProduction;\n                    if (data.totalPartProduction > 0) {\n                        result.push({ ...data, employeeName: e.employeeName, employeeId, perHourCost, perPartCost, perDaySalary, monthlySalary: salary });\n                    }\n                    ;\n                }\n                ;\n            }\n            ;\n            ;\n        }\n        ;\n    }\n    ;\n    resp.status(200).json({\n        success: true,\n        message: \"getting data\",\n        result\n    });\n});\nconst employeeSalaryReport = async (employeeId, partId, date, productionSlipStore) => {\n    try {\n        const newDate = new Date(date);\n        newDate.setUTCHours(0, 0, 0, 0);\n        const nextDate = new Date(newDate);\n        nextDate.setDate(nextDate.getDate() + 1);\n        const attendance = await v2attendanceModel_1.default.findOne({\n            employeeId, date: {\n                $gte: newDate,\n                $lt: nextDate\n            }\n        }).lean();\n        if (!attendance) {\n            return;\n        }\n        ;\n        const firstPunchIn = new Date(attendance.punches[0].punchIn);\n        const lastPunchOut = new Date(attendance.punches[attendance.punches.length - 1]?.punchOut);\n        const secondlastPunchOut = new Date(attendance.punches[attendance.punches.length - 2]?.punchOut);\n        let totalWorkingHours;\n        if (lastPunchOut) {\n            totalWorkingHours = (lastPunchOut.getTime() - firstPunchIn.getTime()) / (1000 * 60 * 60);\n        }\n        else if (secondlastPunchOut) {\n            totalWorkingHours = (secondlastPunchOut.getTime() - firstPunchIn.getTime()) / (1000 * 60 * 60);\n        }\n        else {\n            totalWorkingHours = 0;\n        }\n        const productiveTime = attendance.productiveHours;\n        const productionSlipsNumbers = attendance.productionSlipNumbers;\n        const productionSlips = [];\n        if (!productionSlipsNumbers) {\n            return;\n        }\n        for (let p of productionSlipsNumbers) {\n            const data = productionSlipStore[p + \"\"];\n            if (data.status === \"completed\" || data.status === \"cnc\")\n                productionSlips.push(data);\n        }\n        ;\n        let totalTime = 0;\n        let totalPartProduction = 0;\n        let totalPartTime = 0;\n        const productionSlipNumbers = [];\n        for (let p of productionSlips) {\n            const PartId = p.part._id + \"\";\n            for (let w of p.working) {\n                const startTime = new Date(w.startTime);\n                const endTime = new Date(w.endTime);\n                const time = (endTime.getTime() - startTime.getTime()) / (60 * 60 * 1000);\n                const totalEmployee = w.employees.length;\n                for (let e of w.employees) {\n                    if ((e.employeeId + \"\" === employeeId) && PartId === partId + \"\") {\n                        totalPartTime += time;\n                        totalPartProduction += (w.itemProduced / totalEmployee);\n                        productionSlipNumbers.push(p.productionSlipNumber);\n                    }\n                }\n                ;\n                totalTime += time;\n            }\n            ;\n        }\n        ;\n        const ratio = totalPartTime / totalTime;\n        const actualTime = ratio * productiveTime;\n        const perHourProduction = totalPartProduction / actualTime;\n        return {\n            date: newDate,\n            totalTime,\n            totalPartProduction,\n            totalPartTime,\n            productiveTime,\n            actualTime,\n            ratio,\n            productionSlipNumbers,\n            totalWorkingHours,\n            perHourProduction,\n        };\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/salaryReportController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/shopController.ts":
/*!**********************************************************!*\
  !*** ./src/controllers/bomControllers/shopController.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deleteShop = exports.updateShop = exports.getSingleShop = exports.getAllShop = exports.addShop = void 0;\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\n// add a shop\nexports.addShop = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { shopName, shopCode, jobProfileName } = req.body;\n    shopName = shopName.trim();\n    shopCode = shopCode.trim();\n    const jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n    if (!jobProfile) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Job Profile not found.\"\n        });\n    }\n    const shop = await shopModel_1.default.findOne({ shopName });\n    if (shop) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Shop with same name is already presesnt.\"\n        });\n    }\n    const newShop = await shopModel_1.default.create({ shopName, shopCode, jobProfile: {\n            jobProfileId: jobProfile._id,\n            jobProfileName: jobProfile.jobProfileName\n        } });\n    resp.status(201).json({\n        success: true,\n        message: \"Shop created successfully.\",\n        newShop\n    });\n});\n// get all shops\nexports.getAllShop = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const shops = await shopModel_1.default.find();\n    resp.status(200).json({\n        success: true,\n        message: \"Getting all Shops successfully.\",\n        shops\n    });\n});\n// get single shops\nexports.getSingleShop = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const shop = await shopModel_1.default.findById({ _id: id });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting Shop successfully.\",\n        shop\n    });\n});\n// get update shops\nexports.updateShop = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const { shopName, shopCode, jobProfileName } = req.body;\n    let jobProfile;\n    let shop;\n    shop = await shopModel_1.default.findById({ _id: id });\n    if (!shop) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Shop not found.\"\n        });\n    }\n    if (shopName) {\n        shop.shopName = shopName;\n    }\n    if (shopCode) {\n        shop.shopCode = shopCode;\n    }\n    if (jobProfileName) {\n        jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n        if (!jobProfile) {\n            return resp.status(400).json({\n                success: false,\n                message: \"Jobprofile not found.\"\n            });\n        }\n        shop.jobProfile = {\n            jobProfileId: jobProfile._id,\n            jobProfileName: jobProfile.jobProfileName\n        };\n    }\n    await shop.save();\n    resp.status(200).json({\n        success: true,\n        message: \"Getting Shop successfully.\",\n        shop\n    });\n});\n// delete shop \nexports.deleteShop = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const shop = await shopModel_1.default.findById(id);\n    if (!shop) {\n        return resp.status(404).json({\n            success: false,\n            message: `Shop with Id ${id} not found.`\n        });\n    }\n    const alreadyUsed = [];\n    const processes = await globalProcessModel_1.default.find({ shop });\n    if (processes.length > 0) {\n        processes.forEach((p) => {\n            const string = p.processName;\n            alreadyUsed.push(string);\n        });\n    }\n    if (alreadyUsed.length > 0) {\n        return resp.status(405).json({\n            success: false,\n            message: \"Shop is used in processes.\",\n            alreadyUsed\n        });\n    }\n    else {\n        const shop = await shopModel_1.default.findByIdAndDelete({ _id: id });\n        return resp.json({\n            success: true,\n            message: `Shop with name ${shop?.shopName} deleted.`\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/shopController.ts?");

/***/ }),

/***/ "./src/controllers/bomControllers/workOrderController.ts":
/*!***************************************************************!*\
  !*** ./src/controllers/bomControllers/workOrderController.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.changeWorkOrderInProductionSlip = exports.updateProcessInWorkOrder = exports.getAllWorkOrderWithProductionSlip = exports.getAllWorkOrder = exports.getWorkOrder = exports.deleteWorkOrder = exports.updateConsumedItemInMasterBomb = exports.addChildPartInMasterBom = exports.updateInMasterBom = exports.updateWorkOrder = exports.addWorkOrder = void 0;\nconst customerModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/customerModel */ \"./src/database/models/customerModel.ts\"));\nconst finishedItemModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/finishedItemModel */ \"./src/database/models/finishedItemModel.ts\"));\nconst globalProcessModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/globalProcessModel */ \"./src/database/models/globalProcessModel.ts\"));\nconst workOrderModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workOrderModel */ \"./src/database/models/workOrderModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst finishedItemController_1 = __webpack_require__(/*! ./finishedItemController */ \"./src/controllers/bomControllers/finishedItemController.ts\");\nconst childPartModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/childPartModel */ \"./src/database/models/childPartModel.ts\"));\nconst godownModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/godownModel */ \"./src/database/models/godownModel.ts\"));\nconst productionSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/productionSlipModel */ \"./src/database/models/productionSlipModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nexports.addWorkOrder = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const id = req.params.finishedItemId;\n    const { orderQuantity, orderNumber } = req.body;\n    const finished = await finishedItemModel_1.default.findById(id);\n    if (finished?.bomCompleted == false) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Finished Item is not completed.\",\n        });\n    }\n    ;\n    const order = await workOrderModel_1.default.findOne({ orderNumber: orderNumber.trim() });\n    if (order) {\n        return resp.status(400).json({\n            success: false,\n            message: `Work order with number ${orderNumber} already present.`\n        });\n    }\n    ;\n    const childParts = await childPartModel_1.default.find({}).lean();\n    const childPartStore = {};\n    const godownStore = {};\n    childParts.forEach((c) => {\n        const id = c._id + \"\";\n        childPartStore[id] = {\n            ...c,\n        };\n    });\n    const godowns = await godownModel_1.default.find().lean();\n    godowns.forEach((g) => {\n        const id = g._id + \"\";\n        godownStore[id] = {\n            ...g,\n        };\n    });\n    const data = await (0, finishedItemController_1.getBomItemWithQuantity)(req, resp, id, orderQuantity);\n    if (!data) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Master Bom or finished Item not found.\",\n        });\n    }\n    const customer = await customerModel_1.default.findById({\n        _id: data.customer,\n    });\n    if (!customer) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Customer Not found.\",\n        });\n    }\n    const obj = {\n        date: new Date(),\n        orderNumber: orderNumber.trim(),\n        customerId: customer._id,\n        customerName: customer.customerName,\n        finishedItemId: id,\n        orderQuantity,\n        finishItemName: data.finishedItemName,\n        partCode: data.partCode,\n        MCode: data.MCode,\n        masterBom: data.items,\n    };\n    const workOrder = await workOrderModel_1.default.create({ ...obj });\n    workOrder.masterBom.forEach((w) => {\n        const id = w._id + \"\";\n        const childPartDetail = childPartStore[id];\n        const productionGodownId = childPartDetail.productionGodown + \"\";\n        const godownDetails = godownStore[productionGodownId];\n        w.productionGodownId = godownDetails._id;\n        w.productionGodownName = godownDetails.godownName;\n        w.newChild.forEach((d) => {\n            const id = d._id + \"\";\n            childPartDetail.consumedItem.forEach((c) => {\n                const id1 = c.itemId + \"\";\n                if (c.consumptionGodown) {\n                    const godownChild = godownStore[c.consumptionGodown];\n                    if (id == id1) {\n                        d.consumptionGodownId = godownChild._id;\n                        d.consumptionGodownName = godownChild.godownName;\n                        return;\n                    }\n                    ;\n                }\n                ;\n            });\n        });\n    });\n    await workOrder.save();\n    resp.status(200).json({\n        success: true,\n        message: \"Work Order created successfully\",\n        workOrder,\n        // masterBom: data.newFinishItem.items\n    });\n});\nexports.updateWorkOrder = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { orderQuantity, status } = req.body;\n    const workOrder = await workOrderModel_1.default.findById(id);\n    if (!workOrder) {\n        return resp.status(404).json({\n            success: false,\n            message: \"work order Not Found.\",\n        });\n    }\n    ;\n    const oldQuantity = workOrder.orderQuantity === 0 ? 1 : workOrder.orderQuantity;\n    if (status) {\n        workOrder.status = status;\n        if (status === \"cancel\") {\n            const productionSlips = await productionSlipModel_1.default.find({ workOrderId: workOrder._id });\n            for (let p of productionSlips) {\n                if (p.itemProduced > 0) {\n                    return resp.status(400).json({\n                        success: false,\n                        message: `This workOrder's slip is producing item Slip Number ${p.productionSlipNumber}.`\n                    });\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    if (orderQuantity !== undefined) {\n        if (orderQuantity === 0) {\n            workOrder.masterBom.forEach((d) => {\n                if (oldQuantity && d.numberOfItem) {\n                    d.numberOfItem = (d.numberOfItem / oldQuantity) * 1;\n                    if (d.newChild) {\n                        d.newChild.forEach((e) => {\n                            if (e.numberOfItem) {\n                                e.numberOfItem = (e.numberOfItem / oldQuantity || 0) * 1;\n                            }\n                        });\n                    }\n                    ;\n                }\n                ;\n            });\n        }\n        else {\n            workOrder.masterBom.forEach((d) => {\n                if (oldQuantity && d.numberOfItem) {\n                    d.numberOfItem = (d.numberOfItem / oldQuantity) * orderQuantity;\n                    if (d.newChild) {\n                        d.newChild.forEach((e) => {\n                            if (e.numberOfItem) {\n                                e.numberOfItem = (e.numberOfItem / oldQuantity) * orderQuantity;\n                            }\n                        });\n                    }\n                    ;\n                }\n                ;\n            });\n        }\n        workOrder.orderQuantity = orderQuantity;\n    }\n    ;\n    await workOrder.save();\n    resp.status(200).json({\n        success: true,\n        message: \"order quantity updated successFully.\",\n        workOrder,\n    });\n});\nexports.updateInMasterBom = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const { childPartId, consumedItems } = req.body;\n    const workOrder = await workOrderModel_1.default.findById(id).lean();\n    const consumedItemStore = {};\n    consumedItems.forEach((c) => {\n        const id = c._id + \"\";\n        consumedItemStore[id] = {\n            ...c,\n        };\n    });\n    let indexx;\n    workOrder?.masterBom.forEach((w, index) => {\n        if (w._id == childPartId) {\n            const numberOfItem = w.numberOfItem;\n            indexx = index;\n            w.newChild.forEach((c) => {\n                const id = c._id + \"\";\n                const newChild = consumedItemStore[id];\n                c.numberOfItem = newChild.numberOfItem * numberOfItem;\n            });\n        }\n    });\n    const workOrderBomRawStore = {};\n    const lastId = workOrder?.masterBom[workOrder?.masterBom.length - 1]._id + \"\";\n    workOrderBomRawStore[lastId] = {\n        ...workOrder?.masterBom[workOrder?.masterBom.length - 1],\n    };\n    workOrder?.masterBom.forEach((m) => {\n        if (m.newChild) {\n            m.newChild.forEach((n) => {\n                const id = n._id + \"\";\n                workOrderBomRawStore[id] = {\n                    ...n,\n                };\n            });\n        }\n    });\n    for (let i = indexx || 0; i >= 0; i--) {\n        const data = workOrder?.masterBom[i];\n        const id = data?._id + \"\";\n        const rawStore = workOrderBomRawStore[id];\n        const oldNumberOfItem = data?.numberOfItem || 1;\n        const newNumberOfItem = rawStore.numberOfItem;\n        if (data?.numberOfItem !== undefined) {\n            data.numberOfItem = rawStore.numberOfItem;\n        }\n        if (data?.newChild) {\n            data.newChild.forEach((d) => {\n                const id = d._id + \"\";\n                const storeData1 = workOrderBomRawStore[id];\n                if (d.numberOfItem) {\n                    const numberOfItem = (d.numberOfItem / oldNumberOfItem) * newNumberOfItem;\n                    storeData1.numberOfItem = numberOfItem;\n                    workOrderBomRawStore[id].numberOfItem = numberOfItem;\n                    d.numberOfItem = numberOfItem;\n                }\n            });\n        }\n    }\n    const newWorkOrder = await workOrderModel_1.default.findByIdAndUpdate(id, {\n        masterBom: workOrder?.masterBom,\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"order quantity updated successFully.\",\n        newWorkOrder,\n        workOrder,\n        workOrderBomRawStore,\n    });\n});\n// add child part in master bom\nexports.addChildPartInMasterBom = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const workOrder = await workOrderModel_1.default.findById(id);\n    const { processName, childPartName, productionGodown, itemConsumed, newIndex, } = req.body;\n    const allChildPart = await childPartModel_1.default.find().lean();\n    const childPartStore = {};\n    allChildPart.forEach((a) => {\n        const name = a.partName;\n        childPartStore[name] = {\n            ...a,\n        };\n    });\n    if (!workOrder) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Work order not found .\",\n        });\n    }\n    const childPart = await childPartModel_1.default.findOne({ partName: childPartName });\n    if (!childPart) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Child Part with this name already present.\",\n        });\n    }\n    ;\n    const godown = await godownModel_1.default.findOne({ godownName: productionGodown });\n    if (!godown) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Production godown not found.\",\n        });\n    }\n    const process = await globalProcessModel_1.default.findOne({\n        processName: processName,\n    });\n    if (!process) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Process not found.\",\n        });\n    }\n    const childArray = [];\n    // for checking childPart present or not\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n    });\n    itemConsumed.forEach((i) => {\n        const name = i.childPart;\n        const part = childPartStore[name];\n        if (!part) {\n            return resp.status(404).json({\n                success: false,\n                message: `Child Part with Name ${name} not found.`,\n            });\n        }\n        childArray.push({\n            ...part,\n            quantity: i.quantity,\n            consumptionGodown: i.consumptionGodown,\n        });\n    });\n    // const newChildPart = await ChildPartModel.create({\n    //   partName: childPartName,\n    //   productionGodown: godown?._id,\n    //   numberOfItem: 1,\n    // });\n    // childArray.forEach((c: any) => {\n    //   const itemId = c._id;\n    //   const itemName = c.partName;\n    //   const itemType = \"child part\";\n    //   const consumedItemQuantity = c.quantity;\n    //   const consumptionGodown = c.productionGodown;\n    //   newChildPart.consumedItem.push({\n    //     itemId,\n    //     itemName,\n    //     itemType,\n    //     consumedItemQuantity,\n    //     consumptionGodown,\n    //   });\n    // });\n    // await newChildPart.save();\n    const newChild = [];\n    childPart.consumedItem.forEach((n) => {\n        const obj = {\n            _id: n.itemId,\n            partName: n.itemName,\n            numberOfItem: n.consumedItemQuantity,\n        };\n        newChild.push(obj);\n    });\n    const newItem = {\n        _id: childPart._id,\n        process: process.processName,\n        partName: childPart.partName,\n        numberOfItem: 1,\n        itemProduced: 0,\n        newChild: newChild,\n    };\n    if (newIndex >= 0 && newIndex <= workOrder.masterBom.length) {\n        workOrder.masterBom.splice(newIndex, 0, newItem);\n    }\n    // await workOrder.save();\n    const data1 = await workOrderModel_1.default\n        .findByIdAndUpdate({ _id: workOrder._id }, { masterBom: workOrder.masterBom }).exec();\n    resp.status(200).json({\n        success: true,\n        message: \"Added item in workOrder.\",\n        data1,\n    });\n});\nconst updateConsumedItemInMasterBomb = async (req, resp, next) => {\n    try {\n        const { id } = req.params;\n        const { childPartId, childPartName, consumedItems } = req.body;\n        const workOrder = await workOrderModel_1.default.findById(id).lean();\n        const childPartStore = {};\n        const childParts = await childPartModel_1.default.find().lean();\n        childParts.forEach((c) => {\n            const id = c._id + \"\";\n            childPartStore[id] = {\n                ...c,\n            };\n        });\n        consumedItems.forEach((c) => {\n            if (c._id + \"\" === childPartId + \"\") {\n                return resp.status(400).json({\n                    success: false,\n                    message: `Child Part is consumming itself.`\n                });\n            }\n            ;\n        });\n        const childPart = await childPartModel_1.default.findById(childPartId);\n        if (childPartName) {\n            if (childPart) {\n                childPart.partName = childPartName;\n                await childPart.save();\n            }\n            ;\n        }\n        ;\n        console.log(consumedItems);\n        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        // const productionSlip = await ProductionSlipModel.find({\n        //   workOrderId: workOrder?._id,\n        //   \"part._id\": childPartId,\n        // }).lean();\n        // productionSlip.forEach(async (p) => {\n        //   const id = p._id + \"\";\n        //   const numberOfItems = p.numberOfItems;\n        //   const result: any = [];\n        //   p.consumedItem.forEach((c) => {\n        //     const id = c._id + \"\";\n        //     consumedItems.forEach((i: { _id: string; numberOfItem: number }) => {\n        //       const id1 = i._id + \"\";\n        //       if (id === id1) {\n        //         const obj = { ...c };\n        //         obj.numberOfItem = numberOfItems * i.numberOfItem;\n        //         result.push(obj);\n        //       }\n        //     });\n        //   });\n        //   const prd = await ProductionSlipModel.findByIdAndUpdate(\n        //     { _id: id },\n        //     { consumedItem: result } \n        //   );\n        //   if(childPartName){\n        //     if(prd){\n        //     prd.part.partName = childPartName;\n        //    };\n        //   };\n        // });\n        /////////////////////////////////////////////////////////////////////////////////////////////////////////\n        const arr = [];\n        const consumedItemStore = {};\n        consumedItems.forEach((c) => {\n            const id = c._id + \"\";\n            consumedItemStore[id] = {\n                ...c,\n            };\n            const obj = {\n                ...consumedItemStore[id],\n                ...childPartStore[id],\n            };\n            arr.push(obj);\n        });\n        let indexx;\n        workOrder?.masterBom.forEach((w, index) => {\n            if (w._id == childPartId) {\n                const numberOfItem = w.numberOfItem;\n                indexx = index;\n                arr.forEach((c) => {\n                    const id = c._id + \"\";\n                    const newChild = consumedItemStore[id];\n                    c.numberOfItem = newChild.numberOfItem * numberOfItem;\n                });\n                w.newChild = arr;\n            }\n            ;\n        });\n        const workOrderBomRawStore = {};\n        const lastId = workOrder?.masterBom[workOrder?.masterBom.length - 1]._id + \"\";\n        workOrderBomRawStore[lastId] = {\n            ...workOrder?.masterBom[workOrder?.masterBom.length - 1],\n        };\n        workOrder?.masterBom.forEach((m) => {\n            if (m.newChild) {\n                m.newChild.forEach((n) => {\n                    const id = n._id + \"\";\n                    workOrderBomRawStore[id] = {\n                        ...n,\n                    };\n                });\n            }\n            ;\n        });\n        for (let i = indexx || 0; i >= 0; i--) {\n            const data = workOrder?.masterBom[i];\n            const id = data?._id + \"\";\n            if (!workOrderBomRawStore[id]) {\n                continue;\n            }\n            ;\n            const rawStore = workOrderBomRawStore[id];\n            const oldNumberOfItem = data?.numberOfItem || 1;\n            const newNumberOfItem = rawStore?.numberOfItem;\n            if (data?.numberOfItem !== undefined) {\n                data.numberOfItem = rawStore.numberOfItem || oldNumberOfItem;\n            }\n            ;\n            if (data?.newChild) {\n                data.newChild.forEach((d) => {\n                    const id = d._id + \"\";\n                    const storeData1 = workOrderBomRawStore[id];\n                    if (d.numberOfItem) {\n                        const numberOfItem = (d.numberOfItem / oldNumberOfItem) * newNumberOfItem;\n                        storeData1.numberOfItem = numberOfItem;\n                        workOrderBomRawStore[id].numberOfItem = numberOfItem;\n                        d.numberOfItem = numberOfItem;\n                    }\n                    ;\n                });\n            }\n            ;\n        }\n        ;\n        const newWorkOrder = await workOrderModel_1.default.findByIdAndUpdate(id, {\n            masterBom: workOrder?.masterBom,\n        });\n        let newChilds;\n        newWorkOrder?.masterBom.forEach((m) => {\n            if (m._id + \"\" === childPartId + \"\") {\n                newChilds = m.newChild;\n            }\n            ;\n        });\n        const productionSlips = await productionSlipModel_1.default.find({\n            workOrderId: workOrder?._id,\n            \"part._id\": childPartId,\n        }).lean();\n        for (let i of productionSlips) {\n            await productionSlipModel_1.default.findByIdAndUpdate(i._id, { consumedItem: newChilds });\n        }\n        ;\n        resp.status(200).json({\n            success: true,\n            message: \"work order updated successFully.\",\n            workOrder,\n        });\n    }\n    catch (error) {\n        console.log(error);\n        resp.json({\n            error: error,\n        });\n    }\n};\nexports.updateConsumedItemInMasterBomb = updateConsumedItemInMasterBomb;\nexports.deleteWorkOrder = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const workOrder = await workOrderModel_1.default.findById(id);\n    if (workOrder) {\n        const workOrder = await workOrderModel_1.default.findByIdAndDelete(id);\n        return resp.status(201).json({\n            success: true,\n            message: \"work order delete successfully\",\n        });\n    }\n    else {\n        return resp.status(201).json({\n            success: false,\n            message: \"work order not found\",\n        });\n    }\n    ;\n});\nexports.getWorkOrder = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const workOrder = await workOrderModel_1.default.findById(id);\n    const processes = await globalProcessModel_1.default.find().lean();\n    const processStore = {};\n    processes.forEach((p) => {\n        const id = p._id + \"\";\n        processStore[id] = {\n            ...p\n        };\n    });\n    const childParts = await childPartModel_1.default.find().lean();\n    const childPartStore = {};\n    childParts.forEach((c) => {\n        const id = c._id + \"\";\n        childPartStore[id] = {\n            ...c\n        };\n    });\n    if (!workOrder) {\n        return resp.status(404).json({\n            success: false,\n            message: `Work order not found with ${id}.`\n        });\n    }\n    ;\n    const productionSlips = await productionSlipModel_1.default.find({ workOrderId: workOrder._id }).lean();\n    const productionSlipStore = {};\n    productionSlips.forEach((p) => {\n        const id = p.part._id + \"\";\n        if (!productionSlipStore[id]) {\n            productionSlipStore[id] = {\n                itemProduced: 0\n            };\n        }\n        ;\n        productionSlipStore[id].itemProduced += p.itemProduced;\n    });\n    workOrder.masterBom.forEach((m) => {\n        const partId = m._id + \"\";\n        const partDetails = childPartStore[partId];\n        const processId = m.processId + \"\";\n        const processDetails = processStore[processId];\n        if (processDetails) {\n            m.process = processDetails.processName;\n        }\n        ;\n        if (partDetails) {\n            m.partName = partDetails.partName;\n        }\n        ;\n        m.newChild.forEach((n) => {\n            const partId = n._id + \"\";\n            const partDetails = childPartStore[partId];\n            if (partDetails) {\n                n.partName = partDetails.partName;\n            }\n            ;\n        });\n    });\n    await workOrder.save();\n    const newWorkOrder = await workOrderModel_1.default.findById(workOrder._id).lean();\n    newWorkOrder.masterBom.forEach((m) => {\n        const id = m._id + \"\";\n        const remainingItems = (m.numberOfItem - productionSlipStore[id]?.itemProduced || 0);\n        m.remainingItems = remainingItems;\n    });\n    resp.status(200).json({\n        success: true,\n        message: `Getting work order successfully.`,\n        workOrder: newWorkOrder\n    });\n});\nexports.getAllWorkOrder = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { name, status, customer, sort, process, shop, date, nextDate } = req.query;\n    const query = {};\n    const processStore = {};\n    if (date) {\n        const newDate = new Date(date);\n        if (nextDate) {\n            const newNextDate = new Date(nextDate);\n            newNextDate.setDate(newNextDate.getDate() + 1);\n            query.createdAt = {\n                $gt: newDate,\n                $lte: newNextDate\n            };\n        }\n        else {\n            const newNextDate = new Date(newDate);\n            newNextDate.setDate(newNextDate.getDate() + 1);\n            query.createdAt = {\n                $gt: newDate,\n                $lte: newNextDate\n            };\n        }\n        ;\n    }\n    ;\n    if (shop) {\n        const shopDetails = await shopModel_1.default.findOne({ shopName: shop });\n        const process = await globalProcessModel_1.default\n            .find({ \"shop.shopId\": shopDetails?._id })\n            .lean();\n        if (!query[\"masterBom.processId\"]) {\n            query[\"masterBom.processId\"] = { $in: [] };\n        }\n        process.forEach((p) => {\n            const id = p.processName + \"\";\n            query[\"masterBom.processId\"].$in.push(p._id);\n            processStore[id] = {\n                _id: id,\n            };\n        });\n    }\n    ;\n    if (process) {\n        const processDetails = await globalProcessModel_1.default.findOne({\n            processName: process,\n        });\n        if (!query[\"masterBom.processId.$in\"]) {\n            query[\"masterBom.processId\"] = { $in: [] };\n        }\n        const id = processDetails?._id + \"\";\n        query[\"masterBom.processId\"].$in.push(processDetails?._id);\n        processStore[id] = {\n            _id: id,\n        };\n    }\n    ;\n    if (name) {\n        query.$or = [\n            { finishItemName: { $regex: name, $options: \"i\" } },\n            { MCode: { $regex: name, $options: \"i\" } },\n            { partCode: { $regex: name, $options: \"i\" } },\n            { orderNumber: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    ;\n    if (status) {\n        query.status = status;\n    }\n    ;\n    if (customer) {\n        query.customerName = customer;\n    }\n    ;\n    const allProductionSlips = await productionSlipModel_1.default.find({ status: { $in: [\"completed\", \"manual\", \"cnc\"] } }).lean();\n    const workOrderSlipStore = {};\n    allProductionSlips.forEach((a) => {\n        const id = a.workOrderId + \"\";\n        if (!workOrderSlipStore[id]) {\n            workOrderSlipStore[id] = {\n                slips: []\n            };\n        }\n        workOrderSlipStore[id].slips.push({ ...a });\n    });\n    if (req.employee || req.admin) {\n        let jobProfile;\n        if (req.employee) {\n            jobProfile = await jobProfileModel_1.default.findOne({\n                _id: req.employee?.jobProfileId,\n            });\n            if (!jobProfile) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Job profile not found with ID ${req.employee?.jobProfileId}.`,\n                });\n            }\n        }\n        ;\n        if (req.employee && jobProfile?.jobProfileName.toLowerCase() !== \"hr\") {\n            const shop = await shopModel_1.default.findOne({\n                \"jobProfile.jobProfileId\": jobProfile?._id,\n            });\n            if (!shop) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Shop not found for JobProfile ${jobProfile?.jobProfileName}`,\n                });\n            }\n            ;\n            const processes = await globalProcessModel_1.default\n                .find({ \"shop.shopId\": shop._id })\n                .lean();\n            if (processes.length === 0) {\n                return resp.status(404).json({\n                    success: false,\n                    message: `Processes not found for shop ${shop.shopName}`,\n                });\n            }\n            ;\n            const processStore = {};\n            processes.forEach((p) => {\n                const id = p._id + \"\";\n                processStore[id] = {\n                    ...p,\n                };\n            });\n            let workOrders;\n            if (sort === \"old\") {\n                workOrders = await workOrderModel_1.default.find(query).sort({ date: 1 }).lean();\n            }\n            else if (sort === \"new\") {\n                workOrders = await workOrderModel_1.default\n                    .find(query)\n                    .sort({ date: -1 })\n                    .lean();\n            }\n            else {\n                workOrders = await workOrderModel_1.default\n                    .find(query)\n                    .sort({ date: -1 })\n                    .lean();\n            }\n            const result = [];\n            workOrders.forEach((w) => {\n                const id = w._id + \"\";\n                const masterBom = [];\n                const length = w.masterBom.length - 2;\n                let totalFinishItem = 0;\n                let totalLoading = 0;\n                w.masterBom.forEach((m, i) => {\n                    const partId = m._id + \"\";\n                    if (i === length) {\n                        const productionSlips = workOrderSlipStore[id]?.slips;\n                        if (productionSlips) {\n                            productionSlips.forEach((p) => {\n                                if (partId === p.part._id + \"\") {\n                                    totalFinishItem += p.itemProduced || 0;\n                                }\n                                ;\n                            });\n                        }\n                        ;\n                    }\n                    else if (i === length + 1) {\n                        const productionSlips = workOrderSlipStore[id]?.slips;\n                        if (productionSlips) {\n                            productionSlips.forEach((p) => {\n                                if (partId === p.part._id + \"\") {\n                                    totalLoading += p.itemProduced || 0;\n                                }\n                                ;\n                            });\n                        }\n                        ;\n                    }\n                    ;\n                    const processId = m.processId + \"\";\n                    if (processStore[processId]) {\n                        masterBom.push({ ...m });\n                    }\n                });\n                const obj = {\n                    ...w, totalFinishItem, totalLoading\n                };\n                obj.masterBom = masterBom;\n                if (obj.masterBom.length > 0) {\n                    result.push(obj);\n                }\n            });\n            return resp.status(200).json({\n                success: true,\n                message: \"getting work order successfully\",\n                workOrder: result,\n                processes\n            });\n        }\n        else {\n            //------------------- Condition For admin-----------------//\n            let workOrder;\n            if (sort === \"old\") {\n                workOrder = await workOrderModel_1.default.find(query).sort({ date: 1 }).lean();\n            }\n            else if (sort === \"new\") {\n                workOrder = await workOrderModel_1.default\n                    .find(query)\n                    .sort({ date: -1 })\n                    .lean();\n            }\n            else {\n                workOrder = await workOrderModel_1.default\n                    .find(query)\n                    .sort({ date: -1 })\n                    .lean();\n            }\n            const result = [];\n            workOrder.forEach((w) => {\n                const id = w._id + \"\";\n                const masterBom = [];\n                const length = w.masterBom.length - 2;\n                let totalFinishItem = 0;\n                let totalLoading = 0;\n                w.masterBom.forEach((m, i) => {\n                    const partId = m._id + \"\";\n                    if (i === length) {\n                        const productionSlips = workOrderSlipStore[id]?.slips;\n                        if (productionSlips) {\n                            productionSlips.forEach((p) => {\n                                if (partId === p.part._id + \"\") {\n                                    totalFinishItem += p.itemProduced || 0;\n                                }\n                            });\n                        }\n                    }\n                    else if (i === length + 1) {\n                        const productionSlips = workOrderSlipStore[id]?.slips;\n                        if (productionSlips) {\n                            productionSlips.forEach((p) => {\n                                if (partId === p.part._id + \"\") {\n                                    totalLoading += p.itemProduced || 0;\n                                }\n                            });\n                        }\n                    }\n                });\n                const obj = {\n                    ...w, totalFinishItem, totalLoading\n                };\n                result.push(obj);\n            });\n            return resp.status(200).json({\n                success: true,\n                message: \"getting work order successfully\",\n                workOrder: result,\n            });\n        }\n        ;\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: `Login First.`,\n        });\n    }\n    ;\n});\nconst getAllWorkOrderWithProductionSlip = async (req, resp, next) => {\n    const workOrders = await workOrderModel_1.default.find().lean();\n    const allProductionSlip = await productionSlipModel_1.default.find().lean();\n    const productionSlipStore = {};\n    allProductionSlip.forEach((a) => {\n        const workOrderId = a.workOrderId + \"\";\n        if (productionSlipStore[workOrderId]) {\n            productionSlipStore[workOrderId].data.push({\n                productionSlipNumber: a.productionSlipNumber,\n                productionSlipId: a._id,\n                workOrderId: workOrderId,\n                status: a.status,\n            });\n        }\n        productionSlipStore[workOrderId] = {\n            data: [\n                {\n                    productionSlipNumber: a.productionSlipNumber,\n                    productionSlipId: a._id,\n                    workOrderId: workOrderId,\n                    status: a.status,\n                },\n            ],\n        };\n    });\n    const workOrderDetails = [];\n    workOrders.forEach((w) => {\n        const id = w._id + \"\";\n        const productionSlips = productionSlipStore[id];\n        const obj = {\n            workOrder: w.finishItemName,\n            workOrderNumber: w.orderNumber,\n            quantity: w.orderQuantity,\n            productionSlips,\n        };\n        workOrderDetails.push(obj);\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting data successfully.\",\n        workOrderDetails,\n    });\n};\nexports.getAllWorkOrderWithProductionSlip = getAllWorkOrderWithProductionSlip;\n// change process in workorder\nexports.updateProcessInWorkOrder = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const { newProcessName, childPartId } = req.body;\n    const newProcess = await globalProcessModel_1.default.findOne({ processName: newProcessName });\n    if (!newProcess) {\n        return resp.status(404).json({\n            success: false,\n            message: `process not found ${newProcessName}`\n        });\n    }\n    ;\n    const workOrder = await workOrderModel_1.default.findById(id);\n    if (!workOrder) {\n        return resp.status(404).json({\n            success: false,\n            message: `Work order not found with id ${id}.`\n        });\n    }\n    ;\n    workOrder.masterBom.forEach((w) => {\n        if (w._id + \"\" === childPartId + \"\") {\n            w.process = newProcess.processName;\n            w.processId = newProcess._id;\n        }\n    });\n    await workOrder.save();\n    const productionSlips = await productionSlipModel_1.default.find({ workOrderId: workOrder._id, \"part._id\": childPartId }).lean();\n    for (let i of productionSlips) {\n        const productionSlip = await productionSlipModel_1.default.findByIdAndUpdate(i._id, { \"process.processId\": newProcess._id, \"process.processName\": newProcess.processName });\n    }\n    resp.status(200).json({\n        success: true,\n        message: `Work order with number ${workOrder.orderNumber} updated.`,\n        workOrder\n    });\n});\nexports.changeWorkOrderInProductionSlip = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { oldWorkOrder, newWorkOrder } = req.body;\n    const newOrder = await workOrderModel_1.default.findOne({ _id: newWorkOrder });\n    if (!newOrder) {\n        return resp.status(404).json({\n            success: false,\n            message: `work order not found.`\n        });\n    }\n    ;\n    const workOrderId = newOrder._id;\n    const productionSlips = await productionSlipModel_1.default.find({ workOrderId: oldWorkOrder });\n    for (let p of productionSlips) {\n        await productionSlipModel_1.default.findByIdAndUpdate({ _id: p._id }, { workOrderId });\n    }\n    resp.status(200).json({\n        success: true\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/bomControllers/workOrderController.ts?");

/***/ }),

/***/ "./src/controllers/employee/LeaveController.ts":
/*!*****************************************************!*\
  !*** ./src/controllers/employee/LeaveController.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.approveGatePassRequestOrReject = exports.approveLeaveRequestOrReject = exports.updateGatePassRequestStatusAcceptedOrReject = exports.updateLeaveRequestStatusAcceptedOrReject = exports.getLeaveRequestByEmployee = exports.getApprovedLeaveRequest = exports.getAllLeaveAndGatePass = exports.getRejectedLeaveRequest = exports.getAcceptedLeaveRequest = exports.getPendingLeaveRequest = exports.requestLeave = void 0;\nconst leaveModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/leaveModel */ \"./src/database/models/leaveModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\n// request for leave\nexports.requestLeave = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        const { employeeId, from, to, gatePassTime, gatePassDate, message } = req.body;\n        try {\n            const employee = await employeeModel_1.default.findById(employeeId || req.employee?._id);\n            if (!employee) {\n                return next(new errorHandler_1.default(\"Employee not found\", 404));\n            }\n            let leave;\n            let fromHours;\n            let toHours;\n            let gatePassDateHours;\n            if (from && to) {\n                fromHours = new Date(from);\n                fromHours.setHours(0, 0, 0, 0);\n                toHours = new Date(to);\n                toHours.setHours(0, 0, 0, 0);\n            }\n            if (from && to) {\n                leave = await leaveModel_1.default.findOne({ employeeId: employee._id, from: fromHours, to: toHours });\n                if (leave) {\n                    return next(new errorHandler_1.default(\"Leave already present for this date interval\", 400));\n                }\n            }\n            if (gatePassDate) {\n                gatePassDateHours = new Date(gatePassDate);\n                gatePassDateHours.setHours(0, 0, 0, 0);\n            }\n            leave = await leaveModel_1.default.create({ employeeId: employee._id, appliedBy: req.admin?._id || req.employee?._id, appliedDate: new Date().setHours(0, 0, 0, 0) });\n            if (from && to) {\n                leave.from = fromHours;\n                leave.to = toHours;\n            }\n            else if (gatePassTime) {\n                leave.gatePassDate = gatePassDateHours;\n                leave.gatePassTime = gatePassTime;\n            }\n            leave.message = message;\n            leave.status = \"pending\";\n            await leave.save();\n            resp.status(200).json({\n                success: true,\n                message: \"Leave requested successfully.\",\n                leave: leave\n            });\n        }\n        catch (error) {\n            return next(new errorHandler_1.default(\"Failed to request leave\", 500));\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\n// getting all the leave request \nconst getPendingLeaveRequest = async (req, resp, next) => {\n    try {\n        // Checking the jobProfile Name\n        // let {groupName, jobProfileName, name } = req.query;\n        if (req.employee || req.admin) {\n            let employee = null;\n            let jobProfile = null;\n            if (req.employee) {\n                employee = await employeeModel_1.default.findById(req.employee._id).exec();\n                if (!employee) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Employee not found',\n                    });\n                }\n                jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n                if (!jobProfile) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Job profile not found',\n                    });\n                }\n            }\n            let { groupName, jobProfileName, name } = req.query;\n            const filter = {};\n            const filter1 = {};\n            // Add groupName filter if provided\n            if (groupName) {\n                const group = await groupModel_1.default.findOne({ groupName }).exec();\n                if (group) {\n                    filter.groupId = group._id;\n                }\n            }\n            // Add jobProfileId filter if provided\n            if (jobProfileName) {\n                const jobProfile = await jobProfileModel_1.default.findOne({\n                    jobProfileName: jobProfileName\n                });\n                if (jobProfile) {\n                    filter.jobProfileId = jobProfile._id;\n                }\n            }\n            if (name) {\n                filter.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n                filter1.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n            }\n            // Check if the employee is in the HR group or is an admin\n            const isHR = jobProfile?.jobProfileName === \"hr\";\n            const isAdmin = req.admin;\n            if (!isHR && !isAdmin) {\n                // Find employees in the same group with lower job rank\n                const groupEmployees = await employeeModel_1.default.aggregate([\n                    {\n                        $match: {\n                            ...filter1\n                        },\n                    },\n                    {\n                        $lookup: {\n                            from: 'jobprofiles',\n                            localField: 'jobProfileId',\n                            foreignField: '_id',\n                            as: 'jobProfile',\n                        },\n                    },\n                    {\n                        $unwind: '$jobProfile',\n                    },\n                    {\n                        $match: {\n                            'jobProfile.parentJobProfileId': jobProfile?._id,\n                        },\n                    },\n                ]).exec();\n                // Find pending leave requests for the selected employees\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allPendingRequest = await leaveModel_1.default.find({ employeeId: { $in: employeeIds }, status: 'pending', }).sort({ \"appliedDate\": -1 }).populate('employeeId').exec();\n                const newRecords = [];\n                for (let rec of allPendingRequest) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all leave requests',\n                    allPendingRequest: newRecords,\n                });\n            }\n            else {\n                const groupEmployees = await employeeModel_1.default.find(filter);\n                const employeeIds = groupEmployees.map((employee) => employee._id);\n                // If the employee is in HR or is an admin, get all pending leave requests\n                const allPendingRequest = await leaveModel_1.default.find({ employeeId: { $in: employeeIds }, status: 'pending' }).sort({ \"appliedDate\": -1 })\n                    .populate('employeeId')\n                    .exec();\n                const newRecords = [];\n                for (let rec of allPendingRequest) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all leave requests',\n                    allPendingRequest: newRecords,\n                });\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Login first\", 404));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n};\nexports.getPendingLeaveRequest = getPendingLeaveRequest;\n// export const getPendingGatePassRequest: RequestHandler<ParamsDictionary, any, any, Query> = async (req: CustomRequest<EmployeeDocument>, resp: Response, next: NextFunction): Promise<void> => {\n//   try {\n//     // Checking the jobProfile Name\n//     if (req.employee || req.admin) {\n//       let employee: EmployeeDocument | null = null;\n//       let jobProfile: JobProfileDocument | null = null;\n//       if (req.employee) {\n//         employee = await EmployeeModel.findById(req.employee._id).exec();\n//         if (!employee) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Employee not found',\n//           });\n//         }\n//         jobProfile = await JobProfileModel.findById(employee?.jobProfileId);\n//         if (!jobProfile) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Job profile not found',\n//           });\n//         }\n//       }\n//       let { groupName, jobProfileName, name } = req.query;\n//       const filter: any = {};\n//       const filter1: any = {};\n//       // Add groupName filter if provided\n//       if (groupName) {\n//         const group = await groupModel.findOne({ groupName }).exec();\n//         if (group) {\n//           filter.groupId = group._id;\n//         }\n//       }\n//       // Add jobProfileId filter if provided\n//       if (jobProfileName) {\n//         const jobProfile = await JobProfileModel.findOne({\n//           jobProfileName: jobProfileName\n//         });\n//         if (jobProfile) {\n//           filter.jobProfileId = jobProfile._id;\n//         }\n//       }\n//       if (name) {\n//         // Use a regular expression to perform case-insensitive search by name\n//         filter.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//         filter1.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//       }\n//       // Check if the employee is in the HR group or is an admin\n//       const isHR = jobProfile?.jobProfileName === \"hr\";\n//       const isAdmin = req.admin;\n//       if (!isHR && !isAdmin) {\n//         // Find employees in the same group with lower job rank\n//         const groupEmployees = await EmployeeModel.aggregate([\n//           {\n//             $match: {\n//               groupId: employee?.groupId,\n//               ...filter1\n//             },\n//           },\n//           {\n//             $lookup: {\n//               from: 'jobprofiles',\n//               localField: 'jobProfileId',\n//               foreignField: '_id',\n//               as: 'jobProfile',\n//             },\n//           },\n//           {\n//             $unwind: '$jobProfile',\n//           },\n//           {\n//             $match: {\n//               'jobProfile.parentJobProfileId': jobProfile?._id,\n//             },\n//           },\n//         ]).exec();\n//         // Find pending leave requests for the selected employees\n//         const employeeIds = groupEmployees.map((emp) => emp._id);\n//         const allPendingRequest = await LeaveModel.find({\n//           employeeId: { $in: employeeIds },\n//           'gatePass.status': 'pending',\n//         })\n//           .populate('employeeId')\n//           .exec();\n//         // Filter leave requests to include only those with approved leave periods\n//         const filteredPendingGatePass = allPendingRequest.filter((leave) =>\n//           leave.gatePass.some((period) => period.status === 'pending')\n//         );\n//         // Filter leave periods within each leave request to include only approved periods\n//         const pendingGatePassWithFilteredPeriods = filteredPendingGatePass.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'pending'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all leave requests',\n//           pendingGatePassWithFilteredPeriods,\n//         });\n//       } else {\n//         const groupEmployees = await EmployeeModel.find(filter)\n//         const employeeIds = groupEmployees.map((employee) => employee._id)\n//         const allPendingRequest = await LeaveModel.find({ employeeId: { $in: employeeIds }, 'gatePass.status': 'pending' })\n//           .populate('employeeId')\n//           .exec();\n//         const pendingGatePassWithFilteredPeriods = allPendingRequest.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'pending'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all leave requests',\n//           pendingGatePassWithFilteredPeriods,\n//         });\n//       }\n//     } else {\n//       return next(new ErrorHandler(\"Login first\", 404));\n//     }\n//   } catch (error: any) {\n//     // Handle any potential errors and return an error response\n//     resp.status(500).json({\n//       success: false,\n//       message: 'An error occurred',\n//       error: error.message,\n//     });\n//   }\n// };\n// get all accepted leave Request\nconst getAcceptedLeaveRequest = async (req, resp, next) => {\n    try {\n        // Checking the jobProfile Name\n        if (req.employee || req.admin) {\n            let employee = null;\n            let jobProfile = null;\n            if (req.employee) {\n                employee = await employeeModel_1.default.findById(req.employee._id).exec();\n                if (!employee) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Employee not found',\n                    });\n                }\n                jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n                if (!jobProfile) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Job profile not found',\n                    });\n                }\n            }\n            let { groupName, jobProfileName, name } = req.query;\n            const filter = {};\n            const filter1 = {};\n            // Add groupName filter if provided\n            if (groupName) {\n                const group = await groupModel_1.default.findOne({ groupName }).exec();\n                if (group) {\n                    filter.groupId = group._id;\n                }\n            }\n            // Add jobProfileId filter if provided\n            if (jobProfileName) {\n                const jobProfile = await jobProfileModel_1.default.findOne({\n                    jobProfileName: jobProfileName\n                });\n                if (jobProfile) {\n                    filter.jobProfileId = jobProfile._id;\n                }\n            }\n            if (name) {\n                filter.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n                filter1.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n            }\n            // Check if the employee is in the HR group or is an admin\n            const isHR = jobProfile?.jobProfileName === \"hr\";\n            const isAdmin = req.admin;\n            if (!isHR && !isAdmin) {\n                // Find employees in the same group with lower job rank\n                const groupEmployees = await employeeModel_1.default.aggregate([\n                    {\n                        $match: {\n                            ...filter1\n                        },\n                    },\n                    {\n                        $lookup: {\n                            from: 'jobprofiles',\n                            localField: 'jobProfileId',\n                            foreignField: '_id',\n                            as: 'jobProfile',\n                        },\n                    },\n                    {\n                        $unwind: '$jobProfile',\n                    },\n                    {\n                        $match: {\n                            'jobProfile.parentJobProfileId': jobProfile?._id,\n                        },\n                    },\n                ]).exec();\n                // Find pending leave requests for the selected employees\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allAcceptedRequest = await leaveModel_1.default.find({\n                    employeeId: { $in: employeeIds },\n                    status: 'accepted',\n                }).sort({ \"appliedDate\": -1 })\n                    .populate('employeeId').populate(\"acceptedBy\")\n                    .exec();\n                const newRecords = [];\n                for (let rec of allAcceptedRequest) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all leave requests',\n                    allAcceptedRequest: newRecords,\n                });\n            }\n            else {\n                const groupEmployees = await employeeModel_1.default.find(filter);\n                const employeeIds = groupEmployees.map((employee) => employee._id);\n                const allAcceptedRequest = await leaveModel_1.default.find({ employeeId: { $in: employeeIds }, status: 'accepted' })\n                    .sort({ \"appliedDate\": -1 }).populate('employeeId').populate(\"acceptedBy\")\n                    .exec();\n                const newRecords = [];\n                for (let rec of allAcceptedRequest) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all leave requests',\n                    allAcceptedRequest: newRecords,\n                });\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Login first\", 404));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n};\nexports.getAcceptedLeaveRequest = getAcceptedLeaveRequest;\n// get all rejected leave Request\nconst getRejectedLeaveRequest = async (req, resp, next) => {\n    try {\n        // Checking the jobProfile Name\n        if (req.employee || req.admin) {\n            let employee = null;\n            let jobProfile = null;\n            if (req.employee) {\n                employee = await employeeModel_1.default.findById(req.employee._id).exec();\n                if (!employee) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Employee not found',\n                    });\n                }\n                jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n                if (!jobProfile) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Job profile not found',\n                    });\n                }\n            }\n            let { name, groupName, jobProfileName, page, limit } = req.query;\n            const pge = page ? parseInt(page) : 1;\n            const lmt = limit ? parseInt(limit) : 20;\n            const filter = {};\n            const filter1 = {};\n            // Add groupName filter if provided\n            if (groupName) {\n                const group = await groupModel_1.default.findOne({ groupName }).exec();\n                if (group) {\n                    filter.groupId = group._id;\n                }\n            }\n            // Add jobProfileId filter if provided\n            if (jobProfileName) {\n                const jobProfile = await jobProfileModel_1.default.findOne({\n                    jobProfileName: jobProfileName\n                });\n                if (jobProfile) {\n                    filter.jobProfileId = jobProfile._id;\n                }\n            }\n            if (name) {\n                filter.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n                filter1.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n            }\n            // Check if the employee is in the HR group or is an admin\n            const isHR = jobProfile?.jobProfileName === \"hr\";\n            const isAdmin = req.admin;\n            if (!isHR && !isAdmin) {\n                // Find employees in the same group with lower job rank\n                const groupEmployees = await employeeModel_1.default.aggregate([\n                    {\n                        $match: {\n                            ...filter1\n                        },\n                    },\n                    {\n                        $lookup: {\n                            from: 'jobprofiles',\n                            localField: 'jobProfileId',\n                            foreignField: '_id',\n                            as: 'jobProfile',\n                        },\n                    },\n                    {\n                        $unwind: '$jobProfile',\n                    },\n                    {\n                        $match: {\n                            'jobProfile.parentJobProfileId': jobProfile?._id,\n                        },\n                    },\n                ]).exec();\n                // Find pending leave requests for the selected employees\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allAcceptedRequest = await leaveModel_1.default.find({\n                    employeeId: { $in: employeeIds },\n                    status: 'rejected',\n                }).sort({ appliedDate: -1 })\n                    .skip((pge - 1) * lmt)\n                    .limit(lmt)\n                    .populate('rejectedBy')\n                    .populate('employeeId')\n                    .exec();\n                const newRecords = [];\n                for (let rec of allAcceptedRequest) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all rejected leave requests',\n                    allRejectedLeave: newRecords,\n                });\n            }\n            else {\n                const groupEmployees = await employeeModel_1.default.find(filter);\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allAcceptedRequest = await leaveModel_1.default.find({ employeeId: { $in: employeeIds }, status: 'rejected' })\n                    .sort({ appliedDate: -1 })\n                    .skip((pge - 1) * lmt)\n                    .limit(lmt)\n                    .populate('rejectedBy')\n                    .populate('employeeId')\n                    .exec();\n                const newRecords = [];\n                for (let rec of allAcceptedRequest) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all rejected leave requests',\n                    allRejectedLeave: newRecords,\n                });\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Login first\", 404));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n};\nexports.getRejectedLeaveRequest = getRejectedLeaveRequest;\n// get all rejected leave Request\nconst getAllLeaveAndGatePass = async (req, resp, next) => {\n    try {\n        // Checking the jobProfile Name\n        if (req.employee || req.admin) {\n            let employee = null;\n            let jobProfile = null;\n            if (req.employee) {\n                employee = await employeeModel_1.default.findById(req.employee._id).exec();\n                if (!employee) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Employee not found',\n                    });\n                    return;\n                }\n                jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n                if (!jobProfile) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Job profile not found',\n                    });\n                    return;\n                }\n            }\n            let { name, groupName, jobProfileName, page, limit, status } = req.query;\n            const pge = page ? parseInt(page) : 1;\n            const lmt = limit ? parseInt(limit) : 20;\n            const filter = {};\n            const filter1 = {};\n            // Add groupName filter if provided\n            if (groupName) {\n                const group = await groupModel_1.default.findOne({ groupName }).exec();\n                if (group) {\n                    filter.groupId = group._id;\n                }\n            }\n            // Add jobProfileId filter if provided\n            if (jobProfileName) {\n                const jobProfile = await jobProfileModel_1.default.findOne({\n                    jobProfileName: jobProfileName\n                });\n                if (jobProfile) {\n                    filter.jobProfileId = jobProfile._id;\n                }\n            }\n            if (name) {\n                filter.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n                filter1.$or = [\n                    { name: { $regex: name, $options: \"i\" } },\n                    { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n                ];\n            }\n            // Check if the employee is in the HR group or is an admin\n            const isHR = jobProfile?.jobProfileName === \"hr\";\n            const isAdmin = req.admin;\n            if (!isHR && !isAdmin) {\n                // Find employees in the same group with lower job rank\n                const groupEmployees = await employeeModel_1.default.aggregate([\n                    {\n                        $match: {\n                            ...filter1\n                        },\n                    },\n                    {\n                        $lookup: {\n                            from: 'jobprofiles',\n                            localField: 'jobProfileId',\n                            foreignField: '_id',\n                            as: 'jobProfile',\n                        },\n                    },\n                    {\n                        $unwind: '$jobProfile',\n                    },\n                    {\n                        $match: {\n                            'jobProfile.parentJobProfileId': jobProfile?._id,\n                        },\n                    },\n                ]).exec();\n                // Find pending leave requests for the selected employees\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allLeaves = await leaveModel_1.default.find({\n                    employeeId: { $in: employeeIds }\n                }).sort({ appliedDate: -1 })\n                    .skip((pge - 1) * lmt)\n                    .limit(lmt)\n                    .populate(\"acceptedBy\").populate(\"rejectedBy\")\n                    .populate('employeeId')\n                    .exec();\n                const newRecords = [];\n                for (let rec of allLeaves) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all leave requests',\n                    allLeaves: newRecords,\n                });\n            }\n            else {\n                const groupEmployees = await employeeModel_1.default.find(filter);\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allLeaves = await leaveModel_1.default.find({ employeeId: { $in: employeeIds } })\n                    .sort({ appliedDate: -1 })\n                    .skip((pge - 1) * lmt)\n                    .limit(lmt)\n                    .populate(\"acceptedBy\")\n                    .populate(\"rejectedBy\")\n                    .populate('employeeId')\n                    .exec();\n                const newRecords = [];\n                for (let rec of allLeaves) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all leave requests',\n                    allLeaves: newRecords,\n                });\n            }\n        }\n        else {\n            return next(new errorHandler_1.default('Login first', 404));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n};\nexports.getAllLeaveAndGatePass = getAllLeaveAndGatePass;\n// get all accepted leave Request\n// export const getAcceptedGatePassRequest: RequestHandler<ParamsDictionary, any, any, Query> = async (req: CustomRequest<EmployeeDocument>, resp: Response, next: NextFunction): Promise<void> => {\n//   try {\n//     // Checking the jobProfile Name\n//     if (req.employee || req.admin) {\n//       let employee: EmployeeDocument | null = null;\n//       let jobProfile: JobProfileDocument | null = null;\n//       if (req.employee) {\n//         employee = await EmployeeModel.findById(req.employee._id).exec();\n//         if (!employee) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Employee not found',\n//           });\n//         }\n//         jobProfile = await JobProfileModel.findById(employee?.jobProfileId);\n//         if (!jobProfile) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Job profile not found',\n//           });\n//         }\n//       }\n//       let { groupName, jobProfileName, name } = req.query;\n//       const filter: any = {};\n//       const filter1: any = {};\n//       // Add groupName filter if provided\n//       if (groupName) {\n//         const group = await groupModel.findOne({ groupName }).exec();\n//         if (group) {\n//           filter.groupId = group._id;\n//         }\n//       }\n//       // Add jobProfileId filter if provided\n//       if (jobProfileName) {\n//         const jobProfile = await JobProfileModel.findOne({\n//           jobProfileName: jobProfileName\n//         });\n//         if (jobProfile) {\n//           filter.jobProfileId = jobProfile._id;\n//         }\n//       }\n//       if (name) {\n//         // Use a regular expression to perform case-insensitive search by name\n//         filter.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//         filter1.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//       }\n//       // Check if the employee is in the HR group or is an admin\n//       const isHR = jobProfile?.jobProfileName === \"hr\";\n//       const isAdmin = req.admin;\n//       if (!isHR && !isAdmin) {\n//         // Find employees in the same group with lower job rank\n//         const groupEmployees = await EmployeeModel.aggregate([\n//           {\n//             $match: {\n//               groupId: employee?.groupId,\n//               ...filter1\n//             },\n//           },\n//           {\n//             $lookup: {\n//               from: 'jobprofiles',\n//               localField: 'jobProfileId',\n//               foreignField: '_id',\n//               as: 'jobProfile',\n//             },\n//           },\n//           {\n//             $unwind: '$jobProfile',\n//           },\n//           {\n//             $match: {\n//               'jobProfile.parentJobProfileId': jobProfile?._id,\n//             },\n//           },\n//         ]).exec();\n//         // Find pending leave requests for the selected employees\n//         const employeeIds = groupEmployees.map((emp) => emp._id);\n//         const allAcceptedRequest = await LeaveModel.find({\n//           employeeId: { $in: employeeIds },\n//           'gatePass.status': 'accepted',\n//         })\n//           .populate('employeeId').populate('gatePass.acceptedBy')\n//           .exec();\n//         // Filter leave requests to include only those with approved leave periods\n//         const filteredAcceptedGatePass = allAcceptedRequest.filter((leave) =>\n//           leave.gatePass.some((period) => period.status === 'accepted')\n//         );\n//         // Filter leave periods within each leave request to include only approved periods\n//         const acceptedGatePassWithFilteredPeriods = filteredAcceptedGatePass.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'accepted'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all leave requests',\n//           acceptedGatePassWithFilteredPeriods,\n//         });\n//       } else {\n//         const groupEmployees = await EmployeeModel.find(filter);\n//         const employeeIds = groupEmployees.map((emp) => emp._id);\n//         // If the employee is in HR or is an admin, get all pending leave requests\n//         const allAcceptedRequest = await LeaveModel.find({ employeeId: { $in: employeeIds }, 'gatePass.status': 'accepted' })\n//           .populate('employeeId')\n//           .exec();\n//         const acceptedGatePassWithFilteredPeriods = allAcceptedRequest.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'accepted'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all leave requests',\n//           acceptedGatePassWithFilteredPeriods,\n//         });\n//       }\n//     } else {\n//       return next(new ErrorHandler(\"Login first\", 404));\n//     }\n//   } catch (error: any) {\n//     // Handle any potential errors and return an error response\n//     resp.status(500).json({\n//       success: false,\n//       message: 'An error occurred',\n//       error: error.message,\n//     });\n//   }\n// };\n// get all rejected leave Request\n// export const getRejectedGatePassRequest: RequestHandler<ParamsDictionary, any, any, Query> = async (req: CustomRequest<EmployeeDocument>, resp: Response, next: NextFunction): Promise<void> => {\n//   try {\n//     // Checking the jobProfile Name\n//     if (req.employee || req.admin) {\n//       let employee: EmployeeDocument | null = null;\n//       let jobProfile: JobProfileDocument | null = null;\n//       if (req.employee) {\n//         employee = await EmployeeModel.findById(req.employee._id).exec();\n//         if (!employee) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Employee not found',\n//           });\n//         }\n//         jobProfile = await JobProfileModel.findById(employee?.jobProfileId);\n//         if (!jobProfile) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Job profile not found',\n//           });\n//         }\n//       }\n//       let { name, groupName, jobProfileName, page, limit }: { name?: string, groupName?: string, jobProfileName?: string, page?: string, limit?: string } = req.query;\n//       const pge: number = page ? parseInt(page) : 1;\n//       const lmt: number = limit ? parseInt(limit) : 20;\n//       const filter: any = {};\n//       const filter1: any = {};\n//       // Add groupName filter if provided\n//       if (groupName) {\n//         const group = await groupModel.findOne({ groupName }).exec();\n//         if (group) {\n//           filter.groupId = group._id;\n//         }\n//       }\n//       // Add jobProfileId filter if provided\n//       if (jobProfileName) {\n//         const jobProfile = await JobProfileModel.findOne({\n//           jobProfileName: jobProfileName\n//         });\n//         if (jobProfile) {\n//           filter.jobProfileId = jobProfile._id;\n//         }\n//       }\n//       if (name) {\n//         // Use a regular expression to perform case-insensitive search by name\n//         filter.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//         filter1.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//       }\n//       // Check if the employee is in the HR group or is an admin\n//       const isHR = jobProfile?.jobProfileName === \"hr\";\n//       const isAdmin = req.admin;\n//       if (!isHR && !isAdmin) {\n//         // Find employees in the same group with lower job rank\n//         const groupEmployees = await EmployeeModel.aggregate([\n//           {\n//             $match: {\n//               groupId: employee?.groupId,\n//               ...filter1\n//             },\n//           },\n//           {\n//             $lookup: {\n//               from: 'jobprofiles',\n//               localField: 'jobProfileId',\n//               foreignField: '_id',\n//               as: 'jobProfile',\n//             },\n//           },\n//           {\n//             $unwind: '$jobProfile',\n//           },\n//           {\n//             $match: {\n//               'jobProfile.parentJobProfileId': jobProfile?._id,\n//             },\n//           },\n//         ]).exec();\n//         // Find pending leave requests for the selected employees\n//         const employeeIds = groupEmployees.map((emp) => emp._id);\n//         const allAcceptedRequest = await LeaveModel.find({\n//           employeeId: { $in: employeeIds },\n//           'gatePass.status': 'rejected',\n//         }).sort({ \"gatePass.date\": -1 })\n//           .skip((pge - 1) * lmt)\n//           .limit(lmt)\n//           .populate('gatePass.rejectedBy')\n//           .populate('employeeId')\n//           .exec();\n//         // Filter leave requests to include only those with approved leave periods\n//         const filteredAcceptedGatePass = allAcceptedRequest.filter((leave) =>\n//           leave.gatePass.some((period) => period.status === 'rejected')\n//         );\n//         // Filter leave periods within each leave request to include only approved periods\n//         const rejectedGatePassWithFilteredPeriods = filteredAcceptedGatePass.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'rejected'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all rejected gatepass',\n//           rejectedGatePassWithFilteredPeriods,\n//         });\n//       } else {\n//         const groupEmployees = await EmployeeModel.find(filter);\n//         const employeeIds = groupEmployees.map((emp) => emp._id);\n//         const allAcceptedRequest = await LeaveModel.find({ employeeId: { $in: employeeIds }, 'gatePass.status': 'rejected' })\n//         .sort({ \"gatePass.date\": -1 })\n//         .skip((pge - 1) * lmt)\n//         .limit(lmt)\n//         .populate('gatePass.rejectedBy')\n//         .populate('employeeId')\n//         .exec();\n//         const rejectedGatePassWithFilteredPeriods = allAcceptedRequest.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'rejected'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all rejected gatepass',\n//           rejectedGatePassWithFilteredPeriods,\n//         });\n//       }\n//     } else {\n//       return next(new ErrorHandler(\"Login first\", 404));\n//     }\n//   } catch (error: any) {\n//     // Handle any potential errors and return an error response\n//     resp.status(500).json({\n//       success: false,\n//       message: 'An error occurred',\n//       error: error.message,\n//     });\n//   }\n// };\n// getting  Approved  leaves \nconst getApprovedLeaveRequest = async (req, resp, next) => {\n    try {\n        let { name, groupName, jobProfileName, page, limit } = req.query;\n        const pge = page ? parseInt(page) : 1;\n        const lmt = limit ? parseInt(limit) : 20;\n        const filter = {};\n        const filter1 = {};\n        if (groupName) {\n            const group = await groupModel_1.default.findOne({ groupName });\n            if (group) {\n                filter.groupId = group._id;\n            }\n        }\n        if (jobProfileName) {\n            const jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n            if (jobProfile) {\n                filter.jobProfileId = jobProfile._id;\n            }\n        }\n        if (name) {\n            filter.$or = [\n                { name: { $regex: name, $options: \"i\" } },\n                { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n            ];\n            filter1.$or = [\n                { name: { $regex: name, $options: \"i\" } },\n                { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n            ];\n        }\n        if (req.employee || req.admin) {\n            let employee = null;\n            let jobProfile = null;\n            if (req.employee) {\n                employee = await employeeModel_1.default.findById(req.employee._id).exec();\n                if (!employee) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Employee not found',\n                    });\n                    return;\n                }\n                jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n                if (!jobProfile) {\n                    resp.status(404).json({\n                        success: false,\n                        message: 'Job profile not found',\n                    });\n                    return;\n                }\n            }\n            const isHR = jobProfile?.jobProfileName === \"hr\";\n            const isAdmin = req.admin;\n            if (!isHR && !isAdmin) {\n                // Find employees in the same group with lower job rank\n                const groupEmployees = await employeeModel_1.default.aggregate([\n                    {\n                        $match: {\n                            ...filter1\n                        },\n                    },\n                    {\n                        $lookup: {\n                            from: 'jobprofiles',\n                            localField: 'jobProfileId',\n                            foreignField: '_id',\n                            as: 'jobProfile',\n                        },\n                    },\n                    {\n                        $unwind: '$jobProfile',\n                    },\n                    {\n                        $match: {\n                            'jobProfile.parentJobProfileId': jobProfile?._id,\n                        },\n                    },\n                ]).exec();\n                const employeeIds = groupEmployees.map((emp) => emp._id);\n                const allLeaveRequests = await leaveModel_1.default.find({\n                    employeeId: { $in: employeeIds },\n                    status: \"approved\"\n                }).sort({ appliedDate: -1 })\n                    .skip((pge - 1) * lmt)\n                    .limit(lmt)\n                    .populate('employeeId')\n                    .populate(\"acceptedBy\")\n                    .exec();\n                const newRecords = [];\n                for (let rec of allLeaveRequests) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all approved leave requests',\n                    allApprovedLeave: newRecords,\n                });\n            }\n            else {\n                const groupEmployees = await employeeModel_1.default.find(filter);\n                const ids = groupEmployees.map((employee) => employee._id);\n                const allApprovedLeave = await leaveModel_1.default.find({\n                    employeeId: { $in: ids },\n                    status: \"approved\"\n                }).sort({ appliedDate: -1 })\n                    .skip((pge - 1) * lmt)\n                    .limit(lmt)\n                    .populate(\"acceptedBy\")\n                    .populate('employeeId').exec();\n                const newRecords = [];\n                for (let rec of allApprovedLeave) {\n                    const docs = await employeeDocsModel_1.default.findOne({ employeeId: rec.employeeId._id });\n                    if (docs) {\n                        const doc = { ...rec.toObject(), profilePicture: docs.profilePicture };\n                        newRecords.push(doc);\n                    }\n                    else {\n                        newRecords.push(rec);\n                    }\n                }\n                resp.status(200).json({\n                    success: true,\n                    message: 'Getting all approved leave requests',\n                    allApprovedLeave: newRecords,\n                });\n            }\n        }\n        else {\n            return next(new errorHandler_1.default('Login first', 404));\n        }\n    }\n    catch (error) {\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n};\nexports.getApprovedLeaveRequest = getApprovedLeaveRequest;\n// getting  Approved  gatepass\n// export const getApprovedGatePassRequest: RequestHandler<ParamsDictionary, any, any, Query> = async (req: CustomRequest<EmployeeDocument>, resp: Response, next: NextFunction): Promise<void> => {\n//   try {\n//     if (req.employee || req.admin) {\n//       let employee: EmployeeDocument | null = null;\n//       let jobProfile: JobProfileDocument | null = null;\n//       if (req.employee) {\n//         employee = await EmployeeModel.findById(req.employee._id).exec();\n//         if (!employee) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Employee not found',\n//           });\n//           return;\n//         }\n//         jobProfile = await JobProfileModel.findById(employee?.jobProfileId);\n//         if (!jobProfile) {\n//           resp.status(404).json({\n//             success: false,\n//             message: 'Job profile not found',\n//           });\n//           return;\n//         }\n//       }\n//       let { name, groupName, jobProfileName, page, limit }: { name?: string, groupName?: string, jobProfileName?: string, page?: string, limit?: string } = req.query;\n//       const pge: number = page ? parseInt(page) : 1;\n//       const lmt: number = limit ? parseInt(limit) : 20;\n//       const filter: any = {};\n//       const filter1: any = {};\n//       // Add groupName filter if provided\n//       if (groupName) {\n//         const group = await groupModel.findOne({ groupName }).exec();\n//         if (group) {\n//           filter.groupId = group._id;\n//         }\n//       }\n//       // Add jobProfileId filter if provided\n//       if (jobProfileName) {\n//         const jobProfile = await JobProfileModel.findOne({\n//           jobProfileName: jobProfileName\n//         });\n//         if (jobProfile) {\n//           filter.jobProfileId = jobProfile._id;\n//         }\n//       }\n//       if (name) {\n//         // Use a regular expression to perform case-insensitive search by name\n//         filter.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//         filter1.$or = [{ name: { $regex: name, $options: \"i\" } }];\n//       }\n//       const isHR = jobProfile?.jobProfileName == \"hr\";\n//       const isAdmin = req.admin;\n//       if (!isHR && !isAdmin) {\n//         // Find employees in the same group with lower job rank\n//         const groupEmployees = await EmployeeModel.aggregate([\n//           {\n//             $match: {\n//               groupId: employee?.groupId,\n//               ...filter1\n//             },\n//           },\n//           {\n//             $lookup: {\n//               from: 'jobprofiles',\n//               localField: 'jobProfileId',\n//               foreignField: '_id',\n//               as: 'jobProfile',\n//             },\n//           },\n//           {\n//             $unwind: '$jobProfile',\n//           },\n//           {\n//             $match: {\n//               'jobProfile.parentJobProfileId': jobProfile?._id,\n//             },\n//           },\n//         ]).exec();\n//         const employeeIds = groupEmployees.map((emp) => emp._id);\n//         const allLeaveRequests = await LeaveModel.find({\n//           employeeId: { $in: employeeIds },\n//         }).sort({ \"gatePass.date\": -1 })\n//           .skip((pge - 1) * lmt)\n//           .limit(lmt)\n//           .populate('employeeId')\n//           .populate('gatePass.acceptedBy')\n//           .exec();\n//         // Filter leave requests to include only those with approved leave periods\n//         const filteredApprovedLeave = allLeaveRequests.filter((leave) =>\n//           leave.gatePass.some((period) => period.status === 'approved')\n//         );\n//         // Filter leave periods within each leave request to include only approved periods\n//         const approvedGatePassWithFilteredPeriods = filteredApprovedLeave.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'approved'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all approved gate pass requests',\n//           approvedGatePassWithFilteredPeriods,\n//         });\n//       } else {\n//         const groupEmployees = await EmployeeModel.find(filter)\n//         const ids = groupEmployees.map((employee) => employee._id)\n//         const allApprovedGatePass = await LeaveModel.find({ employeeId: { $in: ids }, 'gatePass.status': 'approved' })\n//           .sort({ \"gatePass.date\": -1 })\n//           .skip((pge - 1) * lmt)\n//           .limit(lmt)\n//           .populate('gatePass.acceptedBy')  \n//           .populate('employeeId')\n//           .exec();\n//         const approvedGatePassWithFilteredPeriods = allApprovedGatePass.map((leave) => ({\n//           ...leave.toObject(),\n//           gatePass: leave.gatePass.filter((period) => period.status === 'approved'),\n//           fromTo: null\n//         }));\n//         resp.status(200).json({\n//           success: true,\n//           message: 'Getting all approved gate pass requests',\n//           approvedGatePassWithFilteredPeriods,\n//         });\n//       }\n//     } else {\n//       return next(new ErrorHandler('Login first', 404));\n//     }\n//   } catch (error: any) {\n//     resp.status(500).json({\n//       success: false,\n//       message: 'An error occurred',\n//       error: error.message,\n//     });\n//   }\n// };\n// get all leave request by  Employee\nexports.getLeaveRequestByEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (!req.employee) {\n        return next(new errorHandler_1.default(\"Login First\", 404));\n    }\n    const { page, limit } = req.query;\n    const pge = page ? parseInt(page) : 1;\n    const lmt = limit ? parseInt(limit) : 20;\n    const employeeId = req.employee._id;\n    const jobProfile = await jobProfileModel_1.default.findOne({ _id: req.employee.jobProfileId });\n    const leaves = await leaveModel_1.default.find({ employeeId }).populate(\"acceptedBy\").populate(\"rejectedBy\").sort({ appliedDate: -1 })\n        .skip((pge - 1) * lmt).exec();\n    const upperLevelEmployee = await employeeModel_1.default.findOne({ jobProfileId: jobProfile?.parentJobProfileId }).exec();\n    resp.status(200).json({\n        success: true,\n        message: \"Getting all the leaves successfully.\",\n        leaves,\n        upperLevelEmployee\n    });\n});\nfunction isIJobProfile(jobProfileId) {\n    return jobProfileId?.jobRank !== undefined;\n}\n// update leave request status to accepted\nexports.updateLeaveRequestStatusAcceptedOrReject = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeId, from, to, status, rejectedReason } = req.body;\n    try {\n        let employee = null;\n        let jobProfile = null;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Employee not found',\n                });\n                return;\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Job profile not found',\n                });\n                return;\n            }\n        }\n        // Check if the employee is in the HR group or is an admin\n        let isSuper = false;\n        const emp = await employeeModel_1.default.findOne({ _id: employeeId });\n        const jobProfile1 = await jobProfileModel_1.default.findOne({ _id: emp?.jobProfileId, parentJobProfileId: employee?.jobProfileId });\n        if ((jobProfile1?.parentJobProfileId)?.toString() === (employee?.jobProfileId)?.toString()) {\n            isSuper = true;\n        }\n        else {\n            isSuper = false;\n        }\n        const isHR = jobProfile?.jobProfileName === \"hr\";\n        const isAdmin = req.admin;\n        let fromHours;\n        let toHours;\n        fromHours = new Date(from);\n        fromHours.setHours(0, 0, 0, 0);\n        toHours = new Date(to);\n        toHours.setHours(0, 0, 0, 0);\n        if (isHR || isAdmin || isSuper) {\n            // Find leave requests for the selected employees\n            const leaveRequest = await leaveModel_1.default.findOne({\n                employeeId,\n                from: fromHours,\n                to: toHours\n            });\n            if (!leaveRequest) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Leave request not found',\n                });\n                return;\n            }\n            if (leaveRequest) {\n                leaveRequest.status = status;\n                if (status == \"accepted\") {\n                    leaveRequest.acceptedBy = req?.employee?._id || req.admin;\n                    leaveRequest.acceptedDate = new Date();\n                }\n                else if (status == \"rejected\") {\n                    leaveRequest.rejectedBy = req?.employee?._id || req.admin;\n                    leaveRequest.rejectedDate = new Date();\n                    leaveRequest.rejectedReason = rejectedReason;\n                }\n                await leaveRequest.save();\n                resp.status(200).json({\n                    success: true,\n                    message: 'Leave request accepted',\n                    leaveRequest\n                });\n            }\n            else {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Leave period not found',\n                });\n                return;\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Not authorized to accept leave requests\", 403));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n});\n// gatepass accept or reject\nexports.updateGatePassRequestStatusAcceptedOrReject = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeId, gatePassDate, gatePassTime, status, rejectedReason } = req.body;\n    try {\n        let employee = null;\n        let jobProfile = null;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Employee not found',\n                });\n                return;\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Job profile not found',\n                });\n                return;\n            }\n        }\n        let isSuper = false;\n        const emp = await employeeModel_1.default.findOne({ _id: employeeId });\n        const jobProfile1 = await jobProfileModel_1.default.findOne({ _id: emp?.jobProfileId, parentJobProfileId: employee?.jobProfileId });\n        if ((jobProfile1?.parentJobProfileId)?.toString() === (employee?.jobProfileId)?.toString()) {\n            isSuper = true;\n        }\n        else {\n            isSuper = false;\n        }\n        const gatePassDateHours = new Date(gatePassDate);\n        gatePassDateHours.setHours(0, 0, 0, 0);\n        const isHR = jobProfile?.jobProfileName === \"hr\";\n        const isAdmin = req.admin;\n        if (isHR || isAdmin || isSuper) {\n            // Find leave requests for the selected employees\n            const leaveRequest = await leaveModel_1.default.findOne({\n                employeeId,\n                gatePassDate: gatePassDateHours,\n                gatePassTime: gatePassTime\n            });\n            if (!leaveRequest) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'gatePass request not found',\n                });\n                return;\n            }\n            if (leaveRequest) {\n                if (status == \"accepted\") {\n                    leaveRequest.status = status;\n                    leaveRequest.acceptedBy = req?.employee?._id || req.admin;\n                    leaveRequest.acceptedDate = new Date();\n                }\n                else if (status == \"rejected\") {\n                    leaveRequest.status = status;\n                    leaveRequest.rejectedBy = req?.employee?._id || req.admin;\n                    leaveRequest.rejectedDate = new Date();\n                    leaveRequest.rejectedReason = rejectedReason;\n                }\n                await leaveRequest.save();\n                resp.status(200).json({\n                    success: true,\n                    message: `GatePass request updated to ${status}`,\n                    leaveRequest\n                });\n            }\n            else {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Gatepass period not found',\n                });\n                return;\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Not authorized to accept leave requests\", 403));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n});\n// update leave Request to Approved\nexports.approveLeaveRequestOrReject = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeId, from, to, status, rejectedReason } = req.body;\n    try {\n        let employee = null;\n        let jobProfile = null;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Employee not found',\n                });\n                return;\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Job profile not found',\n                });\n                return;\n            }\n        }\n        // Check if the employee is in the HR group or is an admin\n        const isHR = jobProfile?.jobProfileName === \"hr\";\n        const isAdmin = req.admin;\n        let fromHours;\n        let toHours;\n        fromHours = new Date(from);\n        fromHours.setHours(0, 0, 0, 0);\n        toHours = new Date(to);\n        toHours.setHours(0, 0, 0, 0);\n        if (isHR || isAdmin) {\n            // Find leave requests for the selected employees\n            const leaveRequest = await leaveModel_1.default.findOne({\n                employeeId,\n                from: new Date(from),\n                to: new Date(to),\n            });\n            if (!leaveRequest) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Leave request not found',\n                });\n                return;\n            }\n            if (leaveRequest) {\n                if (status == \"approved\") {\n                    leaveRequest.status = status; // set status to 'approved' instead of 'accepted'\n                    leaveRequest.approvedDate = new Date();\n                }\n                else if (status == \"rejected\") {\n                    leaveRequest.status = status; // set status to 'approved' instead of 'accepted'\n                    leaveRequest.rejectedDate = new Date();\n                    leaveRequest.rejectedReason = rejectedReason;\n                }\n                await leaveRequest.save();\n                resp.status(200).json({\n                    success: true,\n                    message: `Leave request ${status}`,\n                    leaveRequest\n                });\n            }\n            else {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Leave period not found',\n                });\n                return;\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Not authorized to approve leave requests\", 403));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n});\n// update leave Request to Approved\nexports.approveGatePassRequestOrReject = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeId, gatePassDate, gatePassTime, status, rejectedReason } = req.body;\n    try {\n        let employee = null;\n        let jobProfile = null;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Employee not found',\n                });\n                return;\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'Job profile not found',\n                });\n                return;\n            }\n        }\n        // Check if the employee is in the HR group or is an admin\n        const isHR = jobProfile?.jobProfileName === \"hr\";\n        const isAdmin = req.admin;\n        let gatePassHours = new Date(gatePassDate);\n        gatePassHours.setHours(0, 0, 0, 0);\n        if (isHR || isAdmin) {\n            // Find leave requests for the selected employees\n            const gatePassRequest = await leaveModel_1.default.findOne({\n                employeeId,\n                gatePassDate: gatePassHours,\n                gatePassTime: gatePassTime\n            });\n            if (!gatePassRequest) {\n                resp.status(404).json({\n                    success: false,\n                    message: 'GatePass request not found',\n                });\n                return;\n            }\n            if (gatePassRequest) {\n                if (status == \"approved\") {\n                    gatePassRequest.status = status; // set status to 'approved' or 'reject' instead of 'accepted'\n                    gatePassRequest.approvedDate = new Date();\n                }\n                else if (status == \"rejected\") {\n                    gatePassRequest.status = status; // set status to 'approved' or 'reject' instead of 'accepted'\n                    gatePassRequest.rejectedDate = new Date();\n                    gatePassRequest.rejectedReason = rejectedReason;\n                }\n                await gatePassRequest.save();\n                resp.status(200).json({\n                    success: true,\n                    message: `GatePass request ${status}`,\n                    gatePassRequest,\n                });\n            }\n            else {\n                resp.status(404).json({\n                    success: false,\n                    message: 'GatePass period not found',\n                });\n                return;\n            }\n        }\n        else {\n            return next(new errorHandler_1.default(\"Not authorized to approve leave requests\", 403));\n        }\n    }\n    catch (error) {\n        // Handle any potential errors and return an error response\n        resp.status(500).json({\n            success: false,\n            message: 'An error occurred',\n            error: error.message,\n        });\n    }\n});\n// // update leave Request to Approved\n// export const getAllLeavePerEmployee: RequestHandler<ParamsDictionary, any, any, Query> = catchErrorAsync(async (req: CustomRequest<EmployeeDocument>, resp: Response, next: NextFunction): Promise<void> => {\n//   const { employeeId, gatePassDate, gatePassTime, status } = req.body;\n//   try {\n//     let employee: EmployeeDocument | null = null;\n//     let jobProfile: JobProfileDocument | null = null;\n//     if (req.employee) {\n//       employee = await EmployeeModel.findById(req.employee._id).exec();\n//       if (!employee) {\n//         resp.status(404).json({\n//           success: false,\n//           message: 'Employee not found',\n//         });\n//         return;\n//       }\n//       jobProfile = await JobProfileModel.findById(employee?.jobProfileId);\n//       if (!jobProfile) {\n//         resp.status(404).json({\n//           success: false,\n//           message: 'Job profile not found',\n//         });\n//         return;\n//       }\n//     }\n//     // Check if the employee is in the HR group or is an admin\n//     const isHR = jobProfile?.jobProfileName === \"hr\";\n//     const isAdmin = req.admin;\n//     if (isHR || isAdmin) {\n//       // Find leave requests for the selected employees\n//       const gatePassRequest = await LeaveModel.findOne({\n//         employeeId,\n//         'gatePass.date': new Date(gatePassDate),\n//         'gatePass.time': gatePassTime,\n//         'gatePass.status': 'accepted'\n//       });\n//       if (!gatePassRequest) {\n//         resp.status(404).json({\n//           success: false,\n//           message: 'GatePass request not found',\n//         });\n//         return;\n//       }\n//       const leavePeriod = gatePassRequest.gatePass.find(leave => leave.date.toISOString().slice(0, 10) === gatePassDate && leave.time === gatePassTime);\n//       if (leavePeriod) {\n//         if (status == \"approved\") {\n//           leavePeriod.status = status; // set status to 'approved' or 'reject' instead of 'accepted'\n//           leavePeriod.approvedDate = new Date();\n//         } else if (status == \"approved\") {\n//           leavePeriod.status = status; // set status to 'approved' or 'reject' instead of 'accepted'\n//           leavePeriod.rejectedDate = new Date();\n//         }\n//         await gatePassRequest.save();\n//         resp.status(200).json({\n//           success: true,\n//           message: 'GatePass request approved',\n//           gatePassRequest,\n//         });\n//       } else {\n//         resp.status(404).json({\n//           success: false,\n//           message: 'GatePass period not found',\n//         });\n//         return;\n//       }\n//     } else {\n//       return next(new ErrorHandler(\"Not authorized to approve leave requests\", 403));\n//     }\n//   } catch (error: any) {\n//     // Handle any potential errors and return an error response\n//     resp.status(500).json({\n//       success: false,\n//       message: 'An error occurred',\n//       error: error.message,\n//     });\n//   }\n// });\n// get leave records\n// export const getLeaveData: RequestHandler<ParamsDictionary, any, any, Query> = async (\n//   req: Request,\n//   resp: Response,\n//   next: NextFunction\n// ): Promise<void> => {\n//   try {\n//     const { name, groupName, jobProfileName } = req.query;\n//     let filters: any = {};\n//     if (name) {\n//       filters['name'] = { $regex: new RegExp(String(name), 'i') };\n//     }\n//     if (groupName) {\n//       const group = await groupModel.findOne({ groupName })\n//       if (group) {\n//         filters['groupId'] = String(group._id);\n//       }\n//     }\n//     if (jobProfileName) {\n//       const jobProfile = await JobProfileModel.findOne({ jobProfileName });\n//       if (jobProfile) {\n//         filters['jobProfileId'] = String(jobProfile._id);\n//       }\n//     }\n//     const employees = await EmployeeModel.find(filters).exec();\n//     const employeeIds = employees.map((employee) => employee._id);\n//     const leaveData = await LeaveModel.find({ employeeId: { $in: employeeIds } })\n//       .exec();\n//     const result: any[] = [];\n//     for (const leave of leaveData) {\n//       const employee = leave.employeeId;\n//       const employeeDetails = await EmployeeModel.findById({ _id: employee })\n//       const leaveRecords = leave.fromTo.map((record) => ({\n//         appliedDate: record.appliedDate,\n//         from: record.from,\n//         to: record.to,\n//         message: record.message,\n//         status: record.status,\n//         acceptedDate: record.acceptedDate,\n//         acceptedBy: record.acceptedBy,\n//         rejectedDate: record.rejectedDate,\n//         rejectedBy: record.rejectedBy,\n//         approvedDate: record.approvedDate,\n//       }));\n//       const gatePassRecords = leave.gatePass.map((record) => ({\n//         date: record.date,\n//         time: record.time,\n//         status: record.status,\n//         acceptedDate: record.acceptedDate,\n//         acceptedBy: record.acceptedBy,\n//         rejectedDate: record.rejectedDate,\n//         rejectedBy: record.rejectedBy,\n//         approvedDate: record.approvedDate,\n//       }));\n//       result.push({\n//         employeeDetails,\n//         leaveRecords,\n//         gatePassRecords,\n//       });\n//     }\n//     resp.status(200).json({\n//       success: true,\n//       message: 'Getting leave data with filters',\n//       leaveData: result,\n//     });\n//   } catch (error: any) {\n//     resp.status(500).json({\n//       success: false,\n//       message: 'An error occurred',\n//       error: error.message,\n//     });\n//   }\n// };\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/LeaveController.ts?");

/***/ }),

/***/ "./src/controllers/employee/activeController.ts":
/*!******************************************************!*\
  !*** ./src/controllers/employee/activeController.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.changeActiveStatus = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst v2attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/v2attendanceModel */ \"./src/database/models/v2attendanceModel.ts\"));\nexports.changeActiveStatus = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    try {\n        const employees = await employeeModel_1.default.find({});\n        if (employees && employees.length > 0) {\n            const currentDate = new Date();\n            currentDate.setHours(0, 0, 0, 0);\n            const twentyDaysAgo = new Date(currentDate.getTime());\n            twentyDaysAgo.setDate(currentDate.getDate() - 20);\n            twentyDaysAgo.setHours(0, 0, 0, 0);\n            for (const emp of employees) {\n                const attendanceRecords = await v2attendanceModel_1.default.find({\n                    employeeId: emp._id,\n                    date: {\n                        $gt: twentyDaysAgo,\n                        $lt: currentDate,\n                    },\n                });\n                //console.log(emp.name,attendanceRecords.length )\n                if (attendanceRecords.length === 0) {\n                    emp.BarCodeStatus = false;\n                    emp.active = false;\n                }\n                await emp.save();\n                //console.log(\"Api called\")\n            }\n            res.status(200).json({\n                success: true,\n                message: \"Employee Active Status Changed.\",\n            });\n        }\n        else {\n            res.status(200).json({\n                success: true,\n                message: \"No employees found to update.\",\n            });\n        }\n    }\n    catch (error) {\n        // Handle any errors, for example, using 'next' middleware.\n        next(error);\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/activeController.ts?");

/***/ }),

/***/ "./src/controllers/employee/attendanceController.ts":
/*!**********************************************************!*\
  !*** ./src/controllers/employee/attendanceController.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFirstPunchInLastPunchOut = exports.employeeStaffAttendance = exports.singleEmployeeAttendance = exports.myAttendance = exports.getGroupRecordPerDay = exports.getPunchRecords = exports.getGroupPunchRecords = exports.absentAndPresentEmployee = exports.updateAttendance = exports.markAttendanceWithEmployeeId = exports.getEmployeeByQRCode = void 0;\nconst attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/attendanceModel */ \"./src/database/models/attendanceModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst QRCode = __importStar(__webpack_require__(/*! qrcode */ \"qrcode\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst department_1 = __importDefault(__webpack_require__(/*! ../../database/models/department */ \"./src/database/models/department.ts\"));\n// Scan The QR code And attendance get marked\nexports.getEmployeeByQRCode = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById({\n            _id: req.employee.jobProfileId,\n        });\n    }\n    const { data } = req.body;\n    let qrCode;\n    try {\n        qrCode = await QRCode.toDataURL(data); // Using email as an example\n    }\n    catch (err) {\n        return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n    }\n    if (req.admin ||\n        jobProfile?.isSupervisor ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee = await employeeModel_1.default.findOne({ currentBarCode: qrCode });\n        let employee1 = await employeeModel_1.default.findOne({ permanentBarCode: qrCode });\n        if (!employee && !employee1) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        if (employee1) {\n            employee = employee1;\n        }\n        let docs = await employeeDocsModel_1.default.findOne({ employeeId: employee?._id });\n        let date = new Date();\n        let nextDay;\n        date = new Date(date);\n        date.setHours(0, 0, 0, 0);\n        date.setHours(date.getHours() - 6);\n        nextDay = new Date(date);\n        nextDay.setDate(nextDay.getDate() + 2);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() - 6);\n        let attendanceRecord = await attendanceModel_1.default.findOne({\n            employeeId: employee?._id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n        });\n        let message = \"\";\n        let length = attendanceRecord?.punches\n            ? attendanceRecord?.punches.length - 1\n            : 0;\n        if (attendanceRecord?.punches[length].punchOut) {\n            message = \"Punch In\";\n        }\n        else if (!attendanceRecord) {\n            message = \"Punch In\";\n        }\n        else {\n            message = \"Punch Out\";\n        }\n        let profilePicture;\n        if (docs) {\n            profilePicture = docs.profilePicture;\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"getting employee data successfully.\",\n            employee,\n            profilePicture: profilePicture,\n            docs: docs,\n            punch: message,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security .\",\n        });\n    }\n});\n// mark attendance by employee\nexports.markAttendanceWithEmployeeId = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById(req.employee.jobProfileId);\n    }\n    let lastPunchOut;\n    let lastPunchIn;\n    const { id } = req.body;\n    let date = new Date();\n    let nextDay;\n    date = new Date(date);\n    date.setHours(0, 0, 0, 0);\n    date.setHours(date.getHours() - (6 + 5.5));\n    nextDay = new Date(date);\n    nextDay.setDate(nextDay.getDate() + 3);\n    nextDay.setHours(0, 0, 0, 0);\n    nextDay.setHours(nextDay.getHours() - (6 + 5.5));\n    console.log(date, nextDay);\n    let message = ``;\n    if (req.admin ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee = await employeeModel_1.default.findOne({ _id: id })\n            .populate(\"jobProfileId\")\n            .populate(\"groupId\")\n            .exec();\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        const currentDate = new Date();\n        console.log(currentDate.getHours(), currentDate.getDate());\n        let attendanceRecord = await attendanceModel_1.default.findOne({\n            employeeId: employee?._id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n        });\n        if (!attendanceRecord) {\n            attendanceRecord = new attendanceModel_1.default({\n                employeeId: employee?._id,\n                date: currentDate,\n                punches: [\n                    {\n                        employeeId: employee?._id,\n                        punchIn: new Date(),\n                        punchInBy: req.employee?._id || req.admin?._id,\n                        status: \"pending\",\n                    },\n                ],\n                isPresent: true,\n            });\n            message = `Attendance punch In successfully.`;\n        }\n        else {\n            let attDate = new Date(attendanceRecord.date);\n            // condition added for night shift\n            if (currentDate.getDate() !== attDate.getDate() &&\n                currentDate.getHours() > 18) {\n                attendanceRecord = new attendanceModel_1.default({\n                    employeeId: employee?._id,\n                    date: currentDate,\n                    punches: [\n                        {\n                            employeeId: employee?._id,\n                            punchIn: new Date(),\n                            punchInBy: req.employee?._id || req.admin?._id,\n                            status: \"pending\",\n                        },\n                    ],\n                    isPresent: true,\n                });\n                message = `Attendance punch In successfully.`;\n                return resp.status(200).json({\n                    success: true,\n                    message,\n                    attendance: attendanceRecord,\n                    employee,\n                });\n            }\n            const todayAttendance = attendanceRecord.punches;\n            if (!todayAttendance) {\n                attendanceRecord.punches.push({\n                    punchIn: new Date(),\n                    punchInBy: req.employee?._id || req.admin?._id,\n                    status: \"pending\",\n                });\n                message = `Attendance punch In successfully.`;\n            }\n            else {\n                const lastPunch = todayAttendance[todayAttendance.length - 1];\n                if (lastPunch && lastPunch.punchOut) {\n                    // attendanceRecord.punches.push({\n                    //   employeeId: employee?._id,\n                    //   punchIn: new Date(),\n                    //   punchInBy: req.employee?._id || req.admin?._id,\n                    //   status: \"approved\",\n                    // });\n                    const hasApprovedRecords = todayAttendance.some((record) => record.status === \"approved\");\n                    const newPunch = {\n                        employeeId: employee?._id,\n                        punchIn: new Date(),\n                        punchInBy: req.employee?._id || req.admin?._id,\n                        status: hasApprovedRecords ? \"approved\" : \"pending\",\n                    };\n                    attendanceRecord.punches.push(newPunch);\n                    message = `Attendance punch In successfully.1`;\n                }\n                else {\n                    lastPunch.punchOut = new Date();\n                    lastPunch.punchOutBy = req.employee?._id || req.admin?._id;\n                    message = `Attendance punch Out successfully.`;\n                    // Calculate the working hours for the current day\n                    lastPunchIn = new Date(lastPunch.punchIn);\n                    lastPunchOut = new Date(lastPunch.punchOut);\n                    if (lastPunch.status == \"approved\") {\n                        const punchIn = new Date(lastPunch.punchIn);\n                        const punchOut = new Date(lastPunch.punchOut);\n                        const workingHours = (punchOut.getTime() - punchIn.getTime()) / (1000 * 60 * 60); // Convert milliseconds to hours\n                        attendanceRecord.workingHours += workingHours;\n                    }\n                    else {\n                        const punchIn = new Date(lastPunch.punchIn);\n                        const punchOut = new Date(lastPunch.punchOut);\n                        const workingHours = (punchOut.getTime() - punchIn.getTime()) / (1000 * 60 * 60); // Convert milliseconds to hours\n                        attendanceRecord.pendingHours += workingHours;\n                    }\n                }\n            }\n            attendanceRecord.isPresent = true;\n        }\n        const ratePerHour = employee.salary / (employee.workingDays * 4.3 * employee.workingHours);\n        if (attendanceRecord.workingHours <= 4) {\n            attendanceRecord.totalEarning =\n                ratePerHour * attendanceRecord.workingHours;\n        }\n        else {\n            //   if(lastPunchOut?.getHours() === 14 && lastPunchOut?.getMinutes() >= 0 ){\n            //     if(lastPunchIn?.getHours() === 14 && lastPunchIn?.getMinutes() >= 0 ){\n            //      let freeTime= (lastPunchOut.getTime() - lastPunchIn.getTime()) / (1000 * 60 * 60);\n            //     attendanceRecord.totalEarning = ratePerHour * (attendanceRecord.workingHours - employee.lunchTime +freeTime);\n            //   }else{\n            //     let freeTime= (lastPunchOut.getTime() - {should be equal to 15}) / (1000 * 60 * 60);\n            //     attendanceRecord.totalEarning = ratePerHour * (attendanceRecord.workingHours - employee.lunchTime +freeTime);\n            //   }\n            // }else{\n            //      attendanceRecord.totalEarning = ratePerHour * (attendanceRecord.workingHours - employee.lunchTime);\n            //   }\n            if (attendanceRecord.workingHours > 0) {\n                attendanceRecord.workingHours += attendanceRecord.pendingHours;\n                attendanceRecord.pendingHours = 0;\n            }\n            attendanceRecord.totalEarning =\n                ratePerHour * (attendanceRecord.workingHours - employee.lunchTime);\n        }\n        if (!employee.overTime) {\n            if (attendanceRecord.workingHours > employee.workingHours) {\n                attendanceRecord.totalEarning = ratePerHour * employee.workingHours; //- employee.lunchTime)\n            }\n        }\n        await attendanceRecord.save();\n        resp.status(200).json({\n            success: true,\n            message,\n            attendance: attendanceRecord,\n            employee,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security or admin or hr.\",\n        });\n    }\n});\n// approve or reject attendance\nexports.updateAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let employee = null;\n        let approverId;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            approverId = employee?._id;\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Employee not found\",\n                });\n            }\n        }\n        else {\n            approverId = req.admin?._id;\n        }\n        // Check if the employee is in the HR group or is an admin\n        // const {date}:{date?:string} = req.query;\n        let { employeeId, status, punchInTime, date } = req.body;\n        let nextDay;\n        if (date) {\n            date = new Date(date);\n            date.setHours(0, 0, 0, 0);\n            date.setHours(date.getHours() - (6 + 5.5));\n            nextDay = new Date(date);\n            nextDay.setDate(nextDay.getDate() + 3);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setHours(nextDay.getHours() - (6 + 5.5));\n        }\n        console.log(date, nextDay);\n        const employee1 = await employeeModel_1.default.findById(employeeId);\n        if (!employee1) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        const punchIn = new Date(punchInTime);\n        const attendanceRecord = await attendanceModel_1.default.findOne({\n            employeeId,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n        });\n        if (!attendanceRecord) {\n            return next(new errorHandler_1.default(\"Attendance record not found.\", 404));\n        }\n        let previousArray = false;\n        const attendanceDay = attendanceRecord.punches.find((attDay, index) => {\n            if (index === 0 && attDay.punchIn.getTime() === punchIn.getTime()) {\n                previousArray = true;\n            }\n            return attDay.punchIn.getTime() === punchIn.getTime();\n        });\n        if (!attendanceDay) {\n            return next(new errorHandler_1.default(\"No PunchIn found for this day.\", 404));\n        }\n        let oldStatus = false;\n        if (attendanceDay.status == \"approved\") {\n            oldStatus = true;\n        }\n        const hasApprovedImage = attendanceRecord.punches.some((punch) => punch.approvedImage !== undefined);\n        if (status === \"approved\") {\n            if (!hasApprovedImage) {\n                if (attendanceDay.approvedImage) {\n                    attendanceDay.approvedBy = approverId;\n                    attendanceDay.status = \"approved\";\n                }\n                else {\n                    resp.status(400).json({\n                        success: false,\n                        message: \"Image should be uploaded.\",\n                    });\n                }\n            }\n            else {\n                attendanceDay.approvedBy = approverId;\n                attendanceDay.status = \"approved\";\n            }\n        }\n        else {\n            attendanceDay.approvedBy = approverId;\n            attendanceDay.status = \"rejected\";\n        }\n        if (attendanceDay.status == \"approved\") {\n            if (oldStatus == false) {\n                const punchIn = new Date(attendanceDay.punchIn);\n                const punchOut = attendanceDay.punchOut && new Date(attendanceDay.punchOut);\n                if (punchOut) {\n                    const workingHours = (punchOut.getTime() - punchIn.getTime()) / (1000 * 60 * 60); // Convert milliseconds to hours\n                    attendanceRecord.workingHours += workingHours;\n                    attendanceRecord.pendingHours -= workingHours;\n                }\n            }\n        }\n        if (attendanceDay.status == \"rejected\") {\n            if (oldStatus == true) {\n                const punchIn = new Date(attendanceDay.punchIn);\n                const punchOut = attendanceDay.punchOut && new Date(attendanceDay.punchOut);\n                if (punchOut) {\n                    const workingHours = (punchOut.getTime() - punchIn.getTime()) / (1000 * 60 * 60); // Convert milliseconds to hours\n                    attendanceRecord.workingHours -= workingHours;\n                    attendanceRecord.pendingHours += workingHours;\n                }\n            }\n        }\n        // else {\n        //   const punchIn = new Date(attendanceDay.punchIn);\n        //   const punchOut = attendanceDay.punchOut && new Date(attendanceDay.punchOut);\n        // if (punchOut) {\n        //   const workingHours = (punchOut.getTime() - punchIn.getTime()) / (1000 * 60 * 60); // Convert milliseconds to hours\n        //   attendanceRecord.pendingHours += workingHours;\n        //   if(oldStatus){\n        //   attendanceRecord.workingHours -= workingHours;\n        // }\n        // }\n        // }\n        const ratePerHour = employee1.salary /\n            (employee1.workingDays * 4.3 * employee1.workingHours);\n        if (attendanceRecord.workingHours <= 4) {\n            attendanceRecord.totalEarning =\n                ratePerHour * attendanceRecord.workingHours;\n        }\n        else {\n            attendanceRecord.totalEarning =\n                ratePerHour * (attendanceRecord.workingHours - employee1.lunchTime);\n        }\n        if (!employee1.overTime) {\n            if (attendanceRecord.workingHours > employee1.workingHours) {\n                attendanceRecord.totalEarning =\n                    ratePerHour * (employee1.workingHours - employee1.lunchTime);\n            }\n        }\n        await attendanceRecord.save();\n        resp.status(200).json({\n            success: true,\n            message: \"Attendance approved successfully.\",\n            attendance: attendanceRecord,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\n// admin panel getting all the attendance of all employee\nexports.absentAndPresentEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let employee = null;\n        let jobProfile = null;\n        let { date, nextDate, groupName, departmentName, jobProfileName, name, limit = 20, page = 1, } = req.query;\n        limit = +limit;\n        page = +page;\n        const skip = (page - 1) * limit;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Employee not found\",\n                });\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Job profile not found\",\n                });\n            }\n        }\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n            nextDay.setHours(nextDay.getHours() - 6);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setHours(nextDay.getHours() - 6);\n        }\n        const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n        const isAdmin = req.admin;\n        const filter = {};\n        const filter1 = {};\n        let jobProfileIds = [];\n        // Add groupName filter if provided\n        if (groupName) {\n            const group = await groupModel_1.default.findOne({ groupName }).exec();\n            if (group) {\n                filter.groupId = group._id;\n            }\n        }\n        if (departmentName) {\n            const department = await department_1.default.findOne({ departmentName });\n            if (!department) {\n                return resp.status(404).json({\n                    success: false,\n                    message: \"Department not found.\",\n                });\n            }\n            const jobProfiles = await jobProfileModel_1.default.find({\n                department: department._id,\n            });\n            const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n            jobProfileIds = [...jobProfileIds, ...ids];\n            filter.jobProfileId = { $in: jobProfileIds };\n        }\n        // Add jobProfileId filter if provided\n        if (jobProfileName) {\n            const jobProfile = await jobProfileModel_1.default.findOne({\n                jobProfileName: jobProfileName,\n            });\n            if (jobProfile) {\n                jobProfileIds = [...jobProfileIds, jobProfile._id];\n                filter.jobProfileId = { $in: jobProfileIds };\n                filter1.jobProfileId = jobProfile._id;\n            }\n        }\n        if (name) {\n            filter.$or = [\n                { name: { $regex: name, $options: \"i\" } },\n                { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n            ];\n            filter1.$or = [\n                { name: { $regex: name, $options: \"i\" } },\n                { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n            ];\n        }\n        const employeeDocsStore = {};\n        const employeeDocs = await employeeDocsModel_1.default.find({}).lean();\n        employeeDocs.forEach((e) => {\n            const id = e.employeeId + \"\";\n            employeeDocsStore[id] = {\n                profilePicture: e.profilePicture,\n            };\n        });\n        if (!isHR && !isAdmin) {\n            let numberOfEmployee = 0;\n            let totalPresent = 0;\n            const employeeIds = await employeeModel_1.default.aggregate([\n                {\n                    $match: {\n                        ...filter1,\n                    },\n                },\n                {\n                    $lookup: {\n                        from: \"jobprofiles\",\n                        localField: \"jobProfileId\",\n                        foreignField: \"_id\",\n                        as: \"jobProfile\",\n                    },\n                },\n                {\n                    $unwind: \"$jobProfile\",\n                },\n                {\n                    $match: {\n                        \"jobProfile.parentJobProfileId\": jobProfile?._id,\n                    },\n                },\n            ]);\n            const ids = employeeIds.map((employee) => employee._id);\n            numberOfEmployee = ids.length;\n            const attendanceRecords = await attendanceModel_1.default\n                .find({\n                employeeId: { $in: ids },\n                date: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            })\n                .sort({ date: -1 })\n                .populate(\"employeeId\")\n                .populate({\n                path: \"employeeId\",\n                populate: {\n                    path: \"jobProfileId\",\n                },\n            })\n                .populate({\n                path: \"employeeId\",\n                populate: {\n                    path: \"groupId\",\n                },\n            })\n                .populate(\"punches.approvedBy\")\n                .exec();\n            totalPresent = attendanceRecords.length;\n            let newRecords = [];\n            for (let rec of attendanceRecords) {\n                const id = rec.employeeId._id + \"\";\n                const docs = employeeDocsStore[id];\n                if (docs) {\n                    const doc = {\n                        ...rec.toObject(),\n                        profilePicture: docs.profilePicture,\n                    };\n                    newRecords.push(doc);\n                }\n                else {\n                    newRecords.push(rec);\n                }\n            }\n            // // Get employee IDs from the attendanceRecords\n            // const includedEmployeeIds = attendanceRecords.map(\n            //   (record) => (record.employeeId as EmployeeDocument)?._id\n            // );\n            // // Find employees not included in the attendanceRecords\n            // const excludedEmployees = await EmployeeModel.find({\n            //   \"jobProfile.parentJobProfileId\": jobProfile?._id,\n            //   _id: { $nin: includedEmployeeIds },\n            // });\n            resp.status(200).json({\n                success: true,\n                message: \"Employee punches fetched successfully.\",\n                attendanceRecords: newRecords,\n                // excludedEmployees,\n                totalPresent,\n                numberOfEmployee,\n            });\n        }\n        else {\n            // admin condition\n            const employeeIds = await employeeModel_1.default.find(filter)\n                .skip(skip)\n                .limit(limit)\n                .exec();\n            const employeeid = await employeeModel_1.default.find(filter).exec();\n            const empids = employeeid.map((employee) => employee._id);\n            const ids = employeeIds.map((employee) => employee._id);\n            const documnetLength = await attendanceModel_1.default.countDocuments({\n                employeeId: { $in: empids },\n                date: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            });\n            const attendanceRecords = await attendanceModel_1.default\n                .find({\n                employeeId: { $in: ids },\n                date: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            })\n                .sort({ date: -1 })\n                .populate(\"employeeId\")\n                .populate({\n                path: \"employeeId\",\n                populate: {\n                    path: \"jobProfileId\",\n                },\n            })\n                .populate({\n                path: \"employeeId\",\n                populate: {\n                    path: \"groupId\",\n                },\n            })\n                .populate(\"punches.approvedBy\")\n                .exec();\n            let newRecords = [];\n            for (let rec of attendanceRecords) {\n                const id = rec.employeeId._id + \"\";\n                const docs = employeeDocsStore[id];\n                if (docs) {\n                    const doc = {\n                        ...rec.toObject(),\n                        profilePicture: docs.profilePicture,\n                    };\n                    newRecords.push(doc);\n                }\n                else {\n                    newRecords.push(rec);\n                }\n            }\n            // // Get employee IDs from the attendanceRecords\n            // const includedEmployeeIds: any = attendanceRecords.map(\n            //   (record) => (record.employeeId as EmployeeDocument)?._id\n            // );\n            // // Find employees not included in the attendanceRecords\n            // const excludedEmployees = await EmployeeModel.find({\n            //     ...filter,\n            //   _id: { $nin: includedEmployeeIds },\n            // });\n            resp.status(200).json({\n                success: true,\n                message: \"Employee punches fetched successfully.\",\n                attendanceRecords: newRecords,\n                documnetLength: documnetLength,\n                // excludedEmployees,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\n// get punch record by security\nexports.getGroupPunchRecords = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin || req.employee) {\n        const { date, nextDate } = req.query;\n        const employeeStore = {};\n        const attendanceStore = {};\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n            nextDay.setHours(nextDay.getHours() - 6);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setHours(nextDay.getHours() - 6);\n        }\n        const allEmployee = await employeeModel_1.default.find({});\n        const allAttendance = await attendanceModel_1.default.find({\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        });\n        allEmployee.forEach((e) => {\n            const id = e.groupId + \"\";\n            if (!employeeStore[id]) {\n                employeeStore[id] = {\n                    value: [],\n                };\n            }\n            employeeStore[id].value.push({\n                ...e.toObject(),\n            });\n        });\n        allAttendance.forEach((a) => {\n            const id = a.employeeId + \"\";\n            attendanceStore[id] = {\n                ...a.toObject(),\n            };\n        });\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            _id: req.employee?.jobProfileId,\n        });\n        if (req.admin || jobProfile?.jobProfileName.toLowerCase() === \"hr\") {\n            const groups = await groupModel_1.default.find();\n            const groupPresent = [];\n            for (let group of groups) {\n                const punchIn = [];\n                const punchOut = [];\n                const groupId = group._id + \"\";\n                const employees = employeeStore[groupId];\n                if (employees) {\n                    let count = 0;\n                    const ids = employees.value.map((employee) => employee._id);\n                    ids.forEach((i) => {\n                        const id = i;\n                        const data = attendanceStore[id];\n                        if (data) {\n                            count++;\n                            for (let punch of data.punches) {\n                                if (punch.punchInBy) {\n                                    const emp = {\n                                        employee: data.employeeId,\n                                        punchIn: punch.punchIn,\n                                    };\n                                    punchIn.push(emp);\n                                }\n                                if (punch.punchOutBy) {\n                                    const emp = {\n                                        employee: data.employeeId,\n                                        punchOut: punch.punchOut,\n                                    };\n                                    punchOut.push(emp);\n                                }\n                            }\n                        }\n                    });\n                    const obj = {\n                        present: count,\n                        punchIn,\n                        punchOut,\n                        groupName: group.groupName,\n                        totalEmployeesInGroup: ids.length,\n                    };\n                    groupPresent.push(obj);\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully.\",\n                groupPresent,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 403));\n    }\n});\n// get punch record by security\nexports.getPunchRecords = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin || req.employee) {\n        const { date } = req.query;\n        let nextDay;\n        let date1;\n        if (typeof date === \"string\") {\n            date1 = new Date(date);\n            date1.setHours(0, 0, 0, 0);\n            date1.setHours(date1.getHours() - 6);\n            nextDay = new Date(date1);\n            nextDay.setDate(nextDay.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const punchIn = [];\n        const punchOut = [];\n        let countIn = 0;\n        let countOut = 0;\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            _id: req.employee?.jobProfileId,\n        });\n        if (jobProfile?.jobProfileName.toLowerCase() === \"security\" ||\n            jobProfile?.jobProfileName.toLowerCase() === \"security head\") {\n            const allData = await attendanceModel_1.default\n                .find({\n                date: {\n                    $gte: date1,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .exec();\n            for (let data of allData) {\n                for (let punch of data.punches) {\n                    if (punch.punchInBy?.toString() ===\n                        (req.employee?._id?.toString() || req.admin?._id?.toString())) {\n                        const emp = { employee: data.employeeId, punchIn: punch.punchIn };\n                        punchIn.push(emp);\n                        countIn++;\n                    }\n                    if (punch.punchOutBy?.toString() ===\n                        (req.employee?._id?.toString() || req.admin?._id?.toString())) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchOut: punch.punchOut,\n                        };\n                        punchOut.push(emp);\n                        countOut++;\n                    }\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully security.\",\n                punchIn,\n                punchOut,\n                countIn: punchIn.length,\n                countOut: punchOut.length,\n            });\n        }\n        else if (jobProfile?.jobProfileName === \"hr\" || req.admin) {\n            let totalPresent = 0;\n            const totalEmployees = await employeeModel_1.default.countDocuments();\n            const allData = await attendanceModel_1.default\n                .find({\n                date: {\n                    $gte: date1,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .populate(\"punches.punchInBy\")\n                .populate(\"punches.punchOutBy\")\n                .exec();\n            totalPresent = allData.length;\n            for (let data of allData) {\n                for (let punch of data.punches) {\n                    if (punch.punchIn) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchIn: punch.punchIn,\n                            punchInBy: punch.punchInBy,\n                        };\n                        punchIn.push(emp);\n                    }\n                    if (punch.punchOut) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchOut: punch.punchOut,\n                            punchOutBy: punch.punchOutBy,\n                        };\n                        punchOut.push(emp);\n                    }\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully.\",\n                punchIn,\n                punchOut,\n                countIn: punchIn.length,\n                countOut: punchOut.length,\n                totalEmployees,\n                totalPresent,\n            });\n        }\n        else {\n            let totalEmployees = 0;\n            let totalPresent = 0;\n            const employeeIds = await employeeModel_1.default.aggregate([\n                {\n                    $lookup: {\n                        from: \"jobprofiles\",\n                        localField: \"jobProfileId\",\n                        foreignField: \"_id\",\n                        as: \"jobProfile\",\n                    },\n                },\n                {\n                    $unwind: \"$jobProfile\",\n                },\n                {\n                    $match: {\n                        \"jobProfile.parentJobProfileId\": jobProfile?._id,\n                    },\n                },\n            ]).exec();\n            const ids = employeeIds.map((employee) => employee._id);\n            totalEmployees = ids.length;\n            const allData = await attendanceModel_1.default\n                .find({\n                date: {\n                    $gte: date1,\n                    $lt: nextDay,\n                },\n                employeeId: { $in: ids },\n            })\n                .populate(\"employeeId\")\n                .populate(\"punches.punchInBy\")\n                .populate(\"punches.punchOutBy\")\n                .exec();\n            totalPresent = allData.length;\n            for (let data of allData) {\n                for (let punch of data.punches) {\n                    if (punch.punchIn) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchIn: punch.punchIn,\n                            punchInBy: punch.punchInBy,\n                        };\n                        punchIn.push(emp);\n                    }\n                    if (punch.punchOut) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchOut: punch.punchOut,\n                            punchOutBy: punch.punchOutBy,\n                        };\n                        punchOut.push(emp);\n                    }\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully.\",\n                punchIn,\n                punchOut,\n                countIn: punchIn.length,\n                countOut: punchOut.length,\n                totalEmployees,\n                totalPresent,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 403));\n    }\n});\n// get all group salary per day\nexports.getGroupRecordPerDay = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let employee = null;\n        let jobProfile = null;\n        let { date, nextDate, groupName, jobProfileName, name } = req.query;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Employee not found\",\n                });\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Job profile not found\",\n                });\n            }\n        }\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n        const isAdmin = req.admin;\n        const filter1 = {};\n        if (name) {\n            filter1.$or = [\n                { name: { $regex: name, $options: \"i\" } },\n                { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n            ];\n        }\n        if (!isHR && !isAdmin) {\n            const employeeIds = await employeeModel_1.default.aggregate([\n                {\n                    $match: {\n                        ...filter1,\n                    },\n                },\n                {\n                    $lookup: {\n                        from: \"jobprofiles\",\n                        localField: \"jobProfileId\",\n                        foreignField: \"_id\",\n                        as: \"jobProfile\",\n                    },\n                },\n                {\n                    $unwind: \"$jobProfile\",\n                },\n                {\n                    $match: {\n                        \"jobProfile.parentJobProfileId\": jobProfile?._id,\n                    },\n                },\n            ]).exec();\n            const ids = employeeIds.map((employee) => employee._id);\n            const attendanceRecords = await attendanceModel_1.default\n                .find({\n                employeeId: { $in: ids },\n                date: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .exec();\n            // Get employee IDs from the attendanceRecords\n            const includedEmployeeIds = attendanceRecords.map((record) => record.employeeId?._id);\n            // Find employees not included in the attendanceRecords\n            const excludedEmployees = await employeeModel_1.default.find({\n                \"jobProfile.parentJobProfileId\": jobProfile?._id,\n                _id: { $nin: includedEmployeeIds },\n            });\n            resp.status(200).json({\n                success: true,\n                message: \"Employee punches fetched successfully.\",\n                employees: attendanceRecords,\n                excludedEmployees,\n            });\n        }\n        else {\n            const groupData = await groupModel_1.default.find({});\n            let data = [];\n            for (let group of groupData) {\n                const employeeIds = await employeeModel_1.default.find({ groupId: group._id });\n                const ids = employeeIds.map((employee) => employee._id);\n                const attendanceRecords = await attendanceModel_1.default.find({\n                    employeeId: { $in: ids },\n                    date: {\n                        $gte: filterDate,\n                        $lt: nextDay,\n                    },\n                });\n                let totalBasicSalary = 0;\n                let totalEarning = 0;\n                let totalWorkingHour = 0;\n                let totalPendingHour = 0;\n                let totalHoursAsPerEmployee = 0;\n                let netRatePerHour = 0;\n                for (let att of attendanceRecords) {\n                    totalWorkingHour += att.workingHours;\n                    totalPendingHour += att.pendingHours;\n                    totalEarning += att.totalEarning;\n                }\n                for (let emp of employeeIds) {\n                    totalHoursAsPerEmployee += emp.workingHours - emp.lunchTime;\n                    let rate = emp.salary / (emp.workingDays * 4.3);\n                    totalBasicSalary += rate;\n                }\n                let totalAbsentHour = totalHoursAsPerEmployee - totalWorkingHour - totalPendingHour;\n                netRatePerHour =\n                    totalEarning / (totalWorkingHour / employeeIds.length);\n                data.push({\n                    groupName: group.groupName,\n                    groupId: group._id,\n                    numberOfEmployees: employeeIds.length,\n                    totalBasicSalary,\n                    totalEarning,\n                    totalWorkingHour,\n                    totalPendingHour,\n                    totalHoursAsPerEmployee,\n                    totalAbsentHour,\n                    netRatePerHour,\n                });\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"Employee punches fetched successfully.\",\n                data,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\n//my attendance\nexports.myAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee) {\n        let { date, nextDate } = req.query;\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const data = await attendanceModel_1.default\n            .find({\n            employeeId: req.employee._id,\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        })\n            .sort({ date: -1 })\n            .populate(\"punches.approvedBy\")\n            .exec();\n        resp.status(200).json({\n            success: true,\n            message: \"Getting all attendance successfully.\",\n            data,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login as employee\", 404));\n    }\n});\n// single employee Attendance\nexports.singleEmployeeAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let { date, nextDate } = req.query;\n        let { employeeId } = req.params;\n        let employee = await employeeModel_1.default.findOne({ _id: employeeId });\n        if (!employee) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Employee not found .\",\n            });\n        }\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const data = await attendanceModel_1.default\n            .find({\n            employeeId: employee._id,\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        })\n            .sort({ date: -1 })\n            .populate(\"punches.approvedBy\")\n            .exec();\n        resp.status(200).json({\n            success: true,\n            message: \"Getting all attendance successfully.\",\n            data,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login as employee\", 404));\n    }\n});\n// employee staff attendance\nexports.employeeStaffAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let employee = null;\n        let jobProfile = null;\n        let { date, nextDate } = req.query;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Employee not found\",\n                });\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Job profile not found\",\n                });\n            }\n        }\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n        const isAdmin = req.admin;\n        if (!isHR && !isAdmin) {\n            const myJobProfile = await jobProfileModel_1.default.findOne({\n                _id: jobProfile?._id,\n            });\n            const childJobProfile = myJobProfile?.childProfileId;\n            const data = [];\n            if (childJobProfile) {\n                for (let jobProfile of childJobProfile) {\n                    const thisJobProfile = await jobProfileModel_1.default.findOne({\n                        _id: jobProfile,\n                    });\n                    const employees = await employeeModel_1.default.find({\n                        jobProfileId: jobProfile,\n                    });\n                    const totalEmployees = employees.length;\n                    const ids = employees.map((employee) => employee._id);\n                    const attendanceRecords = await attendanceModel_1.default\n                        .find({\n                        employeeId: { $in: ids },\n                        date: {\n                            $gte: filterDate,\n                            $lt: nextDay,\n                        },\n                    })\n                        .sort({ date: -1 })\n                        .populate(\"employeeId\")\n                        .populate({\n                        path: \"employeeId\",\n                        populate: {\n                            path: \"jobProfileId\",\n                        },\n                    })\n                        .populate(\"punches.approvedBy\")\n                        .exec();\n                    const todayPresent = attendanceRecords.length;\n                    const dataa = {\n                        todayPresent,\n                        totalEmployees,\n                        thisJobProfile,\n                    };\n                    data.push(dataa);\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"Employee punches fetched successfully.\",\n                data,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\n// api for excel sheet\nexports.getFirstPunchInLastPunchOut = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { date, nextDate } = req.query;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        filterDate.setHours(filterDate.getHours() - (6 + 5.5));\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        filterDate.setHours(filterDate.getHours() - (6 + 5.5));\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 3);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 3);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    const adjustTimeForIndianTimeZone = (time) => {\n        const indianTime = new Date(time);\n        indianTime.setHours(indianTime.getHours() + 5); // Add 5 hours\n        indianTime.setMinutes(indianTime.getMinutes() + 30); // Add 30 minutes\n        return indianTime;\n    };\n    console.log(\"adjustTimeForIndianTimeZone\", adjustTimeForIndianTimeZone);\n    const data = await attendanceModel_1.default\n        .find({\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    })\n        .populate({\n        path: \"employeeId\",\n        populate: {\n            path: \"jobProfileId\",\n        },\n    })\n        .populate({\n        path: \"employeeId\",\n        populate: {\n            path: \"jobProfileId\",\n        },\n    })\n        .populate({\n        path: \"employeeId\",\n        populate: {\n            path: \"groupId\",\n        },\n    })\n        .sort({ date: -1 })\n        .exec();\n    let result = [];\n    const dateFormat = (dateString) => {\n        const date = new Date(dateString);\n        const year = date.getFullYear();\n        const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n        const day = date.getDate().toString().padStart(2, \"0\");\n        const hours = date.getHours().toString().padStart(2, \"0\");\n        const minutes = date.getMinutes().toString().padStart(2, \"0\");\n        const seconds = date.getSeconds().toString().padStart(2, \"0\");\n        const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}`;\n        return formattedDate;\n    };\n    data.forEach((d) => {\n        const punchIn = adjustTimeForIndianTimeZone(d.punches[0].punchIn);\n        let punchOut;\n        if (d.punches[d.punches.length - 1].punchOut) {\n            // if (d.punches[d.punches.length - 1].punchOut) {\n            punchOut = adjustTimeForIndianTimeZone(d.punches[d.punches.length - 1].punchOut);\n            console.log(\"d.punches[d.punches.length - 1].punchOut\", d.punches[d.punches.length - 1].punchOut);\n            console.log(\"punchOut\", punchOut);\n            // }\n        }\n        else {\n            if (d.punches[d.punches.length - 2]) {\n                punchOut = adjustTimeForIndianTimeZone(d.punches[d.punches.length - 2].punchOut);\n            }\n        }\n        let workingHours;\n        if (punchOut) {\n            workingHours =\n                (punchOut.getTime() - punchIn.getTime()) / (1000 * 60 * 60);\n        }\n        if (d.employeeId) {\n            const obj = {\n                employeeCode: d.employeeId.employeeCode,\n                employeeName: d.employeeId.name,\n                jobProfile: d.employeeId.jobProfileId.jobProfileName,\n                groupName: d.employeeId.groupId.groupName,\n                date: new Date(d.date).toISOString().split(\"T\")[0],\n                punchIn: dateFormat(punchIn),\n                punchOut: dateFormat(punchOut),\n                workingHours: workingHours ? Number(workingHours.toFixed(3)) : 0,\n                approvedHours: Number(d.workingHours.toFixed(3)),\n                pendingHours: Number(d.pendingHours.toFixed(3)),\n                totalEarning: Number(d.totalEarning.toFixed(3)),\n            };\n            result.push(obj);\n        }\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting all attendance successfully.\",\n        result,\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/attendanceController.ts?");

/***/ }),

/***/ "./src/controllers/employee/departmentController.ts":
/*!**********************************************************!*\
  !*** ./src/controllers/employee/departmentController.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deleteDepartment = exports.newChildDepartmentAllData = exports.childDepartmentAllData = exports.getJobProfileInDepartment = exports.getDepartmentByParent = exports.getAllDepartment = exports.getAllParentDepartment = exports.deleteDepartmentToJobProfile = exports.addDepartmentToJobProfile = exports.updateHierarchyDepartment = exports.addParentDepartment = exports.updateParentDepartment = exports.updateDepartment = exports.addDepartment = void 0;\nconst attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/attendanceModel */ \"./src/database/models/attendanceModel.ts\"));\nconst department_1 = __importDefault(__webpack_require__(/*! ../../database/models/department */ \"./src/database/models/department.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst parentDepartment_1 = __importDefault(__webpack_require__(/*! ../../database/models/parentDepartment */ \"./src/database/models/parentDepartment.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\n// add department\nexports.addDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { departmentName, description, parentDepartmentName } = req.body;\n    // find parentGroupID\n    departmentName = departmentName.trim();\n    let department = await department_1.default.findOne({ departmentName });\n    if (department) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Department with same name already present.\",\n        });\n    }\n    let parent;\n    if (parentDepartmentName) {\n        parent = await parentDepartment_1.default.findOne({\n            departmentName: parentDepartmentName,\n        });\n        if (!parent) {\n            return resp.status(400).json({\n                success: false,\n                message: \"Parent department not found.\",\n            });\n        }\n    }\n    const newDepartment = await department_1.default.create({\n        departmentName,\n        description,\n        parentDepartmentId: parent?._id,\n    });\n    parent?.childDepartmentId.push(newDepartment._id);\n    await parent?.save();\n    resp.status(201).json({\n        success: true,\n        message: \"Created department successfully.\",\n        Department: newDepartment,\n        parent,\n    });\n});\nexports.updateDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    let { departmentName, description } = req.body;\n    let department = await department_1.default.findById(id);\n    if (department) {\n        let allDepartment = await department_1.default.findOne({\n            departmentName: departmentName,\n        });\n        if (allDepartment) {\n            return resp.status(400).json({\n                success: false,\n                message: \"Department with same name already present.\",\n            });\n        }\n        else {\n            await department_1.default.findByIdAndUpdate(id, {\n                departmentName: departmentName,\n                description: description,\n            });\n            resp.status(201).json({\n                success: true,\n                message: \"updated department successfully.\",\n            });\n        }\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n});\nexports.updateParentDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    let { departmentName, description } = req.body;\n    let department = await parentDepartment_1.default.findById(id);\n    if (department) {\n        let allDepartment = await parentDepartment_1.default.findOne({\n            departmentName: departmentName,\n        });\n        if (allDepartment) {\n            return resp.status(400).json({\n                success: false,\n                message: \"Department with same name already present.\",\n            });\n        }\n        else {\n            await parentDepartment_1.default.findByIdAndUpdate(id, {\n                departmentName: departmentName,\n                description: description,\n            });\n            resp.status(201).json({\n                success: true,\n                message: \"updated department successfully.\",\n            });\n        }\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n});\n// add new parent department\nexports.addParentDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { departmentName, description } = req.body;\n    // find parentGroupID\n    departmentName = departmentName.trim();\n    let department = await parentDepartment_1.default.findOne({ departmentName });\n    if (department) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Department with same name already present.\",\n        });\n    }\n    const newParentDepartment = await parentDepartment_1.default.create({\n        departmentName,\n        description,\n    });\n    resp.status(201).json({\n        success: true,\n        message: \"Created Parent Department successfully.\",\n        Department: newParentDepartment,\n    });\n});\n// add new parent department\nexports.updateHierarchyDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { departmentName, parentDepartmentName } = req.body;\n    // find parentGroupID\n    departmentName = departmentName.trim();\n    parentDepartmentName = parentDepartmentName.trim();\n    let department = await department_1.default.findOne({ departmentName });\n    if (!department) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n    let parentDepartment = await parentDepartment_1.default.findOne({\n        departmentName: parentDepartmentName,\n    });\n    if (!parentDepartment) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Parent department Not Found.\",\n        });\n    }\n    if (department.parentDepartmentId) {\n        await parentDepartment_1.default\n            .findByIdAndUpdate({ _id: department.parentDepartmentId }, { $pull: { childDepartmentId: department._id } }, { new: true })\n            .exec();\n    }\n    parentDepartment.childDepartmentId.push(department._id);\n    await parentDepartment.save();\n    let updatedDepartment = await department_1.default\n        .findByIdAndUpdate({ _id: department._id }, { parentDepartmentId: parentDepartment._id }, { new: true })\n        .exec();\n    resp.status(201).json({\n        success: true,\n        message: \"Updated Hierarchy of department successfully.\",\n        updatedDepartment,\n        parentDepartment,\n    });\n});\n// add department to a jobProfile\nexports.addDepartmentToJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { departmentName, jobProfileName } = req.body;\n    // find parentGroupID\n    // departmentName = departmentName.trim();\n    let department = await department_1.default.findOne({ departmentName });\n    if (!department) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n    let jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n    if (!jobProfile) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Job profile not found.\",\n        });\n    }\n    jobProfile.department = department._id;\n    await jobProfile.save();\n    resp.status(201).json({\n        success: true,\n        message: \"Added department to jobProfile.\",\n        jobProfile,\n    });\n});\n// delete department to a jobProfile\nexports.deleteDepartmentToJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { departmentName, jobProfileName } = req.body;\n    // find parentGroupID\n    // departmentName = departmentName.trim();\n    let department = await department_1.default.findOne({ departmentName });\n    if (!department) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n    let jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n    if (!jobProfile) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Job profile not found.\",\n        });\n    }\n    jobProfile.department = null;\n    await jobProfile.save();\n    resp.status(201).json({\n        success: true,\n        message: \"deleted department to jobProfile.\",\n        jobProfile,\n    });\n});\n// getting all parent department\nexports.getAllParentDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const allParentDepartment = await parentDepartment_1.default\n        .find({})\n        .populate(\"childDepartmentId\")\n        .exec();\n    return resp.status(200).json({\n        success: true,\n        message: \"Getting all parent department successfully.\",\n        allParentDepartment,\n    });\n});\n// getting all department\nexports.getAllDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const allDepartment = await department_1.default\n        .find({})\n        .populate(\"parentDepartmentId\")\n        .exec();\n    return resp.status(200).json({\n        success: true,\n        message: \"Getting all department successfully.\",\n        allDepartment,\n    });\n});\n// getting department by parent department\nexports.getDepartmentByParent = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { departmentName } = req.query;\n    // getting the parent department details\n    const parent = await parentDepartment_1.default.findOne({ departmentName });\n    if (!parent) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Parent department not found.\",\n        });\n    }\n    const allDepartment = await department_1.default.find({\n        parentDepartmentId: parent._id,\n    });\n    return resp.status(200).json({\n        success: true,\n        message: \"Getting all department successfully.\",\n        allDepartment,\n    });\n});\n// getting all department\nexports.getJobProfileInDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { departmentName } = req.query;\n    const department = await department_1.default.findOne({ departmentName });\n    if (!department) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n    const jobProfile = await jobProfileModel_1.default.find({\n        department: department._id,\n    });\n    return resp.status(200).json({\n        success: true,\n        message: `Getting all job Profile successfully of department ${departmentName}.`,\n        jobProfile,\n    });\n});\n// all data per department\nexports.childDepartmentAllData = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let { departmentName, date, nextDate } = req.query;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n    }\n    const parentDepartment = await parentDepartment_1.default.findOne({\n        departmentName,\n    });\n    if (!parentDepartment) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Parent Department not found.\",\n        });\n    }\n    const departmentArrary = await department_1.default\n        .find({ parentDepartmentId: parentDepartment._id })\n        .lean();\n    let dep = [];\n    for (let department of departmentArrary) {\n        const jobProfilesArray = await jobProfileModel_1.default.find({\n            department: department._id,\n        });\n        let data = [];\n        for (let jobProfile of jobProfilesArray) {\n            const employees = await employeeModel_1.default.find({\n                jobProfileId: jobProfile._id,\n            }).select({ _id: 1 });\n            const ids = employees.map((e) => e._id);\n            let totalHours = 0;\n            for (let e of employees) {\n                totalHours += e.workingHours;\n            }\n            const todaysAttendance = await attendanceModel_1.default.find({\n                date: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n                employeeId: { $in: ids },\n            });\n            let pendingHours = 0;\n            let workingHours = 0;\n            let totalEarning = 0;\n            for (let total of todaysAttendance) {\n                pendingHours += total.pendingHours;\n                workingHours += total.workingHours;\n                totalEarning += total.totalEarning;\n            }\n            const obj = {\n                pendingHours,\n                workingHours,\n                totalEarning,\n                totalHours,\n                jobProfileName: jobProfile.jobProfileName,\n                totalEmployee: ids.length,\n            };\n            data.push(obj);\n        }\n        const obj = {\n            departmentName: department.departmentName,\n            departmentDescription: department.description,\n            data: data,\n        };\n        dep.push(obj);\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Getting data successfully\",\n        dep,\n    });\n});\n// for better time complexity\nexports.newChildDepartmentAllData = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const jobProfileStore = {};\n    const employeeStore = {};\n    const attendanceStore = {};\n    let { departmentName, date, nextDate } = req.query;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n    }\n    const parentDepartment = await parentDepartment_1.default.findOne({\n        departmentName,\n    });\n    if (!parentDepartment) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Parent Department not found.\",\n        });\n    }\n    const departmentArrary = await department_1.default\n        .find({ parentDepartmentId: parentDepartment._id })\n        .lean();\n    const jobProfileArray = await jobProfileModel_1.default.find({}).lean();\n    const employees = await employeeModel_1.default.find({}).lean();\n    const attendance = await attendanceModel_1.default\n        .find({\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    })\n        .lean();\n    jobProfileArray.forEach((d) => {\n        const id = d.department + \"\";\n        if (!jobProfileStore[id]) {\n            jobProfileStore[id] = { value: [] };\n        }\n        jobProfileStore[id].value.push({\n            jobProfileName: d.jobProfileName,\n            jobProfileId: d._id,\n        });\n    });\n    employees.forEach((d) => {\n        const id = d.jobProfileId + \"\";\n        if (!employeeStore[id]) {\n            employeeStore[id] = { value: [] };\n        }\n        const obj = {\n            id: d._id,\n            name: d.name,\n            workingHours: d.workingHours,\n            salary: d.salary,\n        };\n        employeeStore[id].value.push(obj);\n    });\n    attendance.forEach((d) => {\n        const id = d.employeeId + \"\";\n        attendanceStore[id] = {\n            employeeId: id,\n            workingHours: d.workingHours ? d.workingHours : 0,\n            pendingHours: d.pendingHours ? d.pendingHours : 0,\n            totolEarning: d.totalEarning ? d.totalEarning : 0,\n        };\n    });\n    const departmentSalary = [];\n    departmentArrary.forEach((d) => {\n        const id = d._id + \"\";\n        const jobProfiles = jobProfileStore[id];\n        const salaryData = [];\n        if (jobProfiles) {\n            jobProfiles.value.forEach((j) => {\n                const employee = employeeStore[j.jobProfileId];\n                let employeeWorkingHours = 0;\n                let employeePendingHours = 0;\n                let employeeTotalEarning = 0;\n                let employeeTotalHours = 0;\n                let totalSalaryOfEmployee = 0;\n                let totalPresent = 0;\n                if (employee) {\n                    employee.value.forEach((e) => {\n                        const id = e.id + \"\";\n                        employeeTotalHours += e.workingHours;\n                        totalSalaryOfEmployee += e.salary;\n                        const salary = attendanceStore[id];\n                        if (attendanceStore[id]) {\n                            totalPresent++;\n                            employeeWorkingHours += salary.workingHours;\n                            employeeTotalEarning += salary.totolEarning;\n                            employeePendingHours += salary.pendingHours;\n                        }\n                    });\n                    const obj = {\n                        jobProfilesName: j.jobProfileName,\n                        numberOfEmployee: employee.value.length,\n                        employeeWorkingHours,\n                        employeePendingHours,\n                        employeeTotalEarning,\n                        employeeTotalHours,\n                        totalSalaryOfEmployee,\n                    };\n                    salaryData.push(obj);\n                }\n            });\n            departmentSalary.push({\n                departmentName: d.departmentName,\n                departmentDescription: d.description,\n                numberOfJobProfiles: jobProfiles.value.length,\n                salaryData,\n            });\n        }\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting data successfully\",\n        departmentSalary,\n    });\n});\nexports.deleteDepartment = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    const department = await department_1.default.findById(id);\n    let numberOfJobProfiles = null;\n    if (!department) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Department not found.\",\n        });\n    }\n    const matchingEmployees = await jobProfileModel_1.default.find({\n        department: department._id,\n    });\n    numberOfJobProfiles = matchingEmployees.length;\n    if (numberOfJobProfiles > 0) {\n        return resp.status(200).json({\n            success: false,\n            message: \"Department cannot be deleted because it has job profiles.\",\n            numberOfJobProfiles,\n        });\n    }\n    else {\n        const department = await department_1.default.findByIdAndDelete(id);\n        return resp.status(200).json({\n            success: true,\n            message: `Department Deleted successfully`,\n            numberOfJobProfiles,\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/departmentController.ts?");

/***/ }),

/***/ "./src/controllers/employee/employeeController.ts":
/*!********************************************************!*\
  !*** ./src/controllers/employee/employeeController.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.employeeBarCode = exports.salaryLogPerEmployee = exports.newPasswordGenerator = exports.changePassword = exports.assignedByMe = exports.assignQrCode = exports.getEmployeeByGroupAndJobProfile = exports.getSingle = exports.getAllFields = exports.updateNewFields = exports.deleteNewFields = exports.getNewFields = exports.addNewField = exports.loginEmployee = exports.getAllEmployee = exports.deleteEmployee = exports.updateEmployee = exports.updateEmployeeBarCodes = exports.addEmployee = void 0;\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst bcrypt_1 = __importDefault(__webpack_require__(/*! bcrypt */ \"bcrypt\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst QRCode = __importStar(__webpack_require__(/*! qrcode */ \"qrcode\"));\nconst sendCookie_1 = __webpack_require__(/*! ../../utils/sendCookie */ \"./src/utils/sendCookie.ts\");\nconst barCodeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/barCodeModel */ \"./src/database/models/barCodeModel.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst salaryLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/salaryLogModel */ \"./src/database/models/salaryLogModel.ts\"));\nconst department_1 = __importDefault(__webpack_require__(/*! ../../database/models/department */ \"./src/database/models/department.ts\"));\nconst attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/attendanceModel */ \"./src/database/models/attendanceModel.ts\"));\nconst loginHistoryModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/loginHistoryModel */ \"./src/database/models/loginHistoryModel.ts\"));\nconst adminModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/adminModel */ \"./src/database/models/adminModel.ts\"));\n// adding a employee\nexports.addEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { name, aadharNumber, groupName, jobProfileName, email, employeeCode, contactNumber, password, dateOfBirth, gender, dateOfJoining, salary, expactedSalary, leaveTaken, workingDays, workingHours, lunchTime, overTime, overTimeRate, PF_UAN_Number, ESI_ID, PAN_Number, salaryMode, bankDetails, } = req.body;\n    if (email) {\n        email = email.toLowerCase();\n    }\n    name = name.trim();\n    // for athentication\n    let authorised = false;\n    let addedBy = {};\n    if (req.dbManager) {\n        const emp = await employeeModel_1.default.findById(req.dbManager._id);\n        if (emp?.role === \"dbManager\") {\n            addedBy.by = emp._id;\n            addedBy.name = emp.name;\n            authorised = true;\n        }\n    }\n    if (overTime) {\n        if (!overTimeRate) {\n            overTimeRate = salary / (workingDays * 4.28 * workingHours);\n        }\n    }\n    if (req.admin) {\n        addedBy.by = req.admin._id;\n        addedBy.name = req.admin.name;\n    }\n    if (req.admin || authorised) {\n        const groupId = await groupModel_1.default.findOne({ groupName });\n        if (!groupId) {\n            return next(new errorHandler_1.default(\"Group not found\", 404));\n        }\n        const jobProfileId = await jobProfileModel_1.default.findOne({ jobProfileName });\n        if (!jobProfileId) {\n            return next(new errorHandler_1.default(\"JobProfile not found\", 404));\n        }\n        if (email) {\n            let employee = await employeeModel_1.default.findOne({ email: email });\n            if (employee) {\n                return next(new errorHandler_1.default(\"Employee Already exist.\", 400));\n            }\n        }\n        let employee = await employeeModel_1.default.findOne({\n            contactNumber: contactNumber,\n        });\n        if (employee) {\n            return next(new errorHandler_1.default(\"Employee Already exist.\", 400));\n        }\n        const hashedPassword = await bcrypt_1.default.hash(password || name + \"123\", parseInt(process.env.SALT, 10));\n        // Generate QR code for the currentBarCode\n        let currentBarCode;\n        try {\n            currentBarCode = await QRCode.toDataURL(name + \"123\"); // Using email as an example\n        }\n        catch (err) {\n            return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n        }\n        // For Fixed Salary Employee\n        const findJobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n        if (findJobProfile?.employmentType === \"Fixed Salary Employee\") {\n            employee = await employeeModel_1.default.create({\n                name,\n                aadharNumber,\n                PF_UAN_Number,\n                ESI_ID,\n                PAN_Number,\n                salaryMode,\n                bankDetails,\n                groupId: groupId._id,\n                jobProfileId: jobProfileId._id,\n                email,\n                contactNumber,\n                employeeCode,\n                password: hashedPassword,\n                dateOfBirth,\n                gender,\n                dateOfJoining,\n                salary,\n                leaveTaken,\n                currentBarCode,\n                workingDays,\n                workingHours,\n                lunchTime,\n                overTime,\n                overTimeRate,\n                addedby: addedBy,\n            });\n            let id;\n            if (req.admin) {\n                id = req.admin._id;\n            }\n            else {\n                id = req.employee?._id;\n            }\n            console.log(\"id------salary\", id);\n            await salaryLogModel_1.default.create({\n                employeeId: employee._id,\n                salary,\n                workingHours,\n                applicableMonth: new Date(),\n                changedBy: id,\n            });\n        }\n        // For Contract employee\n        else if (findJobProfile?.employmentType === \"Contract Employee\") {\n            employee = await employeeModel_1.default.create({\n                name,\n                aadharNumber,\n                PF_UAN_Number,\n                ESI_ID,\n                PAN_Number,\n                salaryMode,\n                bankDetails,\n                groupId: groupId._id,\n                jobProfileId: jobProfileId._id,\n                email,\n                contactNumber,\n                password: hashedPassword,\n                dateOfBirth,\n                gender,\n                dateOfJoining,\n                expactedSalary,\n                leaveTaken,\n                currentBarCode,\n                addedby: addedBy,\n            });\n        }\n        const employees = await employeeModel_1.default.find()\n            .populate(\"groupId\")\n            .populate(\"jobProfileId\")\n            .exec();\n        resp.status(201).json({\n            success: true,\n            message: \"Employee created successfully.\",\n            employee,\n            // employees,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first as admin or Data Manager\", 400));\n    }\n});\n// update employee barcode\nexports.updateEmployeeBarCodes = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    try {\n        // Find all employees or filter based on certain conditions\n        let employees = await employeeModel_1.default.find({});\n        if (!employees) {\n            return next(new errorHandler_1.default(\"No employees found.\", 404));\n        }\n        // For each employee, generate a random identifier and use it to generate the QR code\n        for (let employee of employees) {\n            // Generate a random identifier using uuid\n            const randomIdentifier = (0, uuid_1.v4)();\n            // Generate QR code based on the random identifier\n            const newBarCode = await QRCode.toDataURL(randomIdentifier);\n            // Update currentBarCode\n            employee.currentBarCode = newBarCode;\n            await employee.save();\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"Employee barcodes updated successfully.\",\n        });\n    }\n    catch (error) {\n        return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n    }\n});\n// update an employee\nexports.updateEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin || req.employee) {\n        const id = req.params.id;\n        let { name, group, jobProfile, email, employeeCode, contactNumber, password, dateOfBirth, gender, employeeStatus, dateOfJoining, salary, lunchTime, workingHours, workingDays, overTime, overTimeRate, leaveTaken, currentBarCode, aadharNumber, PF_UAN_Number, ESI_ID, PAN_Number, salaryMode, bankName, IFSC_Code, branch, accountNumber, role, optionForRole, active, applicableMonth, } = req.body;\n        if (role) {\n            const employee = await employeeModel_1.default.findById(id);\n            let options = employee?.optionForRole;\n            if (!options.includes(role)) {\n                return resp.status(400).json({\n                    success: false,\n                    message: \"Invalid role. Role is not included in options.\",\n                });\n            }\n        }\n        let updated = {};\n        if (req.employee) {\n            const employee = await employeeModel_1.default.findById(req.employee._id);\n            updated.by = employee?._id;\n            updated.name = employee?.name;\n        }\n        if (req.admin) {\n            const admin = await adminModel_1.default.findById(req.admin._id);\n            updated.by = admin?._id;\n            updated.name = admin?.name;\n        }\n        if (active === false) {\n            const employee = await employeeModel_1.default.findById(id);\n            if (employee) {\n                employee.BarCodeStatus = false;\n                await employee.save();\n            }\n        }\n        if (active === true) {\n            const employee = await employeeModel_1.default.findById(id);\n            if (employee) {\n                employee.BarCodeStatus = true;\n                await employee.save();\n            }\n        }\n        if (email) {\n            email = email.toLowerCase();\n            let emp = await employeeModel_1.default.findOne({ email: email });\n            if (emp) {\n                return next(new errorHandler_1.default(\"Employee With same email already present.\", 400));\n            }\n        }\n        if (group) {\n            var groupId;\n            const findGroup = await groupModel_1.default.findOne({ groupName: group });\n            groupId = findGroup?._id;\n            if (!findGroup) {\n                return resp.status(404).json({\n                    success: false,\n                    message: \"Group not found.\",\n                });\n            }\n        }\n        if (jobProfile) {\n            var jobProfileId;\n            const findJobProfile = await jobProfileModel_1.default.findOne({\n                jobProfileName: jobProfile,\n            });\n            jobProfileId = findJobProfile?._id;\n            if (!findJobProfile) {\n                return resp.status(404).json({\n                    success: false,\n                    message: \"jobProfile not found.\",\n                });\n            }\n        }\n        let employee = await employeeModel_1.default.findOne({ _id: id });\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee doesn't exist.\", 400));\n        }\n        if (employeeCode) {\n            let employee = await employeeModel_1.default.findOne({ employeeCode });\n            if (employee) {\n                return next(new errorHandler_1.default(\"Employee With same EmployeeCode already present.\", 400));\n            }\n        }\n        let hashedPassword;\n        if (password) {\n            hashedPassword = await bcrypt_1.default.hash(password, parseInt(process.env.SALT, 10));\n        }\n        if (contactNumber) {\n            // let check = await EmployeeModel.findOne({ employeeCode });\n            // if (check) {\n            //   return next(\n            //     new ErrorHandler(\n            //       \"Employee With same Phone Number already present.\",\n            //       400\n            //     )\n            //   );\n            // }\n            let check1 = await employeeModel_1.default.findOne({ contactNumber });\n            if (check1) {\n                return next(new errorHandler_1.default(\"Same phone number is already present in database.\", 400));\n            }\n            let overTimeRatecal = (salary ? salary : employee?.salary) /\n                (4.28 *\n                    (workingHours ? workingHours : employee?.workingHours) *\n                    (workingDays ? workingDays : employee?.workingDays));\n            employee = await employeeModel_1.default.findByIdAndUpdate({ _id: id }, {\n                name,\n                aadharNumber,\n                groupId,\n                jobProfileId,\n                email,\n                employeeCode,\n                contactNumber,\n                password: hashedPassword,\n                dateOfBirth,\n                gender,\n                employeeStatus,\n                dateOfJoining,\n                salary,\n                workingHours,\n                workingDays,\n                overTime,\n                lunchTime,\n                overTimeRate: overTimeRate ? overTimeRate : overTimeRatecal,\n                leaveTaken,\n                currentBarCode,\n                verified: false,\n                role: role,\n                optionForRole,\n                updateBy: updated,\n                active,\n            }, { new: true })\n                .populate(\"groupId\")\n                .populate(\"jobProfileId\")\n                .exec();\n            let idd;\n            if (req.admin) {\n                idd = req.admin._id;\n            }\n            else {\n                idd = req.employee?._id;\n            }\n            if (salary || workingDays || workingHours) {\n                await salaryLogModel_1.default.create({\n                    employeeId: employee?._id,\n                    salary,\n                    workingHours,\n                    applicableMonth,\n                    changedBy: id,\n                });\n            }\n        }\n        else {\n            const partialBankDetails = {};\n            if (bankName)\n                partialBankDetails.bankName = bankName;\n            if (IFSC_Code)\n                partialBankDetails.IFSC_Code = IFSC_Code;\n            if (branch)\n                partialBankDetails.branch = branch;\n            if (accountNumber)\n                partialBankDetails.accountNumber = accountNumber;\n            let overTimeRatecal = (salary ? salary : employee?.salary) /\n                (4.28 *\n                    (workingHours ? workingHours : employee?.workingHours) *\n                    (workingDays ? workingDays : employee?.workingDays));\n            employee = await employeeModel_1.default.findByIdAndUpdate({ _id: id }, {\n                name,\n                aadharNumber,\n                PF_UAN_Number,\n                ESI_ID,\n                PAN_Number,\n                salaryMode,\n                $set: {\n                    bankDetails: { ...employee.bankDetails, ...partialBankDetails },\n                },\n                groupId,\n                jobProfileId,\n                email,\n                employeeCode,\n                password: hashedPassword,\n                dateOfBirth,\n                gender,\n                lunchTime,\n                employeeStatus,\n                dateOfJoining,\n                workingHours,\n                workingDays,\n                overTime,\n                overTimeRate: overTimeRatecal,\n                leaveTaken,\n                currentBarCode,\n                role: role,\n                optionForRole,\n                active,\n                updateBy: updated,\n            }, { new: true })\n                .populate(\"groupId\")\n                .populate(\"jobProfileId\")\n                .exec();\n            let idd;\n            if (req.admin) {\n                idd = req.admin._id;\n            }\n            else {\n                idd = req.employee?._id;\n            }\n            if (salary) {\n                await salaryLogModel_1.default.create({\n                    employeeId: id,\n                    salary: salary ? salary : employee?.salary,\n                    applicableMonth: applicableMonth,\n                    changedBy: idd,\n                });\n            }\n        }\n        resp.status(201).json({\n            success: true,\n            message: \"Employee updated successfully.\",\n            employee,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first.\", 401));\n    }\n});\n// delete an employee\nexports.deleteEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    let employee = await employeeModel_1.default.findByIdAndDelete({ _id: id });\n    if (!employee) {\n        return next(new errorHandler_1.default(\"Employee doesn't exist.\", 400));\n    }\n    const attendance = await attendanceModel_1.default.deleteMany({\n        employeeId: employee._id,\n    });\n    resp.status(201).json({\n        success: true,\n        message: \"Employee deleted successfully.\",\n        employee,\n    });\n});\n// getting employee with search and filter\nexports.getAllEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfileIds = [];\n    const { jobProfileName, groupName, employmentStatus, departmentName, name, page = 1, limit = 20, aadhar, createdSort, updatedSort, role, } = req.body;\n    // Create a filter object to hold the query conditions\n    const filter = {};\n    // Add groupName filter if provided\n    if (role) {\n        filter.role = role;\n    }\n    if (groupName &&\n        Array.isArray(groupName) &&\n        groupName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyGroupNames = groupName.filter((name) => name.trim() !== \"\");\n        const groups = await groupModel_1.default\n            .find({ groupName: { $in: nonEmptyGroupNames } })\n            .exec();\n        const groupIds = groups.map((group) => group._id);\n        filter.groupId = { $in: groupIds };\n    }\n    // Add departmentName filter if provided and non-empty\n    if (departmentName &&\n        Array.isArray(departmentName) &&\n        departmentName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyDepartmentNames = departmentName.filter((name) => name.trim() !== \"\");\n        const departments = await department_1.default\n            .find({ departmentName: { $in: nonEmptyDepartmentNames } })\n            .exec();\n        const departmentIds = departments.map((department) => department._id);\n        const jobProfiles = await jobProfileModel_1.default.find({\n            department: { $in: departmentIds },\n        }).exec();\n        const jobProfileIds = jobProfiles.map((jobProfile) => jobProfile._id);\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    // Add jobProfileName filter if provided and non-empty\n    if (jobProfileName &&\n        Array.isArray(jobProfileName) &&\n        jobProfileName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyJobProfileNames = jobProfileName.filter((name) => name.trim() !== \"\");\n        const jobProfiles = await jobProfileModel_1.default.find({\n            jobProfileName: { $in: nonEmptyJobProfileNames },\n        }).exec();\n        const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n        jobProfileIds = [...jobProfileIds, ...ids];\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    if (employmentStatus) {\n        filter.employeeStatus = employmentStatus;\n    }\n    // Add name search filter if provided\n    if (name) {\n        filter.$or = [\n            { name: { $regex: name, $options: \"i\" } },\n            { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n        ];\n    }\n    // Calculate skip value for pagination\n    const skip = (page - 1) * limit;\n    let aadharNumbers = aadhar;\n    aadharNumbers = parseInt(aadhar);\n    if (typeof aadharNumbers != \"undefined\") {\n        const aadharFilter = {};\n        if (aadharNumbers === 1) {\n            aadharFilter.$and = [\n                { aadharNumber: { $exists: true } },\n                { aadharNumber: { $ne: 0 } },\n            ];\n        }\n        else if (aadharNumbers === -1) {\n            aadharFilter.$or = [\n                { aadharNumber: 0 },\n                { aadharNumber: { $exists: false } },\n            ];\n        }\n        Object.assign(filter, aadharFilter);\n    }\n    // Find employees based on the filter with pagination\n    let emplys = await employeeModel_1.default.find(filter)\n        .populate({\n        path: \"jobProfileId\",\n        select: \"jobProfileName jobDescription employmentType isSupervisor\",\n    })\n        .populate({\n        path: \"groupId\",\n        select: \"groupName\",\n    })\n        .skip(skip)\n        .limit(limit)\n        .select(\"-password -trainingStatus -permanentBarCodeNumber -permanentQrCodeAssign -assignedBy -marks -leaveTaken -permanentBarCode\")\n        .exec();\n    if (createdSort === \"True\") {\n        emplys = await employeeModel_1.default.find(filter)\n            .populate({\n            path: \"jobProfileId\",\n            select: \"jobProfileName jobDescription employmentType isSupervisor\",\n        })\n            .populate({\n            path: \"groupId\",\n            select: \"groupName\",\n        })\n            .skip(skip)\n            .limit(limit)\n            .sort({ createdAt: -1 })\n            .select(\"-password -trainingStatus -permanentBarCodeNumber -permanentQrCodeAssign -assignedBy -marks -leaveTaken -permanentBarCode\")\n            .exec();\n    }\n    if (updatedSort === \"True\") {\n        emplys = await employeeModel_1.default.find(filter)\n            .populate({\n            path: \"jobProfileId\",\n            select: \"jobProfileName jobDescription employmentType isSupervisor\",\n        })\n            .populate({\n            path: \"groupId\",\n            select: \"groupName\",\n        })\n            .skip(skip)\n            .limit(limit)\n            .sort({ updatedAt: -1 })\n            .select(\"-password -trainingStatus -permanentBarCodeNumber -permanentQrCodeAssign -assignedBy -marks -leaveTaken -permanentBarCode\")\n            .exec();\n    }\n    if (updatedSort === \"False\") {\n        emplys = await employeeModel_1.default.find(filter)\n            .populate({\n            path: \"jobProfileId\",\n            select: \"jobProfileName jobDescription employmentType isSupervisor\",\n        })\n            .populate({\n            path: \"groupId\",\n            select: \"groupName\",\n        })\n            .skip(skip)\n            .limit(limit)\n            .sort({ updatedAt: 1 })\n            .select(\"-password -trainingStatus -permanentBarCodeNumber -permanentQrCodeAssign -assignedBy -marks -leaveTaken -permanentBarCode\")\n            .exec();\n    }\n    const employeeDocs = await employeeDocsModel_1.default.find().lean();\n    const docsStore = {};\n    employeeDocs.forEach((e) => {\n        const id = e.employeeId + \"\";\n        docsStore[id] = { ...e };\n    });\n    let employees = [];\n    const loggedInHistory = await loginHistoryModel_1.default\n        .find()\n        .select({ logInTime: 1 })\n        .lean();\n    const loggedInHistoryStore = {};\n    loggedInHistory.forEach((l) => {\n        const id = l.user + \"\";\n        if (!loggedInHistoryStore[id]) {\n            loggedInHistoryStore[id] = { data: [] };\n        }\n        loggedInHistoryStore[id].data.push({ ...l });\n    });\n    for (let employee of emplys) {\n        const employeeDocs = docsStore[employee._id + \"\"];\n        const loggedHistory = loggedInHistoryStore[employee._id + \"\"]?.data || [];\n        // const loggedHistory = await loginHistoryModel\n        //   .find({ user: employee._id })\n        //   .select(\"logInTime\");\n        const lastloggedHistory = loggedHistory[loggedHistory.length - 1];\n        if (employeeDocs?.profilePicture) {\n            const employeeCopy = JSON.parse(JSON.stringify(employee));\n            employeeCopy.profilePicture = employeeDocs.profilePicture;\n            employeeCopy.loggedHistory = lastloggedHistory;\n            employees.push(employeeCopy);\n        }\n        else {\n            const employeeCopy = JSON.parse(JSON.stringify(employee));\n            employeeCopy.loggedHistory = lastloggedHistory;\n            employees.push(employeeCopy);\n        }\n    }\n    const count = await employeeModel_1.default.countDocuments(filter);\n    resp.status(200).json({\n        success: true,\n        message: \"Getting All Employee successfully.\",\n        employees,\n        count,\n    });\n});\n// Login employee\nexports.loginEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { email, phone, password } = req.body;\n    let employee = await employeeModel_1.default.findOne({\n        $or: [{ email: email }, { contactNumber: phone }],\n    }).select(\"+password\");\n    if (!employee)\n        return next(new errorHandler_1.default(\"admin doesn't exist.\", 400));\n    const comparePassword = await bcrypt_1.default.compare(password, employee.password);\n    if (!comparePassword)\n        return next(new errorHandler_1.default(\"Employee or password doesn't match.\", 400));\n    (0, sendCookie_1.sendCookieAdmin)(resp, employee._id, `Welcome back, ${employee.name}`, 200);\n});\n// to get dynamic fields\nlet dynamicallyAddedFields = [];\n// add new field in employee model\nexports.addNewField = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    try {\n        const { fields } = req.body;\n        // Update the Mongoose schema to add the new fields\n        const schema = employeeModel_1.default.schema;\n        for (const field of fields) {\n            schema.add({ [field.name]: field.type });\n            // Add the field to the dynamically added fields array\n            dynamicallyAddedFields.push({ name: field.name, type: field.type });\n        }\n        resp.status(200).json({ message: \"Fields added successfully\" });\n    }\n    catch (error) {\n        console.error(error);\n        resp.status(500).json({ message: \"Internal server error\" });\n    }\n});\n// get newFields\nexports.getNewFields = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    try {\n        resp.status(200).json({ fields: dynamicallyAddedFields });\n    }\n    catch (error) {\n        console.error(error);\n        resp.status(500).json({ message: \"Internal server error\" });\n    }\n});\n//delete new fields\nexports.deleteNewFields = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    try {\n        const { fieldName } = req.body;\n        // Update the Mongoose schema to remove the specified field\n        employeeModel_1.default.schema.remove(fieldName);\n        resp.status(200).json({ message: \"Field deleted successfully\" });\n    }\n    catch (error) {\n        console.error(error);\n        resp.status(500).json({ message: \"Internal server error\" });\n    }\n});\n//delete new fields\nexports.updateNewFields = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    try {\n        const { oldFieldName, newFieldName } = req.body;\n        // Update the Mongoose schema to modify the field name\n        const schema = employeeModel_1.default.schema;\n        schema.path(oldFieldName).path = newFieldName;\n        // Update the field name in existing records\n        await employeeModel_1.default.updateMany({}, { $rename: { [oldFieldName]: newFieldName } });\n        resp.status(200).json({ message: \"Field name updated successfully\" });\n    }\n    catch (error) {\n        console.error(error);\n        resp.status(500).json({ message: \"Internal server error\" });\n    }\n});\nexports.getAllFields = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    try {\n        const newFields = [];\n        // Get all the paths in the Mongoose schema\n        const schemaPaths = employeeModel_1.default.schema.paths;\n        for (const path in schemaPaths) {\n            // Check if the path is not a default Mongoose field\n            if (!path.startsWith(\"_\")) {\n                const field = {\n                    name: path,\n                    type: schemaPaths[path].instance,\n                };\n                newFields.push(field);\n            }\n        }\n        resp.status(200).json({ fields: newFields });\n    }\n    catch (error) {\n        console.error(error);\n        resp.status(500).json({ message: \"Internal server error\" });\n    }\n});\n// single employee status\nexports.getSingle = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { employeeId } = req.params;\n    if (employeeId) {\n        const employeeData = await employeeModel_1.default.findById(employeeId)\n            .populate(\"groupId\")\n            .populate(\"jobProfileId\");\n        const data = await employeeDocsModel_1.default.findOne({\n            employeeId: employeeData?._id,\n        });\n        const ep = {\n            ...employeeData?.toObject(),\n            profilePicture: data?.profilePicture,\n            docs: data?.document,\n        };\n        resp.status(200).json({\n            success: true,\n            message: \"employee data successfully.\",\n            employeeData: ep,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"employee not found.\",\n        });\n    }\n});\n// get employee by group and jobProfile\nexports.getEmployeeByGroupAndJobProfile = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { jobProfileName } = req.query;\n    // let group;\n    let jobProfile;\n    // if (groupName) {\n    //   group = await groupModel.findOne({ groupName });\n    // }\n    if (jobProfileName) {\n        jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n    }\n    const employees = await employeeModel_1.default.find({\n        jobProfileId: jobProfile?._id,\n    }).lean(); // Use the lean() method to get plain JavaScript objects instead of Mongoose documents\n    resp.status(200).json({\n        success: true,\n        message: \"Employee data fetched successfully.\",\n        employees: Array.isArray(employees) ? employees : [employees],\n    });\n});\n// assign QR code\nexports.assignQrCode = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById({\n            _id: req.employee.jobProfileId,\n        });\n    }\n    const { employeeId } = req.params;\n    const { data } = req.body;\n    let qrCode;\n    try {\n        qrCode = await QRCode.toDataURL(data); // Using email as an example\n    }\n    catch (err) {\n        return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n    }\n    let employee = await employeeModel_1.default.findOne({ currentBarCode: qrCode });\n    let employee1 = await employeeModel_1.default.findOne({ permanentBarCode: qrCode });\n    if (employee || employee1) {\n        return next(new errorHandler_1.default(\"This Qr code already assigned.\", 400));\n    }\n    if (req.admin ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee = await employeeModel_1.default.findById(employeeId);\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        const currentDate = new Date();\n        employee = await employeeModel_1.default.findByIdAndUpdate(employeeId, {\n            permanentBarCode: qrCode,\n            permanentQrCodeAssign: currentDate,\n            assignedBy: req.employee?._id || req.admin?._id,\n            permanentBarCodeNumber: data,\n        }, { new: true });\n        const newData = await barCodeModel_1.default.findOneAndUpdate({ barCodeNumber: data, employeeId }, { assignedBy: req.employee?._id || req.admin?._id }).exec();\n        resp.status(200).json({\n            success: true,\n            message: \"QrCode Assigned successfully.\",\n            employee,\n            newData,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security .\",\n        });\n    }\n});\n// QR Code Assigned By me\nexports.assignedByMe = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { page, limit, date } = req.query;\n    const pge = page ? parseInt(page) : 1; // Current page number (default: 1)\n    const lmt = limit ? parseInt(limit) : 20; // Number of items per page (default: 10)\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById({\n            _id: req.employee.jobProfileId,\n        });\n    }\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n    }\n    nextDay = new Date(filterDate);\n    nextDay.setDate(filterDate.getDate() + 1);\n    if (req.admin ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee;\n        if (req.employee) {\n            employee = await barCodeModel_1.default.find({\n                assignedBy: req.employee?._id,\n                createdAt: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .sort({ createdAt: -1 })\n                .skip((pge - 1) * lmt)\n                .limit(lmt)\n                .exec();\n        }\n        else if (req.admin) {\n            employee = await barCodeModel_1.default.find({\n                assignedBy: req.admin?._id,\n                createdAt: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .sort({ createdAt: -1 })\n                .skip((pge - 1) * lmt)\n                .limit(lmt)\n                .exec();\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"getting all employee Assigned Qr by me successfully.\",\n            employee,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security .\",\n        });\n    }\n});\n// change password\nconst changePassword = async (req, resp, next) => {\n    if (req.employee) {\n        const { oldPassword, newPassword } = req.body;\n        const comparePassword = await bcrypt_1.default.compare(oldPassword, req.employee.password);\n        if (comparePassword) {\n            const hashedPassword = await bcrypt_1.default.hash(newPassword, parseInt(process.env.SALT, 10));\n            const updatedEmployee = await employeeModel_1.default.findOneAndUpdate({ _id: req.employee._id }, { password: hashedPassword }, { new: true });\n            resp.status(200).json({\n                success: true,\n                message: \"Password changed successfully.\",\n                employee: updatedEmployee,\n            });\n        }\n        else {\n            resp.status(200).json({\n                success: false,\n                message: \"Old password is not correct.\",\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Something went wrong. Login with employee.\", 400));\n    }\n};\nexports.changePassword = changePassword;\n// new password generate with old password\nconst newPasswordGenerator = async (req, resp, next) => {\n    if (req.admin) {\n        const { employeeId } = req.params;\n        const { password } = req.body;\n        const employee = await employeeModel_1.default.findOne({ _id: employeeId });\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee not found\", 404));\n        }\n        const hashedPassword = await bcrypt_1.default.hash(password, parseInt(process.env.SALT, 10));\n        const updatedEmployee = await employeeModel_1.default.findOneAndUpdate({ _id: employee._id }, { password: hashedPassword }, { new: true });\n        resp.status(200).json({\n            success: true,\n            message: \"Password changed successfully.\",\n            employee: updatedEmployee,\n        });\n    }\n    else {\n        resp.status(403).json({\n            success: false,\n            message: \"Login as admin.\",\n        });\n    }\n};\nexports.newPasswordGenerator = newPasswordGenerator;\n// getting salary log\nconst salaryLogPerEmployee = async (req, resp, next) => {\n    const jobProfile = await jobProfileModel_1.default.findOne({\n        _id: req.employee?.jobProfileId,\n    });\n    if (req.admin || jobProfile?.jobProfileName.toLowerCase() === \"hr\") {\n        const { employeeId } = req.params;\n        const employee = await employeeModel_1.default.findOne({ _id: employeeId });\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee not found\", 404));\n        }\n        const salaryLog = await salaryLogModel_1.default.find({\n            employeeId: employee._id,\n        })\n            .sort({ createdAt: -1 })\n            .exec();\n        const data = [];\n        for (let item of salaryLog) {\n            const admin = await adminModel_1.default.findById(item.changedBy);\n            const employee = await employeeModel_1.default.findById(item.changedBy);\n            if (admin) {\n                data.push({\n                    ...item._doc,\n                    changed: admin.name,\n                });\n            }\n            else if (employee) {\n                data.push({\n                    ...item._doc,\n                    changed: employee.name,\n                });\n            }\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"getting salary log successfully.\",\n            salaryLog: data,\n        });\n    }\n    else {\n        resp.status(403).json({\n            success: false,\n            message: \"Login as Hr or admin.\",\n        });\n    }\n};\nexports.salaryLogPerEmployee = salaryLogPerEmployee;\nexports.employeeBarCode = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const employeeBarCodes = [];\n    const allBarCodes = await barCodeModel_1.default.find({});\n    // Fetch all employees whose IDs are in the barcodes\n    const employeeIds = allBarCodes.map((barcode) => barcode.employeeId);\n    const employees = await employeeModel_1.default.find({ _id: { $in: employeeIds } });\n    employees.forEach((employee) => {\n        const employeeIdString = employee._id.toString();\n        const employeeName = employee.name;\n        const employeeCode = employee.employeeCode;\n        const employeeBarCodeNumbers = allBarCodes\n            .filter((barcode) => barcode.employeeId.toString() === employeeIdString)\n            .map((barcode) => barcode.barCodeNumber);\n        employeeBarCodes.push({\n            name: employeeName,\n            employeeCode: employeeCode,\n            barCodes: employeeBarCodeNumbers,\n        });\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Bar Code.\",\n        employeeBarCodesLength: employeeBarCodes.length,\n        employeeBarCodes,\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/employeeController.ts?");

/***/ }),

/***/ "./src/controllers/employee/employeeDocsController.ts":
/*!************************************************************!*\
  !*** ./src/controllers/employee/employeeDocsController.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uploadEmpDoc = exports.deleteDocs = exports.uploadEmpDocs = exports.allDocuments = exports.getProofPicture = exports.getEmployeeProfile = exports.attendanceApproveImage = exports.uploadProofImage = exports.uploadImage = exports.uploadDocument = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst path_2 = __webpack_require__(/*! path */ \"path\");\nconst barCodeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/barCodeModel */ \"./src/database/models/barCodeModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/attendanceModel */ \"./src/database/models/attendanceModel.ts\"));\n(0, dotenv_1.config)({ path: path_1.default.join(__dirname, \"../../../\", \"public/.env\") });\naws_sdk_1.default.config.update({\n    secretAccessKey: process.env.ACCESS_SECRET,\n    accessKeyId: process.env.ACCESS_KEY,\n    region: process.env.REGION,\n});\nconst BUCKET = process.env.BUCKET;\nif (!BUCKET) {\n    console.error(\"No bucket specified in the environment configuration.\");\n    process.exit(1); // Exit the application or handle the error accordingly\n}\nconst s3 = new aws_sdk_1.default.S3();\n// s3\nexports.uploadDocument = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { groupName, name, jobProfileName, fileName, status } = req.body;\n    const file = req.file;\n    const filter = {};\n    const allowedExtensions = [\n        \".jpg\",\n        \".jpeg\",\n        \".png\",\n        \".pdf\",\n        \".docs\",\n        \".xls\",\n        \".xlsm\",\n        \".xlsx\",\n        \".xlts\",\n        \".rtf\",\n    ];\n    if (groupName) {\n        // find group id from group model\n        const group = await groupModel_1.default.findOne({\n            groupName: groupName,\n        });\n        filter.groupId = group?._id;\n    }\n    if (jobProfileName) {\n        // find allJobProfiles from jobProfile model\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            jobProfileName: jobProfileName,\n        });\n        filter.jobProfileId = jobProfile?._id;\n    }\n    if (name) {\n        filter.$or = [\n            { name: { $regex: name, $options: \"i\" } },\n            { employeeCode: { $regex: name, $options: \"i\" } }, // Search by employeeCode using case-insensitive regex\n        ];\n    }\n    let employees = await employeeModel_1.default.find(filter);\n    const employeeIds = employees.map((emp) => emp._id);\n    // finding employee by group\n    let fileUrl;\n    if (!file) {\n        res.status(400).send(\"No file uploaded.\");\n        return;\n    }\n    const fileExt = (0, path_2.extname)(file.originalname).toLowerCase();\n    if (!allowedExtensions.includes(fileExt)) {\n        return res.status(400).send({\n            success: false,\n            message: \"Invalid file type. Only JPG, JPEG, PNG , pdf ,docs,rtf images are allowed.\",\n        });\n    }\n    const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n    const uploadParams = {\n        Bucket: BUCKET,\n        Key: fileKey,\n        Body: file.buffer,\n        ACL: \"public-read\",\n    };\n    // documentJpg.docs\n    await s3.putObject(uploadParams).promise();\n    fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    for (let i of employeeIds) {\n        let data = await employeeDocsModel_1.default.findOne({ employeeId: i });\n        if (!data) {\n            data = await employeeDocsModel_1.default.create({ employeeId: i });\n        }\n        const document = {\n            docsName: fileName,\n            docs: fileUrl,\n            status: status,\n        };\n        data.employeeId = i;\n        data.document.push(document);\n        await data.save();\n    }\n    res.status(200).json({\n        success: true,\n        message: \"document  added successfully.\",\n    });\n});\nexports.uploadImage = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { employeeId } = req.body;\n    const file = req.file;\n    const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n    // finding employee by group\n    let fileUrl;\n    if (!file) {\n        res.status(400).send(\"No file uploaded.\");\n        return;\n    }\n    const fileExt = (0, path_2.extname)(file.originalname).toLowerCase();\n    if (!allowedExtensions.includes(fileExt)) {\n        return res.status(400).send({\n            success: false,\n            message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n        });\n    }\n    const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n    const uploadParams = {\n        Bucket: BUCKET,\n        Key: fileKey,\n        Body: file.buffer,\n        ACL: \"public-read\",\n    };\n    // documentJpg.docs\n    await s3.putObject(uploadParams).promise();\n    fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    let docs = await employeeDocsModel_1.default.findOne({ employeeId: employeeId });\n    if (!docs) {\n        docs = await employeeDocsModel_1.default.create({ employeeId });\n    }\n    docs.profilePicture = fileUrl;\n    await docs.save();\n    res.status(200).json({\n        success: true,\n        message: \"image added successfully.\",\n        data: docs,\n    });\n});\nexports.uploadProofImage = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { employeeId, data } = req.body;\n    const file = req.file;\n    // finding employee by group\n    const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n    let fileUrl;\n    if (!file) {\n        return res.status(400).json({\n            success: false,\n            message: \"No file uploaded.\",\n        });\n    }\n    const fileExt = (0, path_2.extname)(file.originalname).toLowerCase();\n    if (!allowedExtensions.includes(fileExt)) {\n        return res.status(400).json({\n            success: false,\n            message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n        });\n    }\n    const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n    const uploadParams = {\n        Bucket: BUCKET,\n        Key: fileKey,\n        Body: file.buffer,\n        ACL: \"public-read\",\n    };\n    // documentJpg.docs\n    await s3.putObject(uploadParams).promise();\n    fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    // let barCodeModel = await BarCode.findOne({ barCodeNumber: data });\n    // // if (barCodeModel) {\n    // //   return res.status(400).json({\n    // //     success: false,\n    // //     message: \"Data already present for this bar code\",\n    // //   });\n    // // }\n    let barCodeModel = await barCodeModel_1.default.create({\n        employeeId,\n        barCodeNumber: data,\n        proofPicture: fileUrl,\n        createdAt: new Date(),\n    });\n    res.status(200).json({\n        success: true,\n        message: \"Proof image added successfully.\",\n        barCodeModel,\n    });\n});\n// image saving while approving attendance\nexports.attendanceApproveImage = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const file = req.file;\n    // finding employee by group\n    const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n    let { employeeId, punchInTime, date } = req.body;\n    const employee1 = await employeeModel_1.default.findById(employeeId);\n    if (!employee1) {\n        return next(new errorHandler_1.default(\"Employee not found.\", 404));\n    }\n    const punchIn = new Date(punchInTime);\n    let nextDay;\n    if (date) {\n        date = new Date(date);\n        date.setHours(0, 0, 0, 0);\n        date.setHours(date.getHours() - (6 + 5));\n        nextDay = new Date(date);\n        nextDay.setDate(nextDay.getDate() + 2);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() - (6 + 5));\n    }\n    const attendanceRecord = await attendanceModel_1.default.findOne({\n        employeeId,\n        date: {\n            $gte: date,\n            $lt: nextDay,\n        },\n    });\n    if (!attendanceRecord) {\n        return next(new errorHandler_1.default(\"Attendance record not found.\", 404));\n    }\n    const punchesWithApprovedImage = attendanceRecord.punches.filter((punch) => punch.approvedImage);\n    if (punchesWithApprovedImage.length > 0) {\n        res.status(200).json({\n            success: true,\n            message: \"Approved image already exists.\",\n        });\n    }\n    else {\n        const attendanceDay = attendanceRecord.punches.find((attDay) => {\n            return attDay.punchIn.getTime() === punchIn.getTime();\n        });\n        if (!attendanceDay) {\n            return next(new errorHandler_1.default(\"No PunchIn found for this day.\", 404));\n        }\n        let fileUrl;\n        if (!file) {\n            return res.status(400).json({\n                success: false,\n                message: \"No file uploaded.\",\n            });\n        }\n        const fileExt = (0, path_2.extname)(file.originalname).toLowerCase();\n        if (!allowedExtensions.includes(fileExt)) {\n            return res.status(400).json({\n                success: false,\n                message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n            });\n        }\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        // documentJpg.docs\n        await s3.putObject(uploadParams).promise();\n        fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n        attendanceDay.approvedImage = fileUrl;\n        await attendanceRecord.save();\n        res.status(200).json({\n            success: true,\n            message: \"Approved image added successfully.\",\n            attendanceRecord,\n        });\n    }\n});\nexports.getEmployeeProfile = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const employee = await employeeDocsModel_1.default.findOne({\n        employeeId: id,\n    });\n    if (employee) {\n        resp.status(201).json({\n            success: true,\n            message: \"employee profile getting successfully\",\n            employee,\n        });\n    }\n    else {\n        resp.status(201).json({\n            success: false,\n            message: \"employee invaild\",\n        });\n    }\n});\nexports.getProofPicture = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { id } = req.params;\n    const data = await barCodeModel_1.default.find({\n        employeeId: id,\n    })\n        .populate(\"assignedBy\")\n        .exec();\n    if (data) {\n        resp.status(201).json({\n            success: true,\n            message: \"employee profile getting successfully\",\n            data,\n        });\n    }\n    else {\n        resp.status(201).json({\n            success: false,\n            message: \"employee invaild\",\n        });\n    }\n});\nexports.allDocuments = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const doc = await employeeDocsModel_1.default.find({});\n    resp.status(201).json({\n        success: true,\n        message: \" all employee document successfully\",\n        doc,\n    });\n});\nexports.uploadEmpDocs = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { employeeId } = req.body;\n    const file = req.file;\n    // finding employee by department\n    let fileUrl;\n    if (!file) {\n        res.status(400).send(\"No file uploaded.\");\n        return;\n    }\n    else if (file) {\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        // documentJpg.docs\n        await s3.putObject(uploadParams).promise();\n        fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    }\n    let docs = await employeeDocsModel_1.default.findOne({ employeeId: employeeId });\n    if (!docs) {\n        docs = await employeeDocsModel_1.default.create(docs);\n    }\n    docs.employeeId = employeeId;\n    const obj = {\n        docsName: \"Document\",\n        docs: fileUrl,\n    };\n    docs.document.push(obj);\n    await docs.save();\n    res.status(200).json({\n        success: true,\n        message: \"image added successfully.\",\n        data: docs,\n    });\n});\nexports.deleteDocs = (0, catchAsyncError_1.default)(async (req, res) => {\n    const { employeeCode } = req.query;\n    const filename = req.body.filename;\n    if (employeeCode) {\n        const employee = await employeeModel_1.default.findOne({\n            employeeCode: employeeCode,\n        });\n        if (employee) {\n            const employeeDocs = await employeeDocsModel_1.default.findOne({\n                employeeId: employee.id,\n            });\n            if (!employeeDocs) {\n                return res.status(404).send(\"employeeDocs does not exist.\");\n            }\n            const matchedDocumentIndex = employeeDocs.document.findIndex((doc) => doc.docs === filename);\n            if (matchedDocumentIndex !== -1) {\n                employeeDocs.document.splice(matchedDocumentIndex, 1);\n                employeeDocs.save();\n            }\n            let stringAfterUploads;\n            const parts = filename.split(\"/uploads/\");\n            if (parts.length > 1) {\n                stringAfterUploads = parts[1];\n            }\n            else {\n                res.status(500).send(\"Error deleting file.\");\n            }\n            try {\n                await s3\n                    .deleteObject({ Bucket: BUCKET, Key: stringAfterUploads })\n                    .promise();\n                return res.status(200).json({\n                    success: true,\n                    message: \"Document deleted successfully\",\n                });\n            }\n            catch (error) {\n                return res.status(200).json({\n                    success: false,\n                    message: error.message,\n                });\n            }\n        }\n    }\n    else {\n        return res.status(404).json({\n            success: false,\n            message: \"Employee not found.\",\n        });\n    }\n});\nexports.uploadEmpDoc = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { employeeId, fileName } = req.body;\n    const file = req.file;\n    // finding employee by department\n    let fileUrl;\n    if (!file) {\n        res.status(400).send(\"No file uploaded.\");\n        return;\n    }\n    else if (file) {\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        // documentJpg.docs\n        await s3.putObject(uploadParams).promise();\n        fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    }\n    let docs = await employeeDocsModel_1.default.findOne({ employeeId: employeeId });\n    if (!docs) {\n        docs = await employeeDocsModel_1.default.create(docs);\n    }\n    docs.employeeId = employeeId;\n    const obj = {\n        docsName: fileName,\n        docs: fileUrl,\n    };\n    docs.document.push(obj);\n    await docs.save();\n    res.status(200).json({\n        success: true,\n        message: \"image added successfully.\",\n        data: docs,\n    });\n});\n// export const a = catchErrorAsync(async (req: Request, res: Response) => {\n//   const filename = req.params.filename;\n//   try {\n//     const a= await s3.deleteObject({ Bucket: BUCKET, Key: filename }).promise();\n//     res.send(\"File Deleted Successfully\");\n//   } catch (error) {\n//     res.status(500).send(\"Error deleting file.\");\n//   }\n// });\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/employeeDocsController.ts?");

/***/ }),

/***/ "./src/controllers/employee/groupController.ts":
/*!*****************************************************!*\
  !*** ./src/controllers/employee/groupController.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEmployeeByGroup = exports.getChildGroups = exports.getAllGroupsWithNoParent = exports.getSingleGroup = exports.updateHierarchy = exports.deleteField = exports.updateField = exports.addNewField = exports.allGroup = exports.updateGroup = exports.deleteGroup = exports.addGroup = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\n// add\nexports.addGroup = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let Group = {};\n    let { groupName, description, parentGroupName } = req.body;\n    // find parentGroupID\n    groupName = groupName.trim();\n    let parentGroupId;\n    let parent;\n    if (parentGroupName) {\n        parentGroupId = await groupModel_1.default.findOne({\n            groupName: parentGroupName,\n        });\n        parent = await groupModel_1.default.findOne({ _id: parentGroupId?._id });\n        if (!parent) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Parent group not found.\",\n            });\n        }\n    }\n    const newGroup = await groupModel_1.default.findOne({ groupName: groupName });\n    if (newGroup) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Same named group already present.\",\n        });\n    }\n    if (parentGroupId) {\n        Group = await groupModel_1.default.create({\n            groupName,\n            description,\n            parentGroupId,\n        });\n        const childGroupid = await groupModel_1.default.findOne({\n            groupName: groupName,\n        });\n        if (parent) {\n            parent.childGroupId.push(childGroupid?._id);\n            await parent.save();\n        }\n    }\n    else if (!parentGroupId) {\n        Group = await groupModel_1.default.create({\n            groupName,\n            description,\n        });\n    }\n    resp.status(201).json({\n        success: true,\n        message: \"Created Group successfully.\",\n        Group,\n    });\n});\n// // delete\nexports.deleteGroup = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const groupName = req.body.groupName;\n    const group = await groupModel_1.default.findOne({ groupName });\n    if (group) {\n        const employee = await employeeModel_1.default.find({ groupId: group._id });\n        if (employee.length <= 0) {\n            let docs = await groupModel_1.default.findByIdAndDelete(group._id);\n            resp.status(200).json({\n                success: true,\n                message: \"Deleted Group list successfully.\",\n            });\n        }\n        else {\n            resp.status(400).json({\n                success: false,\n                message: \"Group in linked with employees\",\n            });\n        }\n    }\n    else {\n        resp.status(404).json({\n            success: false,\n            message: \"Group not found.\",\n        });\n    }\n});\n// // update\nexports.updateGroup = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const id = req.params.id;\n    const { groupName, description } = req.body;\n    const group = await groupModel_1.default.findOne({ _id: id });\n    if (group) {\n        const docs = await groupModel_1.default.findByIdAndUpdate({ _id: id }, { groupName: groupName, description: description });\n        resp.status(200).json({\n            success: true,\n            message: \"Updated update group successfully.\",\n            docs,\n        });\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"group invaild\",\n    });\n});\n// // get all\nexports.allGroup = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const docs = await groupModel_1.default.find({});\n    resp.status(200).json({\n        success: true,\n        message: \"All group list.\",\n        docs,\n    });\n});\n// adding new fields in group\nexports.addNewField = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId, fieldName } = req.body;\n    const group = await groupModel_1.default.findById(groupId);\n    if (!group) {\n        return next(new errorHandler_1.default(\"group not found\", 404));\n    }\n    const newField = { fieldName, fieldValue: \"\" };\n    group.newFields.push(newField);\n    await group.save();\n    resp.status(200).json({ message: \"New field added successfully\", group });\n});\n// updating new fields\nexports.updateField = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId, fieldName, fieldValue } = req.body;\n    const group = await groupModel_1.default.findById(groupId);\n    if (!group) {\n        return next(new errorHandler_1.default(\"group not found\", 404));\n    }\n    const fieldToUpdate = group.newFields.find((field) => field.fieldName === fieldName);\n    if (!fieldToUpdate) {\n        return next(new errorHandler_1.default(\"Field not found\", 404));\n    }\n    fieldToUpdate.fieldValue = fieldValue;\n    await group.save();\n    resp.status(200).json({ message: \"Field updated successfully\", group });\n});\n// deleting newFields\nexports.deleteField = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId, fieldName } = req.body;\n    const group = await groupModel_1.default.findById(groupId);\n    if (!group) {\n        return next(new errorHandler_1.default(\"group not found\", 404));\n    }\n    const fieldIndex = group.newFields.findIndex((field) => field.fieldName === fieldName);\n    if (fieldIndex === -1) {\n        return next(new errorHandler_1.default(\"Field not found\", 404));\n    }\n    group.newFields.splice(fieldIndex, 1);\n    await group.save();\n    resp.status(200).json({ message: \"Field deleted successfully\", group });\n});\n// update hierarchy\nexports.updateHierarchy = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { groupName, parentGroupName } = req.body;\n    if (groupName === parentGroupName) {\n        return resp.status(400).json({\n            success: false,\n            message: \"The job profile and parent job profile cannot be same .\",\n        });\n    }\n    // Find job profile ID based on groupName\n    const currentGroup = await groupModel_1.default.findOne({ groupName });\n    if (!currentGroup) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Job Profile not found.\",\n        });\n    }\n    const GroupId = currentGroup._id;\n    if (parentGroupName) {\n        // Find parent job profile ID based on parentGroupName\n        const parentGroup = await groupModel_1.default.findOne({\n            groupName: parentGroupName,\n        });\n        if (!parentGroup) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Parent Job Profile not found.\",\n            });\n        }\n        const parentGroupId = parentGroup._id;\n        if (parentGroup.parentGroupId?.toString() === currentGroup._id.toString()) {\n            const job1 = currentGroup;\n            const job2 = parentGroup;\n            const newArray = job1.childGroupId.filter((e) => String(e) !== String(parentGroup._id));\n            newArray.push(job1._id);\n            const newArray1 = [...job2?.childGroupId];\n            const update1 = await groupModel_1.default\n                .findOneAndUpdate({ _id: currentGroup._id }, { parentGroupId: job2._id, childGroupId: newArray1 }, { new: true })\n                .exec();\n            const update2 = await groupModel_1.default\n                .findOneAndUpdate({ _id: parentGroup._id }, { parentGroupId: job1.parentGroupId, childGroupId: newArray }, { new: true })\n                .exec();\n            return resp.status(200).json({\n                success: true,\n                message: \"Group exchange successfully.\",\n                update1,\n                update2,\n            });\n        }\n        let filter;\n        let update;\n        if (parentGroupId != GroupId) {\n            filter = { _id: GroupId };\n            update = { $set: { parentGroupId } };\n        }\n        // Update current job profile\n        // Update parent job profile\n        const filter2 = { _id: parentGroupId };\n        const update2 = { $push: { childGroupId: GroupId } };\n        // Remove childGroupId from old parent\n        const oldParentGroupId = currentGroup?.parentGroupId;\n        if (oldParentGroupId) {\n            const filter3 = { _id: oldParentGroupId };\n            const update3 = { $pull: { childGroupId: GroupId } };\n            await groupModel_1.default.updateOne(filter3, update3);\n        }\n        await groupModel_1.default.updateOne(filter, update);\n        await groupModel_1.default.updateOne(filter2, update2);\n        resp.status(200).json({\n            success: true,\n            message: \"Updated group successfully.\",\n            currentGroupId: GroupId,\n            parent: parentGroup,\n        });\n    }\n    else {\n        const parent = currentGroup.parentGroupId;\n        if (currentGroup) {\n            currentGroup.parentGroupId = null;\n        }\n        // Remove childGroupId from old parent\n        if (parent) {\n            const oldParentGroup = await groupModel_1.default.findOne({\n                _id: parent,\n            });\n            if (oldParentGroup) {\n                // Use type assertion to suppress TypeScript error\n                const childGroupIdArray = oldParentGroup.childGroupId;\n                const index = childGroupIdArray.indexOf(currentGroup._id);\n                if (index > -1) {\n                    childGroupIdArray.splice(index, 1);\n                    await oldParentGroup.save();\n                }\n            }\n        }\n        await currentGroup?.save();\n        resp.status(200).json({\n            success: true,\n            message: \"Updated group successfully.\",\n            currentGroup,\n            parent,\n        });\n    }\n});\nexports.getSingleGroup = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { groupId } = req.params;\n    if (groupId) {\n        const groupData = await groupModel_1.default.findById(groupId);\n        resp.status(200).json({\n            success: true,\n            message: \"group data successfully.\",\n            groupData,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"employee not found.\",\n        });\n    }\n});\n// getting group data with no parent\nasync function getAllGroupsWithNoParent(req, res) {\n    try {\n        const groups = await groupModel_1.default\n            .find({\n            parentGroupId: null,\n        })\n            .exec();\n        res.status(200).json(groups);\n    }\n    catch (error) {\n        res.status(500).json({ error: \"Internal server error\" });\n    }\n}\nexports.getAllGroupsWithNoParent = getAllGroupsWithNoParent;\n// getting childGroup\nasync function getChildGroups(req, res) {\n    const { groupId } = req.params;\n    try {\n        const group = await groupModel_1.default\n            .findById(groupId)\n            .populate(\"childGroupId\")\n            .exec();\n        if (!group) {\n            return res.status(404).json({ error: \"Group not found\" });\n        }\n        const childGroup = group.childGroupId;\n        res.status(200).json({\n            success: true,\n            group,\n            childGroup,\n        });\n    }\n    catch (error) {\n        res.status(500).json({ error: \"Internal server error\" });\n    }\n}\nexports.getChildGroups = getChildGroups;\nexports.getEmployeeByGroup = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const allGroups = await groupModel_1.default.find({});\n    const allEmployees = await employeeModel_1.default.find({});\n    if (allEmployees && allGroups) {\n        const groupCounts = {};\n        const groupIds = {};\n        allEmployees.forEach((employee) => {\n            const groupId = employee.groupId.toString(); // Assuming groupId is stored as an ObjectId\n            if (groupCounts[groupId]) {\n                groupCounts[groupId]++;\n            }\n            else {\n                groupCounts[groupId] = 1;\n                groupIds[groupId] = employee.groupId; // Store the group ID\n            }\n        });\n        const responseData = allGroups.map((group) => ({\n            groupId: group._id.toString(),\n            groupName: group.groupName,\n            employeeCount: groupCounts[group._id.toString()] || 0,\n        }));\n        resp.status(200).json({\n            success: true,\n            message: \"getting employee count as per group\",\n            responseData,\n        });\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"invalid group or employee\",\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/groupController.ts?");

/***/ }),

/***/ "./src/controllers/employee/jobProfileController.ts":
/*!**********************************************************!*\
  !*** ./src/controllers/employee/jobProfileController.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.emptyAllChildAndParentFields = exports.suggestionForJobProfile = exports.getSingleJobProfile = exports.getChildJobProfile = exports.getAllJobProfileWithNoParent = exports.updateHierarchy = exports.allJobProfile = exports.updateJobDescription = exports.updateJobProfile = exports.deleteJobProfile = exports.addJobProfile = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\n// add\nexports.addJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    let jobProfile = {};\n    let { jobProfileName, jobDescription, parentJobProfileName, employmentType, isSupervisor, } = req.body;\n    // find parentJobProfileID\n    jobProfileName = jobProfileName.trim();\n    let parent;\n    let parentJobProfileId;\n    if (parentJobProfileName) {\n        parentJobProfileId = await jobProfileModel_1.default.findOne({\n            jobProfileName: parentJobProfileName,\n        });\n        parent = await jobProfileModel_1.default.findOne({ _id: parentJobProfileId?._id });\n        if (!parent) {\n            return resp.json(404).json({\n                success: false,\n                message: \"Parent job profile not found.\",\n            });\n        }\n    }\n    const currentJobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n    if (currentJobProfile) {\n        return resp.status(400).json({\n            success: false,\n            message: \"Job Profile with same name already present.\",\n        });\n    }\n    if (parentJobProfileId) {\n        jobProfile = await jobProfileModel_1.default.create({\n            jobProfileName,\n            jobDescription,\n            parentJobProfileId,\n            employmentType,\n            isSupervisor: isSupervisor,\n        });\n        const currentJobProfileId = await jobProfileModel_1.default.findOne({\n            jobProfileName: jobProfileName,\n        });\n        if (parent) {\n            parent.childProfileId.push(currentJobProfileId?._id);\n            await parent.save();\n        }\n    }\n    else if (!parentJobProfileId) {\n        jobProfile = await jobProfileModel_1.default.create({\n            jobProfileName,\n            jobDescription,\n            employmentType,\n            isSupervisor: isSupervisor,\n        });\n    }\n    resp.status(201).json({\n        success: true,\n        message: \"Created Job Profile successfully.\",\n        jobProfile,\n    });\n});\n// // delete\nexports.deleteJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    if (!id) {\n        resp.status(400).json({\n            success: false,\n            message: \"jobProfile id not found\",\n        });\n    }\n    const jobProfile = await jobProfileModel_1.default.findById(id);\n    if (jobProfile) {\n        const matchingEmployees = await employeeModel_1.default.find({\n            jobProfileId: jobProfile._id,\n        });\n        const numberOfEmployees = matchingEmployees.length;\n        const update1 = await jobProfileModel_1.default.find({\n            parentJobProfileId: jobProfile._id,\n        }).exec();\n        if (numberOfEmployees > 0) {\n            resp.status(200).json({\n                success: false,\n                message: \"JobProfile contains employee you can't delete that.\",\n                numberOfEmployees: numberOfEmployees,\n            });\n        }\n        else if (update1.length > 0) {\n            resp.status(200).json({\n                success: false,\n                message: \"JobProfile can't delete because it is parent of some jobprofile.\",\n            });\n        }\n        else {\n            const jobProfile = await jobProfileModel_1.default.findByIdAndDelete(id);\n            resp.status(200).json({\n                success: true,\n                message: \"jobProfile deleted successfully.\",\n                numberOfEmployees: numberOfEmployees,\n            });\n        }\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"jobProfile not found.\",\n        });\n    }\n});\n// // update\nexports.updateJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const id = req.params.id;\n    const { jobProfileName, jobDescription, isSupervisor } = req.body;\n    const jobprofile = await jobProfileModel_1.default.findOne({ _id: id });\n    if (jobprofile) {\n        const docs = await jobProfileModel_1.default.findByIdAndUpdate({ _id: id }, {\n            jobProfileName: jobProfileName,\n            jobDescription: jobDescription,\n            isSupervisor: isSupervisor,\n        }, { new: true });\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Updated jobprofile successfully.\",\n    });\n});\n// update jobDescription\nexports.updateJobDescription = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { jobprofielId, jobDescription } = req.body;\n    const filter = { _id: jobprofielId };\n    const update = { jobDescription: jobDescription };\n    const docs = await jobProfileModel_1.default.findOneAndUpdate(filter, update, {\n        new: true,\n    });\n    resp.status(200).json({\n        success: true,\n        message: \"Updated jobprofile successfully.\",\n        docs,\n    });\n});\n// // get all\nexports.allJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const jobProfiles = await jobProfileModel_1.default.find({})\n        .populate(\"department\")\n        .exec();\n    if (jobProfiles) {\n        const responseJobProfiles = await Promise.all(jobProfiles.map(async (jobProfile) => {\n            const matchingEmployees = await employeeModel_1.default.find({\n                jobProfileId: jobProfile._id,\n            });\n            const numberOfEmployees = matchingEmployees.length;\n            return {\n                ...jobProfile.toObject(),\n                numberOfEmployees,\n            };\n        }));\n        resp.status(200).json({\n            success: true,\n            message: \"All job profile list with the number of employees.\",\n            docs: responseJobProfiles,\n        });\n    }\n    else {\n        resp.status(404).json({\n            success: false,\n            message: \"No job profiles found.\",\n        });\n    }\n});\n// update hierarchy\nexports.updateHierarchy = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { jobProfileName, parentJobProfileName } = req.body;\n    if (jobProfileName === parentJobProfileName) {\n        return resp.status(400).json({\n            success: false,\n            message: \"The job profile and parent job profile cannot be same .\",\n        });\n    }\n    // Find job profile ID based on jobProfileName\n    const currentJobProfile = await jobProfileModel_1.default.findOne({ jobProfileName });\n    if (!currentJobProfile) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Job Profile not found.\",\n        });\n    }\n    const jobProfileId = currentJobProfile._id;\n    if (parentJobProfileName) {\n        // Find parent job profile ID based on parentJobProfileName\n        const parentJobProfile = await jobProfileModel_1.default.findOne({\n            jobProfileName: parentJobProfileName,\n        });\n        if (!parentJobProfile) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Parent Job Profile not found.\",\n            });\n        }\n        const parentJobProfileId = parentJobProfile._id;\n        if (parentJobProfile.parentJobProfileId?.toString() ===\n            currentJobProfile._id.toString()) {\n            const job1 = currentJobProfile;\n            const job2 = parentJobProfile;\n            const newArray = job1.childProfileId.filter((e) => String(e) !== String(parentJobProfile._id));\n            newArray.push(job1._id);\n            const newArray1 = [...job2?.childProfileId];\n            const update1 = await jobProfileModel_1.default.findOneAndUpdate({ _id: currentJobProfile._id }, { parentJobProfileId: job2._id, childProfileId: newArray1 }, { new: true }).exec();\n            const update2 = await jobProfileModel_1.default.findOneAndUpdate({ _id: parentJobProfile._id }, {\n                parentJobProfileId: job1.parentJobProfileId,\n                childProfileId: newArray,\n            }, { new: true }).exec();\n            return resp.status(200).json({\n                success: true,\n                message: \"JobProfile exchange successfully.\",\n                update1,\n                update2,\n            });\n        }\n        let filter;\n        let update;\n        if (parentJobProfileId != jobProfileId) {\n            filter = { _id: jobProfileId };\n            update = { $set: { parentJobProfileId } };\n        }\n        // Update current job profile\n        // Update parent job profile\n        const filter2 = { _id: parentJobProfileId };\n        const update2 = { $push: { childProfileId: jobProfileId } };\n        // Remove childProfileId from old parent\n        const oldParentJobProfileId = currentJobProfile?.parentJobProfileId;\n        if (oldParentJobProfileId) {\n            const filter3 = { _id: oldParentJobProfileId };\n            const update3 = { $pull: { childProfileId: jobProfileId } };\n            await jobProfileModel_1.default.updateOne(filter3, update3);\n        }\n        await jobProfileModel_1.default.updateOne(filter, update);\n        await jobProfileModel_1.default.updateOne(filter2, update2);\n        resp.status(200).json({\n            success: true,\n            message: \"Updated Job Profile successfully.\",\n            currentJobProfileId: jobProfileId,\n            parent: parentJobProfile,\n        });\n    }\n    else {\n        const parent = currentJobProfile.parentJobProfileId;\n        console.log(`Job profile: ${currentJobProfile.jobProfileName}`);\n        if (currentJobProfile) {\n            currentJobProfile.parentJobProfileId = null;\n            const jobprofile = await jobProfileModel_1.default.find({});\n            for (let i = 0; i < jobprofile.length; i++) {\n                const jobProfile = jobprofile[i];\n                if (jobProfile.childProfileId &&\n                    jobProfile.childProfileId.includes(currentJobProfile._id)) {\n                    const indexToRemove = jobProfile.childProfileId.indexOf(currentJobProfile._id);\n                    jobProfile.childProfileId.splice(indexToRemove, 1);\n                    await jobProfile.save();\n                }\n            }\n            // await currentJobProfile.save();\n        }\n        console.log(\"parent\", parent);\n        // Remove childProfileId from old parent\n        if (parent) {\n            const oldParentJobProfile = await jobProfileModel_1.default.findOne({\n                _id: parent,\n            });\n            console.log(\"oldParentJobProfile\", oldParentJobProfile);\n            if (oldParentJobProfile) {\n                // Use type assertion to suppress TypeScript error\n                const childProfileIdArray = oldParentJobProfile.childProfileId;\n                const index = childProfileIdArray.indexOf(currentJobProfile._id);\n                if (index > -1) {\n                    childProfileIdArray.splice(index, 1);\n                    await oldParentJobProfile.save();\n                }\n            }\n        }\n        await currentJobProfile?.save();\n        resp.status(200).json({\n            success: true,\n            message: \"Updated Job Profile successfully.\",\n            currentJobProfile,\n            parent,\n        });\n    }\n});\n// getting jobProfile data with no parent\nasync function getAllJobProfileWithNoParent(req, res) {\n    try {\n        const jobProfile = await jobProfileModel_1.default.find({\n            parentJobProfileId: null,\n        }).exec();\n        res.status(200).json({\n            success: true,\n            jobProfile,\n        });\n    }\n    catch (error) {\n        res.status(500).json({ error: \"Internal server error\" });\n    }\n}\nexports.getAllJobProfileWithNoParent = getAllJobProfileWithNoParent;\nasync function getChildJobProfile(req, res) {\n    const { jobprofielId } = req.params;\n    try {\n        const jobProfile = await jobProfileModel_1.default.findById(jobprofielId)\n            .populate({\n            path: \"department\",\n        })\n            .populate({\n            path: \"childProfileId\",\n            populate: {\n                path: \"department\",\n            },\n        })\n            .exec();\n        if (!jobProfile) {\n            return res.status(404).json({ error: \"jobProfile not found\" });\n        }\n        const childjobProfiles = jobProfile.childProfileId;\n        res.status(200).json({\n            success: true,\n            jobProfile,\n            childjobProfiles,\n        });\n    }\n    catch (error) {\n        res.status(500).json({ error: \"Internal server error\" });\n    }\n}\nexports.getChildJobProfile = getChildJobProfile;\nexports.getSingleJobProfile = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { id } = req.params;\n    if (id) {\n        const allEmployees = await employeeModel_1.default.find({});\n        const jobProfileData = await jobProfileModel_1.default.findById(id);\n        resp.status(200).json({\n            success: true,\n            message: \"jobprofile data successfully.\",\n            jobProfileData,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"jobprofile not found.\",\n        });\n    }\n});\n// suggestion for heirarchy\nconst suggestionForJobProfile = async (req, resp, next) => {\n    try {\n        const { jobprofileId } = req.params;\n        const jobprofileDetails = await jobProfileModel_1.default.findById(jobprofileId);\n        if (!jobprofileDetails) {\n            return resp.status(404).json({\n                success: false,\n                message: `Job profile with Id ${jobprofileId} not found.`,\n            });\n        }\n        const suggestionsArray = [];\n        const allJobProfiles = await jobProfileModel_1.default.find().lean();\n        const allJobProfileStore = {};\n        allJobProfiles.forEach((a) => {\n            const id = a._id + \"\";\n            allJobProfileStore[id] = {\n                ...a,\n            };\n        });\n        if (!jobprofileDetails.parentJobProfileId) {\n            allJobProfiles.forEach((a) => {\n                const id = a._id + \"\";\n                if (id !== jobprofileDetails._id + \"\") {\n                    const obj = {\n                        jobProfileName: a.jobProfileName,\n                        _id: a._id,\n                    };\n                    suggestionsArray.push(obj);\n                }\n            });\n        }\n        else {\n            jobprofileDetails.childProfileId.forEach((j) => {\n                const id = j + \"\";\n                const jobProfile = allJobProfileStore[id];\n                const obj = {\n                    jobProfileName: jobProfile?.jobProfileName,\n                    _id: jobProfile?._id,\n                };\n                suggestionsArray.push(obj);\n            });\n        }\n        resp.status(200).json({\n            success: true,\n            message: `Getting suggestion successfully.`,\n            suggestionsArray,\n            // allJobProfileStore\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n};\nexports.suggestionForJobProfile = suggestionForJobProfile;\nconst emptyAllChildAndParentFields = async (req, res) => {\n    try {\n        // Update all documents in the \"JobProfile\" collection\n        const updateResult = await jobProfileModel_1.default.updateMany({}, {\n            $set: {\n                childProfileId: [],\n                parentJobProfileId: null,\n            },\n        });\n        return res.status(200).json({\n            message: \"ChildProfileId and ParentJobProfileId cleared in all documents.\",\n        });\n    }\n    catch (error) {\n        console.error(error);\n        return res.status(500).json({\n            message: \"An error occurred while clearing fields in all documents.\",\n        });\n    }\n};\nexports.emptyAllChildAndParentFields = emptyAllChildAndParentFields;\n// ass\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/jobProfileController.ts?");

/***/ }),

/***/ "./src/controllers/employee/loggInHistoryController.ts":
/*!*************************************************************!*\
  !*** ./src/controllers/employee/loggInHistoryController.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deleteLoginHistory = exports.getLoggedInUserHistory = void 0;\nconst loginHistoryModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/loginHistoryModel */ \"./src/database/models/loginHistoryModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nexports.getLoggedInUserHistory = (0, catchAsyncError_1.default)(async (req, res) => {\n    if (req.admin) {\n        let { limit = 20, page = 1, date, nextDate, } = req.query;\n        limit = +limit;\n        page = +page;\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 1);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 1);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const skip = (page - 1) * limit;\n        const forTotalNumber = await loginHistoryModel_1.default.find().exec();\n        const logs = await loginHistoryModel_1.default\n            .find()\n            .limit(limit)\n            .skip(skip)\n            .sort({ logInTime: -1 })\n            .exec();\n        if (logs.length > 0) {\n            res.status(200).json({\n                status: true,\n                message: \"Successfully fetched login history\",\n                totalLogs: forTotalNumber.length,\n                data: logs,\n            });\n        }\n        else {\n            res.status(200).json({\n                status: false,\n                message: \"No login history found\",\n            });\n        }\n    }\n    else {\n        res.status(401).json({\n            status: false,\n            message: \"You are not authorized to access this route\",\n        });\n    }\n});\nexports.deleteLoginHistory = (0, catchAsyncError_1.default)(async (req, res) => {\n    if (req.admin) {\n        const { id } = req.params;\n        const log = await loginHistoryModel_1.default.findByIdAndDelete(id).exec();\n        if (log) {\n            res.status(200).json({\n                succss: true,\n                message: \"Successfully deleted login history\",\n            });\n        }\n        else {\n            res.status(200).json({\n                succss: false,\n                message: \"Failed to delete login history\",\n            });\n        }\n    }\n    else {\n        res.status(401).json({\n            status: false,\n            message: \"You are not authorized to access this route\",\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/loggInHistoryController.ts?");

/***/ }),

/***/ "./src/controllers/employee/otpController.ts":
/*!***************************************************!*\
  !*** ./src/controllers/employee/otpController.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyOtp = exports.getOtp = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"axios\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst getOtp = async (req, res) => {\n    let { phoneNumber } = req.query;\n    phoneNumber = Number(phoneNumber);\n    if (!phoneNumber) {\n        return res.status(400).json({\n            success: false,\n            message: \"Phone no. is not valid\"\n        });\n    }\n    else {\n        const emp = await employeeModel_1.default.findOne({ contactNumber: phoneNumber });\n        if (!emp) {\n            return res.status(404).json({\n                success: false,\n                message: `Employee not Found by This ${phoneNumber}.`\n            });\n        }\n        const { data } = await axios_1.default.get(`https://2factor.in/API/V1/${process.env.OTP_API_KEY}/SMS/${phoneNumber}/AUTOGEN/Temp1`);\n        res.send({\n            data: data,\n            employee: emp\n        });\n    }\n};\nexports.getOtp = getOtp;\nconst verifyOtp = async (req, res) => {\n    let { otp, phoneNumber } = req.query;\n    phoneNumber = Number(phoneNumber);\n    otp = Number(otp);\n    const { data } = await axios_1.default.get(`https://2factor.in/API/V1/${process.env.OTP_API_KEY}/SMS/VERIFY3/${phoneNumber}/${otp}`);\n    if (data.Status === \"Success\") {\n        const emp = await employeeModel_1.default.findOne({ contactNumber: phoneNumber });\n        if (!emp) {\n            return res.status(404).json({\n                success: false,\n                message: \"Employee not found.\"\n            });\n        }\n        else {\n            emp.verified = true;\n            const employee = await emp.save();\n            res.send({\n                success: \"true\",\n                message: \"OTP verify Successfully\",\n                data: data,\n                employee\n            });\n        }\n    }\n    else {\n        res.send({\n            success: \"false\",\n            message: \"OTP Not verified\",\n            data: data\n        });\n    }\n};\nexports.verifyOtp = verifyOtp;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/otpController.ts?");

/***/ }),

/***/ "./src/controllers/employee/quizController.ts":
/*!****************************************************!*\
  !*** ./src/controllers/employee/quizController.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deleteQuestion = exports.updateQuestion = exports.addQuestion = exports.submitAnswer = exports.getQuizQuestion = void 0;\nconst quizModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/quizModel */ \"./src/database/models/quizModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\n// Shuffle array function\nconst shuffleArray = (array) => {\n    const shuffledArray = [...array];\n    for (let i = shuffledArray.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];\n    }\n    return shuffledArray;\n};\n// get Quiz questions\nconst getQuizQuestion = async (req, res, next) => {\n    try {\n        const { jobProfileId } = req.body;\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            _id: req.employee?.jobProfileId || jobProfileId,\n        });\n        const questions = await quizModel_1.default.find({ jobProfileId }).select(\"-correctAnswer\");\n        res.status(200).json({\n            success: true,\n            message: `getting question for ${jobProfile?.jobProfileName} Job profile.`,\n            questions,\n        });\n    }\n    catch (err) {\n        console.error(err);\n        res.status(500).json({ error: \"Server error\" });\n    }\n};\nexports.getQuizQuestion = getQuizQuestion;\n// submit the test\nconst submitAnswer = async (req, res, next) => {\n    if (req.employee || req.admin) {\n        const submittedAnswers = req.body.answers;\n        let jobProfile = req.body.jobProfileId;\n        if (jobProfile) {\n            jobProfile = await jobProfileModel_1.default.findById({ _id: req.employee?.jobProfileId || jobProfile });\n        }\n        else {\n            return next(new errorHandler_1.default(\"Login First\", 403));\n        }\n        try {\n            const questions = await quizModel_1.default.find({ jobProfileId: jobProfile?._id });\n            let score = 0;\n            for (let i = 0; i < questions.length; i++) {\n                if (questions[i].correctAnswer === submittedAnswers[i]) {\n                    score++;\n                }\n            }\n            const percent = (score / questions.length) * 100;\n            const employee = await employeeModel_1.default.findById(req.employee?._id);\n            employee?.marks.push(score);\n            if (employee) {\n                if (percent > 35) {\n                    employee.trainingStatus = \"Pass\";\n                }\n                else {\n                    employee.trainingStatus = \"Fail\";\n                }\n                await employee.save();\n            }\n            res.status(200).json({\n                success: true,\n                message: \"Getting result successfully.\",\n                percent,\n                score,\n            });\n        }\n        catch (err) {\n            console.error(err);\n            res.status(500).json({ error: \"Server error\" });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login In first\", 404));\n    }\n};\nexports.submitAnswer = submitAnswer;\n// add question\nconst addQuestion = async (req, res, next) => {\n    const { question, options, correctAnswer, points, jobProfile } = req.body;\n    if (req.employee || req.admin) {\n        const job = await jobProfileModel_1.default.findOne({ jobProfileName: jobProfile });\n        const jobProfileId = job?._id;\n        try {\n            const newQuestion = new quizModel_1.default({\n                question,\n                options,\n                correctAnswer,\n                points,\n                jobProfileId,\n                createdBy: req?.employee?._id || req.admin?._id,\n            });\n            await newQuestion.save();\n            res.status(201).json({\n                success: true,\n                message: \"Question added successfully\",\n            });\n        }\n        catch (err) {\n            console.error(err);\n            res.status(500).json({ error: \"Server error\" });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first \", 403));\n    }\n};\nexports.addQuestion = addQuestion;\n// update Question\nconst updateQuestion = async (req, res, next) => {\n    if (req.employee || req.admin) {\n        const { question, options, correctAnswer } = req.body;\n        const questionId = req.params.id;\n        try {\n            const updatedQuestion = await quizModel_1.default.findByIdAndUpdate(questionId, {\n                question,\n                options,\n                correctAnswer,\n                createdBy: req?.employee?._id || req.admin?._id,\n            }, { new: true });\n            if (!updatedQuestion) {\n                return next(new errorHandler_1.default(\"Question not found\", 404));\n            }\n            res.status(200).json({\n                success: true,\n                message: \"Question updated Successfully\",\n                updatedQuestion,\n            });\n        }\n        catch (err) {\n            console.error(err);\n            res.status(500).json({ error: \"Server error\" });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login First to update the question\", 403));\n    }\n};\nexports.updateQuestion = updateQuestion;\n// delete Question\nconst deleteQuestion = async (req, res, next) => {\n    if (req.employee || req.admin) {\n        const questionId = req.params.id;\n        try {\n            const updatedQuestion = await quizModel_1.default.findByIdAndDelete(questionId, {\n                new: true,\n            });\n            if (!updatedQuestion) {\n                return next(new errorHandler_1.default(\"Question not found\", 404));\n            }\n            res.status(200).json({\n                success: true,\n                message: \"Question Deleted Successfully.\",\n                updatedQuestion,\n            });\n        }\n        catch (err) {\n            console.error(err);\n            res.status(500).json({ error: \"Server error\" });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login First to delete the question\", 403));\n    }\n};\nexports.deleteQuestion = deleteQuestion;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/quizController.ts?");

/***/ }),

/***/ "./src/controllers/employee/salaryChangeController.ts":
/*!************************************************************!*\
  !*** ./src/controllers/employee/salaryChangeController.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.changeSalary = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst salaryLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/salaryLogModel */ \"./src/database/models/salaryLogModel.ts\"));\nexports.changeSalary = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    try {\n        const employees = await employeeModel_1.default.find({});\n        if (employees && employees.length > 0) {\n            const currentDate = new Date();\n            currentDate.setHours(0, 0, 0, 0);\n            const month = currentDate.getMonth() + 1;\n            let year = currentDate.getUTCFullYear();\n            const firstDate = new Date(year, month - 1, 1);\n            for (const emp of employees) {\n                const salaryRecords = await salaryLogModel_1.default.find({\n                    employeeId: emp._id,\n                    applicableMonth: {\n                        $gte: firstDate,\n                        $lt: currentDate,\n                    },\n                });\n                if (salaryRecords.length > 0) {\n                    console.log(\"HII\");\n                    emp.salary = salaryRecords[salaryRecords.length - 1].salary;\n                }\n                await emp.save();\n                //console.log(\"Api called\")\n            }\n            res.status(200).json({\n                success: true,\n                message: \"Employee Active Status Changed.\",\n            });\n        }\n        else {\n            res.status(200).json({\n                success: true,\n                message: \"No employees found to update.\",\n            });\n        }\n    }\n    catch (error) {\n        next(error);\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/salaryChangeController.ts?");

/***/ }),

/***/ "./src/controllers/employee/salaryController.ts":
/*!******************************************************!*\
  !*** ./src/controllers/employee/salaryController.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.month = exports.getMonthlySalary = exports.newGetSalary = exports.getSalary = void 0;\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst department_1 = __importDefault(__webpack_require__(/*! ../../database/models/department */ \"./src/database/models/department.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst v2attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/v2attendanceModel */ \"./src/database/models/v2attendanceModel.ts\"));\nconst workingDayModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workingDayModel */ \"./src/database/models/workingDayModel.ts\"));\nconst salaryLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/salaryLogModel */ \"./src/database/models/salaryLogModel.ts\"));\nconst months = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n];\nexports.getSalary = (0, catchAsyncError_1.default)(async (req, resp) => {\n    const { jobProfileName, groupName, name, departmentName, employmentStatus, page = 1, limit = 20, } = req.query;\n    let jobProfileIds = [];\n    const filter = {};\n    if (groupName) {\n        const group = await groupModel_1.default.findOne({ groupName }).exec();\n        if (group) {\n            filter.groupId = group._id;\n        }\n    }\n    if (departmentName) {\n        const department = await department_1.default.findOne({ departmentName });\n        if (!department) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Department not found.\",\n            });\n        }\n        const jobProfiles = await jobProfileModel_1.default.find({\n            department: department._id,\n        });\n        const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n        jobProfileIds = [...jobProfileIds, ...ids];\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    if (jobProfileName) {\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            jobProfileName,\n        }).exec();\n        if (jobProfile) {\n            jobProfileIds = [...jobProfileIds, jobProfile._id];\n            filter.jobProfileId = { $in: jobProfileIds };\n        }\n    }\n    if (employmentStatus) {\n        filter.employeeStatus = employmentStatus;\n    }\n    if (name) {\n        filter.$or = [\n            { name: { $regex: name, $options: \"i\" } },\n            { employeeCode: { $regex: name, $options: \"i\" } },\n        ];\n    }\n    const skip = (page - 1) * limit;\n    let emplys1 = await employeeModel_1.default.find(filter);\n    let emplys = await employeeModel_1.default.find(filter)\n        .populate({\n        path: \"jobProfileId\",\n        select: \"jobProfileName\",\n    })\n        .populate({\n        path: \"groupId\",\n        select: \"groupName\",\n    })\n        .select({\n        name: 1,\n        employeeCode: 1,\n        email: 1,\n        contactNumber: 1,\n        lunchTime: 1,\n        salary: 1,\n        workingDays: 1,\n        workingHours: 1,\n        gender: 1,\n        aadharNumber: 1,\n        ESI_ID: 1,\n        PF_UAN_Number: 1,\n        PAN_Number: 1,\n        overTimeRate: 1,\n        bankDetails: 1,\n    })\n        .skip(skip)\n        .limit(limit)\n        .sort({ createdAt: 1 })\n        .exec();\n    // const employeeIds = emplys.map((employee) => employee._id);\n    // const attendance = await v2AttendanceModel\n    //   .find({ employeeId: employeeIds })\n    //   .select({ employeeId: 1, date: 1, punches: 1 });\n    // const workingHours: any = attendance.map((item: any) => {\n    //   item.punches[item.punches.length - 1].punchOut - item.punches[0].punchIn;\n    // });\n    resp.status(200).json({\n        success: true,\n        message: \"Getting All Employee successfully.\",\n        // employeeIds,\n        // workingHours,\n        // attendance,\n        Total: emplys1.length,\n        emplys,\n    });\n});\nconst newGetSalary = async (req, resp, next) => {\n    try {\n        let employee = null;\n        let jobProfile = null;\n        let { date, nextDate, groupName, departmentName, jobProfileName, employeeCodes, shifts, name, limit = 20, page = 1, } = req.body;\n        limit = +limit;\n        page = +page;\n        const skip = (page - 1) * limit;\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            //filterDate.setHours(filterDate.getHours() +5.5);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            // filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 1);\n            //nextDay.setHours(nextDay.getHours() - 6);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 1);\n            nextDay.setHours(0, 0, 0, 0);\n            // nextDay.setHours(nextDay.getHours() + 5.5);\n        }\n        const filter = {};\n        const filter1 = {};\n        let jobProfileIds = [];\n        if (groupName && Array.isArray(groupName) &&\n            groupName.some((name) => name.trim() !== \"\")) {\n            const nonEmptyGroupNames = groupName.filter((name) => name.trim() !== \"\");\n            const groups = await groupModel_1.default\n                .find({ groupName: { $in: nonEmptyGroupNames } })\n                .exec();\n            const groupIds = groups.map((group) => group._id);\n            filter.groupId = { $in: groupIds };\n        }\n        if (employeeCodes && Array.isArray(employeeCodes)) {\n            const nonEmptyemployeeCode = employeeCodes.filter((name) => name.trim() !== \"\");\n            const employeeCode = nonEmptyemployeeCode.map((emp) => emp);\n            if (employeeCode && employeeCode.length > 0) {\n                filter.employeeCode = { $in: employeeCode };\n            }\n        }\n        // Add departmentName filter if provided and non-empty\n        if (departmentName && Array.isArray(departmentName) &&\n            departmentName.some((name) => name.trim() !== \"\")) {\n            const nonEmptyDepartmentNames = departmentName.filter((name) => name.trim() !== \"\");\n            const departments = await department_1.default\n                .find({ departmentName: { $in: nonEmptyDepartmentNames } })\n                .exec();\n            const departmentIds = departments.map((department) => department._id);\n            const jobProfiles = await jobProfileModel_1.default.find({\n                department: { $in: departmentIds },\n            }).exec();\n            const jobProfileIds = jobProfiles.map((jobProfile) => jobProfile._id);\n            filter.jobProfileId = { $in: jobProfileIds };\n        }\n        // Add jobProfileName filter if provided and non-empty\n        if (jobProfileName && Array.isArray(jobProfileName) &&\n            jobProfileName.some((name) => name.trim() !== \"\")) {\n            const nonEmptyJobProfileNames = jobProfileName.filter((name) => name.trim() !== \"\");\n            const jobProfiles = await jobProfileModel_1.default.find({\n                jobProfileName: { $in: nonEmptyJobProfileNames },\n            }).exec();\n            const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n            jobProfileIds = [...jobProfileIds, ...ids];\n            filter.jobProfileId = { $in: jobProfileIds };\n        }\n        if (name) {\n            filter.$or = [{ name: name }, { employeeCode: name }];\n            filter1.$or = [{ name: name }, { employeeCode: name }];\n        }\n        const employeeIds = await employeeModel_1.default.find(filter)\n            .select({ _id: 1 })\n            .exec();\n        const employeeid = await employeeModel_1.default.find(filter)\n            .select({ _id: 1 })\n            .exec();\n        const empids = employeeid.map((employee) => employee._id);\n        const ids = employeeIds.map((employee) => employee._id);\n        let documnetLength = await v2attendanceModel_1.default.countDocuments({\n            employeeId: { $in: empids },\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        });\n        let attendanceRecords = await v2attendanceModel_1.default\n            .find({\n            employeeId: { $in: ids },\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        }).select(\"-createdAt -updatedAt -__v\")\n            .skip(skip)\n            .limit(limit)\n            .populate({\n            path: \"remarks.by\",\n            model: \"Employee\",\n        })\n            .sort({ date: -1 })\n            .populate({\n            path: \"approvedBy\",\n            select: \"name\",\n        })\n            .populate({\n            path: \"employeeId\",\n            select: [\n                \"jobProfileId\",\n                \"groupId\",\n                \"workingHours\",\n                \"lunchTime\",\n                \"employeeCode\",\n                \"salary\",\n                \"overTime\",\n                \"contactNumber\",\n                \"name\",\n                \"role\",\n            ],\n            populate: [\n                {\n                    path: \"jobProfileId\",\n                    select: \"jobProfileName\",\n                    populate: {\n                        path: \"department\",\n                        select: \"departmentName\",\n                    },\n                },\n                {\n                    path: \"groupId\",\n                    select: \"groupName\",\n                },\n            ],\n        })\n            .populate({\n            path: \"punches\",\n            populate: [\n                {\n                    path: \"punchInBy\",\n                    select: \"name\",\n                },\n                {\n                    path: \"punchOutBy\",\n                    select: \"name\",\n                },\n            ],\n        })\n            .exec();\n        // Now, the \"department\" field within \"jobProfileId\" should be populated correctly.\n        if (shifts && Array.isArray(shifts)) {\n            const nonEmptyshift = shifts.filter((name) => name.trim() !== \"\");\n            const shift = nonEmptyshift.map((emp) => emp.toLowerCase());\n            if (shift && shift.length > 0) {\n                attendanceRecords = await v2attendanceModel_1.default\n                    .find({\n                    employeeId: { $in: ids },\n                    date: {\n                        $gte: filterDate,\n                        $lt: nextDay,\n                    },\n                    shift: { $in: shift },\n                })\n                    .populate({\n                    path: \"remarks.by\",\n                    model: \"Employee\",\n                })\n                    .sort({ date: -1 })\n                    .populate({\n                    path: \"remarks.by\",\n                    model: \"Employee\",\n                })\n                    .sort({ date: -1 })\n                    .populate({\n                    path: \"approvedBy\",\n                    select: \"name\",\n                })\n                    .populate({\n                    path: \"employeeId\",\n                    select: [\n                        \"jobProfileId\",\n                        \"groupId\",\n                        \"workingHours\",\n                        \"lunchTime\",\n                        \"employeeCode\",\n                        \"salary\",\n                        \"overTime\",\n                        \"contactNumber\",\n                        \"name\",\n                        \"role\",\n                    ],\n                    populate: [\n                        {\n                            path: \"jobProfileId\",\n                            select: \"jobProfileName\",\n                            populate: {\n                                path: \"department\",\n                                select: \"departmentName\",\n                            },\n                        },\n                        {\n                            path: \"groupId\",\n                            select: \"groupName\",\n                        },\n                    ],\n                })\n                    .populate({\n                    path: \"punches\",\n                    populate: [\n                        {\n                            path: \"punchInBy\",\n                            select: \"name\",\n                        },\n                        {\n                            path: \"punchOutBy\",\n                            select: \"name\",\n                        },\n                    ],\n                })\n                    .exec();\n                documnetLength = await v2attendanceModel_1.default.countDocuments({\n                    employeeId: { $in: empids },\n                    date: {\n                        $gte: filterDate,\n                        $lt: nextDay,\n                    },\n                    shift: { $in: shift },\n                });\n            }\n        }\n        let totalSalaryA = 0;\n        let totalSalaryB = 0;\n        let totalSalaryC = 0;\n        let TotalfinalSalary = 0;\n        let newRecords = [];\n        let year = filterDate.getUTCFullYear();\n        const allAttendance = await v2attendanceModel_1.default\n            .find({\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        }).select({ employeeId: 1, punches: 1 })\n            .populate(\"employeeId\")\n            .sort({ date: -1 })\n            .lean();\n        const attendanceStore = {};\n        const month = filterDate.getMonth() + 1;\n        //console.log(month)\n        const firstDate = new Date(year, month - 1, 1);\n        // Create a new Date object for the last day of the month\n        // To get the last day, set the day to 0 of the next month and subtract one day\n        const lastDate = new Date(year, month, 0);\n        console.log(firstDate);\n        console.log(lastDate);\n        const salaryLog = await salaryLogModel_1.default.find({\n            applicableMonth: {\n                $gte: firstDate,\n                $lt: lastDate,\n            },\n        });\n        const salaryStore = {};\n        salaryLog.forEach((a) => {\n            if (a.employeeId) {\n                if (!salaryStore[a.employyeId]) {\n                    salaryStore[a.employeeId] = {\n                        data: []\n                    };\n                }\n            }\n            salaryStore[a.employeeId].data.push({ ...a });\n        });\n        allAttendance.forEach((a) => {\n            // console.log(a)\n            if (a.employeeId) {\n                const employeeId = a.employeeId._id + \"\";\n                if (!attendanceStore[employeeId]) {\n                    attendanceStore[employeeId] = {\n                        data: []\n                    };\n                }\n                ;\n                attendanceStore[employeeId].data.push({ ...a });\n            }\n            ;\n        });\n        // console.log(attendanceStore);\n        let totalDutyHours = 0;\n        let TotaloverTime = 0;\n        const existingYearData = await workingDayModel_1.default.findOne({ year });\n        const new_map = new Map();\n        for (let id of ids) {\n            //  console.log(\"id\",id, \"data \" ,attendanceStore[id+\"\"]);\n            const data = attendanceStore[id + \"\"]?.data || [];\n            let totalDifference = 0;\n            let totalactual = 0;\n            let overTime = 0;\n            let salaryTotalDiffrence = 0;\n            let lunchPresnt = false;\n            if (data) {\n                // Initialize a variable to accumulate the total difference\n                for (let temp of data) {\n                    totalactual += temp.employeeId.workingHours;\n                    for (let p of temp.punches) {\n                        const punchInTT = p.punchIn;\n                        const punchOutTT = p.punchOut;\n                        if (punchInTT && punchOutTT) {\n                            const differ = Math.abs(punchOutTT - punchInTT);\n                            const timedd = differ / (1000 * 60 * 60);\n                            // const punchInHour = punchInTT.getUTCHours();\n                            // const punchOutHour = punchOutTT.getUTCHours();\n                            // const punchInMinute = punchInTT.getUTCMinutes();\n                            // const punchOutMinute = punchOutTT.getUTCMinutes();\n                            // // console.log(punchInHour)\n                            // // console.log(punchOutHour)\n                            // // console.log(punchInMinute)\n                            // // console.log(punchOutMinute)\n                            // if(punchOutHour>1 && punchInHour<=1){\n                            //   lunchPresnt=true\n                            // }\n                            // if(punchOutHour>13 && punchInHour<=13){\n                            //   lunchPresnt=true\n                            // }\n                            // if(punchOutHour==1 && punchOutMinute>=30){\n                            //   lunchPresnt=true\n                            // }\n                            // if(punchOutHour==13 && punchOutMinute>=30){\n                            //   lunchPresnt=true\n                            // }\n                            if (temp.employeeId.workingHours < timedd &&\n                                !temp.employeeId.overTime) {\n                                salaryTotalDiffrence += temp.employeeId.workingHours;\n                            }\n                            else {\n                                salaryTotalDiffrence += timedd;\n                            }\n                        }\n                    }\n                }\n            }\n            //console.log(id,lunchPresnt)\n            new_map.set(id.toString(), {\n                overTime: overTime,\n                length: data?.length,\n                totalactual: totalactual,\n                salaryTotalDiffrence: salaryTotalDiffrence,\n                lunchPresnt: lunchPresnt\n            });\n        }\n        for (const rec of attendanceRecords) {\n            const monthName = months[rec.punches[0].punchIn.getMonth()];\n            let punchInTime = rec.punches[0].punchIn;\n            let punchOutTime = rec.punches[rec.punches.length - 1].punchOut;\n            const originalpunchInTime = new Date(rec.punches[0].punchIn);\n            const originalpunchOutTime = new Date(rec.punches[rec.punches.length - 1].punchOut);\n            // console.log(originalpunchInTime);\n            // console.log(originalpunchOutTime);\n            const salarydata = salaryStore[rec.employeeId._id + \"\"]?.data || [];\n            const salaryDB = salarydata[salarydata.length - 1]?._doc?.salary || rec.employeeId.salary;\n            //console.log(\"Hiiii\",salary)\n            let hours = 0;\n            if (punchInTime != null && punchOutTime !== null) {\n                const punchInHour = punchInTime.getUTCHours();\n                const punchOutHour = punchOutTime.getUTCHours();\n                const punchInMinute = punchInTime.getUTCMinutes();\n                const punchOutMinute = punchOutTime.getUTCMinutes();\n                if (punchInHour < 8) {\n                    //console.log(\"HIII\")\n                    punchInTime.setUTCHours(8);\n                    punchInTime.setUTCMinutes(0);\n                }\n                if (punchInHour === 19) {\n                    punchInTime.setUTCHours(20);\n                    punchInTime.setUTCMinutes(0);\n                }\n                // if(punchOutHour===16  && punchOutMinute>30){\n                //   punchOutTime.setUTCHours(16);\n                //   punchOutTime.setUTCMinutes(30);\n                // }\n                // if(punchOutHour===17  && punchOutMinute<=30){\n                //   punchOutTime.setUTCHours(16);\n                //   punchOutTime.setUTCMinutes(30);\n                // }\n                // if(punchOutHour>=19 && punchOutMinute>30 && punchInHour<19){\n                //   punchOutTime.setUTCHours(19);\n                //   punchOutTime.setUTCMinutes(30);\n                // }\n                const timeDifferenceMs = Math.abs(punchOutTime - punchInTime);\n                //console.log(timeDifferenceMs)\n                hours = timeDifferenceMs / (1000 * 60 * 60);\n                if (hours < 0) {\n                    hours *= -1;\n                }\n            }\n            const tempdata = new_map.get(rec.employeeId._id.toString());\n            if (existingYearData) {\n                const month = existingYearData.month.filter((month) => month.monthName === monthName);\n                let totalWorkingHours = 0;\n                let salaryPerHours = 0;\n                if (month.length > 0) {\n                    if (month[0]?.workingDay) {\n                        totalWorkingHours =\n                            month[0].workingDay * rec.employeeId.workingHours;\n                        salaryPerHours = salaryDB / totalWorkingHours;\n                    }\n                }\n                else {\n                    totalWorkingHours = 30 * rec.employeeId.workingHours;\n                    salaryPerHours = salaryDB / totalWorkingHours;\n                }\n                let salary = 0;\n                let overtime = 0;\n                if (hours > 0.5) {\n                    // if(tempdata.lunchPresnt===true){\n                    hours = Math.abs(hours - rec.employeeId.lunchTime);\n                    //}\n                }\n                if (hours < 0) {\n                    hours = -1 * hours;\n                }\n                if (hours > 1) {\n                    salary = hours * salaryPerHours;\n                }\n                ;\n                //console.log(hours)\n                //if (rec.employeeId.overTime) {\n                // overtime = hours - rec.employeeId.workingHours;\n                // if (overtime < 0) {\n                //   overtime = 0;\n                // }\n                // } else {\n                //   if (hours >= rec.employeeId.workingHours) {\n                //     salary = rec.employeeId.workingHours * salaryPerHours;\n                //   } else {\n                //     salary = hours * salaryPerHours;\n                //   }\n                // }\n                let overTime = 0;\n                if (hours > rec.employeeId.workingHours) {\n                    overTime = overTime + (hours - rec.employeeId.workingHours);\n                }\n                // if (rec.employeeId.overTime) {\n                //   overTime = tempdata.overTime;\n                // }\n                // const salaryB =\n                //   rec.employeeId.workingHours * salaryPerHours +\n                //   overtime * salaryPerHours;\n                const salaryB = rec.employeeId.workingHours * salaryPerHours;\n                totalSalaryB += salaryB;\n                totalSalaryC += tempdata.salaryTotalDiffrence * salaryPerHours;\n                let dutyHours = 0;\n                if (hours >= rec.employeeId.workingHours) {\n                    dutyHours = rec.employeeId.workingHours;\n                }\n                else {\n                    dutyHours = hours;\n                }\n                let tt;\n                if (tempdata.lunchPresnt === true) {\n                    if (tempdata.salaryTotalDiffrence > 0.5) {\n                        tt = tempdata.salaryTotalDiffrence - 0.5;\n                    }\n                }\n                totalSalaryA = totalSalaryA + salary;\n                let finalSalary = rec.employeeId.overTime ? salary : salaryB;\n                TotalfinalSalary += finalSalary;\n                let object = {};\n                object.name = rec?.employeeId?.name;\n                object.groupName = rec?.employeeId?.groupId?.groupName;\n                object.jobProfile = rec?.employeeId?.jobProfileId?.jobProfileName;\n                object.department = rec?.employeeId?.jobProfileId?.department.departmentName;\n                object.role = rec?.employeeId?.role;\n                object.employeeCode = rec?.employeeId?.employeeCode;\n                object.contactNumber = rec?.employeeId?.contactNumber;\n                object.lunchTime = rec?.employeeId?.lunchTime;\n                object.salary = rec?.employeeId?.salary;\n                object.workingHours = rec?.employeeId?.workingHours;\n                object.overTime = rec?.employeeId?.overTime;\n                object.date = rec?.date;\n                object.approvedBy = rec?.approvedBy ? rec.approvedBy.name : \"null\";\n                object.approvedTime = rec?.approvedTime;\n                object.status = rec?.status;\n                object.shift = rec?.shift;\n                object.FirstPunchIn = rec?.punches[0].punchIn;\n                object.FirstPunchInBy = rec?.punches[0].punchInBy ? rec?.punches[0].punchInBy.name : \"\";\n                object.LastPunchOut = rec.punches.length > 0 ? rec?.punches[rec.punches.length - 1]?.punchOut : \"\";\n                object.LastPunchOutBy = rec.punches.length > 0 ? rec?.punches[rec.punches.length - 1]?.punchOutBy ? rec?.punches[rec.punches.length - 1]?.punchOutBy.name : \"\" : \"\";\n                object.totalWorking = rec?.totalWorking;\n                object.remarks = rec?.remarks;\n                object.approvedImage = rec?.approvedImage;\n                //console.log(originalpunchInTime)\n                // console.log(originalpunchOutTime)\n                totalDutyHours += dutyHours;\n                TotaloverTime += overTime;\n                newRecords.push({\n                    totalWorkingHours: totalWorkingHours,\n                    salaryPerHours: salaryPerHours,\n                    firstPunchIn: originalpunchInTime,\n                    lastPunchOut: originalpunchOutTime,\n                    effectivePunchIn: punchInTime,\n                    //effectivePunchOut:punchOutTime,\n                    attendance1: object,\n                    attendance: rec,\n                    SalaryInDay: salary,\n                    finalWorkingHours: hours,\n                    //actualWorkinghours: rec.employeeId.workingHours * tempdata.length,\n                    overTime: overTime,\n                    salaryA: salary,\n                    salaryB: salaryB,\n                    finalSalary: finalSalary,\n                    //salaryC: tempdata.salaryTotalDiffrence * salaryPerHours,\n                    actualworkingHoursbyRecord: tempdata.saralyTotalDiffrence,\n                    dutyHours: dutyHours,\n                    workingHours: tt\n                });\n            }\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"Employee Salary fetched successfully.\",\n            salaryRecords: newRecords,\n            count: documnetLength,\n            totalSalaryA: totalSalaryA,\n            totalSalaryB: totalSalaryB,\n            TotalfinalSalary: TotalfinalSalary,\n            totalDutyHours: totalDutyHours,\n            TotaloverTime: TotaloverTime\n            //totalSalaryC: totalSalaryC,\n        });\n    }\n    catch (error) {\n        //console.log(error);\n    }\n};\nexports.newGetSalary = newGetSalary;\nexports.getMonthlySalary = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let employee = null;\n    let jobProfile = null;\n    let { date, nextDate, groupName, departmentName, jobProfileName, employeeCodes, shifts, name, limit = 20, page = 1, } = req.body;\n    limit = +limit;\n    page = +page;\n    const skip = (page - 1) * limit;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        //filterDate.setHours(filterDate.getHours() +5.5);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        //filterDate.setHours(filterDate.getHours() +5.5);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n        //filterDate.setHours(filterDate.getHours() +5.5);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        //filterDate.setHours(filterDate.getHours() +5.5);\n    }\n    // const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n    // const isAdmin = req.admin;\n    const filter = {};\n    const filter1 = {};\n    let jobProfileIds = [];\n    if (groupName &&\n        Array.isArray(groupName) &&\n        groupName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyGroupNames = groupName.filter((name) => name.trim() !== \"\");\n        const groups = await groupModel_1.default\n            .find({ groupName: { $in: nonEmptyGroupNames } })\n            .exec();\n        const groupIds = groups.map((group) => group._id);\n        filter.groupId = { $in: groupIds };\n    }\n    if (employeeCodes && Array.isArray(employeeCodes)) {\n        const nonEmptyemployeeCode = employeeCodes.filter((name) => name.trim() !== \"\");\n        const employeeCode = nonEmptyemployeeCode.map((emp) => emp);\n        if (employeeCode && employeeCode.length > 0) {\n            filter.employeeCode = { $in: employeeCode };\n        }\n    }\n    // Add departmentName filter if provided and non-empty\n    if (departmentName &&\n        Array.isArray(departmentName) &&\n        departmentName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyDepartmentNames = departmentName.filter((name) => name.trim() !== \"\");\n        const departments = await department_1.default\n            .find({ departmentName: { $in: nonEmptyDepartmentNames } })\n            .exec();\n        const departmentIds = departments.map((department) => department._id);\n        const jobProfiles = await jobProfileModel_1.default.find({\n            department: { $in: departmentIds },\n        }).exec();\n        const jobProfileIds = jobProfiles.map((jobProfile) => jobProfile._id);\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    // Add jobProfileName filter if provided and non-empty\n    if (jobProfileName &&\n        Array.isArray(jobProfileName) &&\n        jobProfileName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyJobProfileNames = jobProfileName.filter((name) => name.trim() !== \"\");\n        const jobProfiles = await jobProfileModel_1.default.find({\n            jobProfileName: { $in: nonEmptyJobProfileNames },\n        }).exec();\n        const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n        jobProfileIds = [...jobProfileIds, ...ids];\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    if (name) {\n        filter.$or = [{ name: name }, { employeeCode: name }];\n        filter1.$or = [{ name: name }, { employeeCode: name }];\n    }\n    const employeeIds = await employeeModel_1.default.find(filter)\n        .skip(skip)\n        .limit(limit)\n        .populate(\"jobProfileId\")\n        .populate({\n        path: \"jobProfileId\",\n        populate: {\n            path: \"department\",\n        },\n    })\n        .populate(\"groupId\")\n        .exec();\n    const employeeid = await employeeModel_1.default.find(filter)\n        .select({ _id: 1 })\n        .exec();\n    const empids = employeeid.map((employee) => employee._id);\n    const ids = employeeIds.map((employee) => employee._id);\n    let documnetLength = employeeid.length;\n    let newRecords = [];\n    let year = filterDate.getUTCFullYear();\n    const allAttendance = await v2attendanceModel_1.default\n        .find({\n        employeeId: { $in: ids },\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    }).select(\"-createdAt -updatedAt -__v\")\n        .select({ employeeId: 1, punches: 1 })\n        .populate({\n        path: \"remarks.by\",\n        model: \"Employee\",\n    })\n        .sort({ date: -1 })\n        .populate({\n        path: \"approvedBy\",\n        select: \"name\",\n    })\n        .populate({\n        path: \"employeeId\",\n        select: [\n            \"jobProfileId\",\n            \"groupId\",\n            \"workingHours\",\n            \"lunchTime\",\n            \"employeeCode\",\n            \"salary\",\n            \"overTime\",\n            \"contactNumber\",\n            \"name\",\n            \"role\",\n        ],\n        populate: [\n            {\n                path: \"jobProfileId\",\n                select: \"jobProfileName\",\n                populate: {\n                    path: \"department\",\n                    select: \"departmentName\",\n                },\n            },\n            {\n                path: \"groupId\",\n                select: \"groupName\",\n            },\n        ],\n    })\n        .populate({\n        path: \"punches\",\n        populate: [\n            {\n                path: \"punchInBy\",\n                select: \"name\",\n            },\n            {\n                path: \"punchOutBy\",\n                select: \"name\",\n            },\n        ],\n    })\n        .sort({ date: -1 })\n        .lean();\n    const attendanceStore = {};\n    allAttendance.forEach((a) => {\n        // console.log(a)\n        if (a.employeeId) {\n            const employeeId = a.employeeId._id + \"\";\n            if (!attendanceStore[employeeId]) {\n                attendanceStore[employeeId] = {\n                    data: []\n                };\n            }\n            ;\n            attendanceStore[employeeId].data.push({ ...a });\n        }\n    });\n    const month = filterDate.getMonth() + 1;\n    //console.log(month)\n    const firstDate = new Date(year, month - 1, 1);\n    const lastDate = new Date(year, month, 0);\n    console.log(firstDate);\n    console.log(lastDate);\n    const salaryLog = await salaryLogModel_1.default.find({\n        applicableMonth: {\n            $gte: firstDate,\n            $lt: lastDate,\n        },\n    });\n    const salaryStore = {};\n    salaryLog.forEach((a) => {\n        if (a.employeeId) {\n            if (!salaryStore[a.employyeId]) {\n                salaryStore[a.employeeId] = {\n                    data: []\n                };\n            }\n        }\n        salaryStore[a.employeeId].data.push({ ...a });\n    });\n    // console.log(attendanceStore);\n    const existingYearData = await workingDayModel_1.default.findOne({ year });\n    let GSalaryA = 0;\n    let GSalaryB = 0;\n    let GoverTime = 0;\n    let GDutyHours = 0;\n    const new_map = new Map();\n    for (let emp of employeeIds) {\n        //  console.log(\"id\",id, \"data \" ,attendanceStore[id+\"\"]);\n        const data = attendanceStore[emp._id + \"\"]?.data || [];\n        const salarydata = salaryStore[emp._id + \"\"]?.data || [];\n        const salaryDB = salarydata[salarydata.length - 1]?._doc?.salary || emp.salary;\n        // console.log(data)\n        let totalDifference = 0;\n        let totalactual = 0;\n        let overTime = 0;\n        let salaryTotalDiffrence = 0;\n        let numberofduty = 0;\n        let approvedduty = 0;\n        let totalWorkingHours = 0;\n        let salaryPerHours = 0;\n        let totalSalaryA = 0;\n        let finalSalary = 0;\n        let dutyPerMonth = 0;\n        let totalHours = 0;\n        let dutyHours = 0;\n        //let overTime = 0\n        if (data) {\n            numberofduty = data.length;\n            for (let temp of data) {\n                //console.log(temp)\n                totalactual += temp.employeeId.workingHours;\n                const monthName = months[temp.punches[0].punchIn.getMonth()];\n                const punchInT = temp.punches[0].punchIn;\n                const punchOutT = temp.punches[temp.punches.length - 1].punchOut;\n                let hours = 0;\n                if (punchInT && punchOutT) {\n                    const punchInHour = punchInT.getUTCHours();\n                    const punchOutHour = punchOutT.getUTCHours();\n                    const punchInMinute = punchInT.getUTCMinutes();\n                    const punchOutMinute = punchOutT.getUTCMinutes();\n                    if (punchInHour < 8) {\n                        punchInT.setUTCHours(8);\n                        punchInT.setUTCMinutes(0);\n                    }\n                    if (punchInHour == 19) {\n                        punchInT.setUTCHours(20);\n                        punchInT.setUTCMinutes(0);\n                    }\n                    // if(punchOutHour==16  && punchOutMinute>30){\n                    //   punchOutT.setUTCHours(16);\n                    //   punchOutT.setUTCMinutes(30);\n                    // }\n                    // if(punchOutHour==17  && punchOutMinute<=30){\n                    //   punchOutT.setUTCHours(16);\n                    //   punchOutT.setUTCMinutes(30);\n                    // }\n                    // if(punchOutHour>=19 && punchOutMinute>30 && punchInHour<19){\n                    //   punchOutT.setUTCHours(16);\n                    //   punchOutT.setUTCMinutes(30);\n                    // }\n                    const diff = punchOutT - punchInT;\n                    //console.log(\"diff\",diff)\n                    const timed = diff / (1000 * 60 * 60);\n                    hours = timed;\n                    if (hours < 0) {\n                        hours *= -1;\n                    }\n                    if (temp.employeeId.workingHours < timed &&\n                        !temp.employeeId.overTime) {\n                        totalDifference += temp.employeeId.workingHours;\n                    }\n                    else {\n                        totalDifference += timed;\n                    }\n                }\n                if (temp.status === \"approved\") {\n                    approvedduty += 1;\n                }\n                let lunchPresent = false;\n                for (let p of temp.punches) {\n                    const punchInTT = p.punchIn;\n                    const punchOutTT = p.punchOut;\n                    if (punchInTT && punchOutTT) {\n                        const punchInHour = punchInTT.getUTCHours();\n                        const punchOutHour = punchOutTT.getUTCHours();\n                        const punchInMinute = punchInTT.getUTCMinutes();\n                        const punchOutMinute = punchOutTT.getUTCMinutes();\n                        if (punchOutHour > 1 && punchInHour <= 1) {\n                            lunchPresent = true;\n                        }\n                        if (punchOutHour > 13 && punchInHour <= 13) {\n                            lunchPresent = true;\n                        }\n                        if (punchOutHour == 1 && punchOutMinute >= 30) {\n                            lunchPresent = true;\n                        }\n                        if (punchOutHour == 13 && punchOutMinute >= 30) {\n                            lunchPresent = true;\n                        }\n                        const differ = punchOutTT - punchInTT;\n                        const timedd = differ / (1000 * 60 * 60);\n                        if (temp.employeeId.workingHours < timedd &&\n                            !temp.employeeId.overTime) {\n                            salaryTotalDiffrence += temp.employeeId.workingHours;\n                        }\n                        else {\n                            salaryTotalDiffrence += timedd;\n                        }\n                    }\n                }\n                if (existingYearData) {\n                    const month = existingYearData.month.filter((month) => month.monthName === monthName);\n                    if (month.length > 0) {\n                        if (month[0]?.workingDay) {\n                            dutyPerMonth = month[0].workingDay;\n                            totalWorkingHours =\n                                month[0].workingDay * temp.employeeId.workingHours;\n                            salaryPerHours = salaryDB / totalWorkingHours;\n                        }\n                    }\n                    else {\n                        dutyPerMonth = 30;\n                        totalWorkingHours = 30 * temp.employeeId.workingHours;\n                        salaryPerHours = salaryDB / totalWorkingHours;\n                    }\n                    let salary = 0;\n                    if (hours > 0.5) {\n                        // if(lunchPresent){\n                        hours = Math.abs(hours - temp.employeeId.lunchTime);\n                        //}\n                    }\n                    // if (temp.employeeId.overTime) {\n                    if (hours < 0) {\n                        hours *= -1;\n                    }\n                    if (hours > 1) {\n                        salary = hours * salaryPerHours;\n                    }\n                    //console.log(hours)\n                    totalHours += hours;\n                    if (hours > temp.employeeId.workingHours) {\n                        overTime = overTime + (hours - temp.employeeId.workingHours);\n                    }\n                    // } else {\n                    //   if (hours >= temp.employeeId.workingHours) {\n                    //     salary = temp.employeeId.workingHours * salaryPerHours;\n                    //     totalHours+=temp.employeeId.workingHours\n                    //   } else {\n                    //     salary = hours * salaryPerHours;\n                    //     totalHours+=hours\n                    //   }\n                    // }\n                    totalSalaryA += salary;\n                }\n                finalSalary = temp.employeeId.overTime ? totalSalaryA : totalactual * salaryPerHours;\n                if (hours >= temp.employeeId.workingHours) {\n                    dutyHours = dutyHours + temp.employeeId.workingHours;\n                }\n                else {\n                    dutyHours = dutyHours + hours;\n                }\n            }\n            if (numberofduty > 0) {\n                GSalaryA += totalSalaryA;\n                GSalaryB += (totalactual * salaryPerHours);\n                GDutyHours += dutyHours;\n                GoverTime += overTime;\n                newRecords.push({\n                    dutyPerMonth: dutyPerMonth,\n                    overTime: overTime,\n                    length: data.length,\n                    totalactual: totalactual,\n                    sumActualWorkingHours: totalactual,\n                    sumFinalWorkingHours: totalDifference,\n                    numberofduty: numberofduty,\n                    approvedduty: approvedduty,\n                    salaryA: totalSalaryA,\n                    salaryB: totalactual * salaryPerHours,\n                    //salaryC: salaryTotalDiffrence * salaryPerHours,\n                    finalSalary: finalSalary,\n                    employee: emp,\n                    totalWorkingHours: totalWorkingHours,\n                    salaryPerHours: salaryPerHours,\n                    sumDutyHours: dutyHours,\n                    totalHours: totalHours\n                });\n            }\n        }\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Employee Salary fetched successfully.\",\n        salaryRecords: newRecords,\n        GSalaryA: GSalaryA,\n        GSalaryB: GSalaryB,\n        GoverTime: GoverTime,\n        GDutyHours: GDutyHours,\n        count: documnetLength,\n    });\n});\nexports.month = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    try {\n        const getAllEmployee = await employeeModel_1.default.find({}).lean();\n        // Create an array to store the salary log data\n        const salaryLogs = [];\n        for (let employee of getAllEmployee) {\n            console.log(employee.name);\n            const salaryLogData = {\n                employeeId: employee._id,\n                salary: employee.salary,\n                applicableMonth: new Date(\"2023-10-01\"),\n                changedBy: \"64a3f3353d41be4135d71b31\",\n            };\n            // Push the salary log data into the array\n            salaryLogs.push(salaryLogData);\n        }\n        // Create and save SalaryLogModel instances in bulk\n        const savedSalaryLogs = await salaryLogModel_1.default.create(salaryLogs);\n        return res.json({\n            status: \"done\",\n            savedSalaryLogs,\n        });\n    }\n    catch (error) {\n        // Handle any errors here\n        next(error);\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/salaryController.ts?");

/***/ }),

/***/ "./src/controllers/employee/scanSlipController.ts":
/*!********************************************************!*\
  !*** ./src/controllers/employee/scanSlipController.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getScannedSlip = exports.addOrUpdateScanSlip = void 0;\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst path_2 = __webpack_require__(/*! path */ \"path\");\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst scanSlipModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/scanSlipModel */ \"./src/database/models/scanSlipModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\n(0, dotenv_1.config)({ path: path_1.default.join(__dirname, \"../../../\", \"public/.env\") });\naws_sdk_1.default.config.update({\n    secretAccessKey: process.env.ACCESS_SECRET,\n    accessKeyId: process.env.ACCESS_KEY,\n    region: process.env.REGION,\n});\nconst BUCKET = process.env.BUCKET;\nif (!BUCKET) {\n    console.error(\"No bucket specified in the environment configuration.\");\n    process.exit(1);\n}\nconst s3 = new aws_sdk_1.default.S3();\nconst addOrUpdateScanSlip = async (req, res) => {\n    try {\n        const { date, shift, shopName, registered, manual } = req.body;\n        let scannedSlip = [];\n        const file = req.file;\n        if (file) {\n            scannedSlip = [await UploadToBucket(file)];\n            if (scannedSlip === false) {\n                return res.status(400).json({ error: \"error while uploading image\" });\n            }\n        }\n        const shop = await shopModel_1.default.findOne({ shopName: shopName });\n        if (!shop) {\n            res\n                .status(400)\n                .json({ success: false, message: \"Shop name is not found\" });\n            return;\n        }\n        let scanSlip = await scanSlipModel_1.default.findOne({ date, shift });\n        if (!scanSlip) {\n            // If the scan slip doesn't exist for the specified date, create a new one\n            scanSlip = new scanSlipModel_1.default({ date, shift, shop: [] });\n        }\n        const shopIndex = scanSlip.shop.findIndex((shopItem) => shopItem.shop.equals(shop._id));\n        if (shopIndex !== -1) {\n            // If the shop exists, update the scannedSlip, manual, and registered values\n            const existingShop = scanSlip.shop[shopIndex];\n            const existingScannedSlip = new Set(existingShop.scannedSlip);\n            scannedSlip.forEach((value) => existingScannedSlip.add(value));\n            existingShop.scannedSlip = Array.from(existingScannedSlip);\n            // Update the manual and registered values for the shop\n            if (manual) {\n                existingShop.manual = Number(existingShop.manual) + Number(manual);\n            }\n            if (registered) {\n                existingShop.registered =\n                    Number(existingShop.registered) + Number(registered);\n            }\n            // existingShop.manual = Number(existingShop.manual) + Number(manual);\n            // existingShop.registered =\n            // Number(existingShop.registered) + Number(registered);\n        }\n        else {\n            const newShopEntry = {\n                shop: shop._id,\n                shopName: shop.shopName,\n                scannedSlip,\n                registered,\n                manual,\n            };\n            scanSlip.shop.push(newShopEntry);\n        }\n        await scanSlip.save();\n        res.status(201).json({ message: \"Scan slip added/updated successfully\" });\n    }\n    catch (error) {\n        console.error(error);\n        res.status(500).json({ message: \"Error adding/updating scan slip\" });\n    }\n};\nexports.addOrUpdateScanSlip = addOrUpdateScanSlip;\nconst UploadToBucket = async (file) => {\n    const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n    let fileUrl;\n    if (!file) {\n        return false;\n    }\n    const fileExt = (0, path_2.extname)(file.originalname).toLowerCase();\n    if (!allowedExtensions.includes(fileExt)) {\n        // const errorMessage = \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\";\n        return false;\n    }\n    const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n    const uploadParams = {\n        Bucket: BUCKET,\n        Key: fileKey,\n        Body: file.buffer,\n        ACL: \"public-read\",\n    };\n    // documentJpg.docs\n    await s3.putObject(uploadParams).promise();\n    fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    return fileUrl;\n};\nexports.getScannedSlip = (0, catchAsyncError_1.default)(async (req, res) => {\n    let { date, shopName, shift } = req.query;\n    let filter = {};\n    try {\n        if (shopName) {\n            const shop = await shopModel_1.default.findOne({ shopName });\n            if (!shop) {\n                return res.status(404).json({\n                    success: false,\n                    message: \"Shop not found\",\n                });\n            }\n            filter[\"shop.shop\"] = shop._id;\n        }\n        if (!date) {\n            const currentDate = new Date();\n            const year = currentDate.getFullYear();\n            const month = (currentDate.getMonth() + 1).toString().padStart(2, \"0\");\n            const day = currentDate.getDate().toString().padStart(2, \"0\");\n            date = `${year}-${month}-${day}`;\n        }\n        if (shift) {\n            filter.shift = shift;\n        }\n        const result = [];\n        if (date) {\n            const slips = await scanSlipModel_1.default.find({ ...filter, date }).lean();\n            slips.forEach((s) => {\n                const shops = [];\n                s.shop.forEach((p) => {\n                    if (shopName) {\n                        if (p.shopName == shopName) {\n                            const obj = {\n                                ...p,\n                            };\n                            shops.push(obj);\n                        }\n                    }\n                    else {\n                        const obj = {\n                            ...p,\n                        };\n                        shops.push(obj);\n                    }\n                });\n                const obj = {\n                    ...s,\n                    shop: shops,\n                };\n                result.push(obj);\n            });\n        }\n        return res.status(200).json({\n            success: true,\n            message: \"Getting scanned slips\",\n            slips: result,\n        });\n    }\n    catch (error) {\n        console.error(\"An error occurred:\", error);\n        return res.status(500).json({\n            success: false,\n            message: \"An error occurred while processing the request\",\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/scanSlipController.ts?");

/***/ }),

/***/ "./src/controllers/employee/trainingController.ts":
/*!********************************************************!*\
  !*** ./src/controllers/employee/trainingController.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getTraining = exports.deleteTrainingData = exports.getTrainingData = exports.addTrainingDocs = exports.addTrainingLinks = void 0;\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst trainingModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/trainingModel */ \"./src/database/models/trainingModel.ts\"));\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\n(0, dotenv_1.config)({ path: path_1.default.join(__dirname, \"../../\", \"public/.env\") });\naws_sdk_1.default.config.update({\n    secretAccessKey: process.env.ACCESS_SECRET,\n    accessKeyId: process.env.ACCESS_KEY,\n    region: process.env.REGION,\n});\nconst BUCKET = process.env.BUCKET;\nif (!BUCKET) {\n    console.error(\"No bucket specified in the environment configuration.\");\n    process.exit(1); // Exit the application or handle the error accordingly\n}\nconst s3 = new aws_sdk_1.default.S3();\nexports.addTrainingLinks = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { groupName, jobProfileName, objArray } = req.body;\n    const filter = {};\n    if (groupName) {\n        const group = await groupModel_1.default.findOne({ groupName: groupName });\n        filter.groupId = group?._id;\n    }\n    if (jobProfileName) {\n        const jobProfile = await jobProfileModel_1.default.findOne({ jobProfileName: jobProfileName });\n        filter.jobProfileId = jobProfile?._id;\n    }\n    let data = await trainingModel_1.default.findOne(filter);\n    if (!data) {\n        // Create a new document if not found\n        data = new trainingModel_1.default(filter);\n    }\n    // Add training materials to the existing or newly created document\n    for (let t of objArray) {\n        // Check if the resourceName already exists in trainingMaterial\n        const existingTraining = data.trainingMaterial.find((training) => training.resourceName === t.resourceName);\n        if (!existingTraining) {\n            data.trainingMaterial.push(t);\n        }\n    }\n    try {\n        await data.save();\n        res.status(200).json({\n            success: true,\n            message: \"Training data added successfully.\",\n            data: data,\n        });\n    }\n    catch (error) {\n        res.status(500).json({\n            success: false,\n            message: \"Error occurred while saving the training data.\",\n            error: error?.message,\n        });\n    }\n});\nexports.addTrainingDocs = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { groupName, jobProfileName, fileName } = req.body;\n    const file = req.file;\n    const filter = {};\n    if (groupName) {\n        // find group id from group model\n        const group = await groupModel_1.default.findOne({\n            groupName: groupName,\n        });\n        filter.groupId = group?._id;\n    }\n    if (jobProfileName) {\n        // find allJobProfiles from jobProfile model\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            jobProfileName: jobProfileName,\n        });\n        filter.jobProfileId = jobProfile?._id;\n    }\n    // finding employee by group\n    let fileUrl;\n    if (!file) {\n        res.status(400).send(\"No file uploaded.\");\n        return;\n    }\n    else if (file) {\n        const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n        const uploadParams = {\n            Bucket: BUCKET,\n            Key: fileKey,\n            Body: file.buffer,\n            ACL: \"public-read\",\n        };\n        // documentJpg.docs\n        await s3.putObject(uploadParams).promise();\n        fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    }\n    let data = await trainingModel_1.default.findOne(filter);\n    if (!data) {\n        data = await trainingModel_1.default.create(filter);\n    }\n    const obj = {\n        resourceName: fileName,\n        resourceUrl: fileUrl,\n    };\n    data.trainingMaterial.push(obj);\n    await data.save();\n    res.status(200).json({\n        success: true,\n        message: \"training data added successfully.\",\n        data: data,\n    });\n});\nexports.getTrainingData = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { Id } = req.params;\n    if (Id) {\n        const trainingData = await trainingModel_1.default.findById(Id);\n        resp.status(200).json({\n            success: true,\n            message: \"Training  data successfully.\",\n            trainingData,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Training not found.\",\n        });\n    }\n});\nexports.deleteTrainingData = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const { Id } = req.params;\n    if (Id) {\n        const trainingData = await trainingModel_1.default.findByIdAndDelete(Id);\n        resp.status(200).json({\n            success: true,\n            message: \"Training  data successfully.\",\n            trainingData,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Training not found.\",\n        });\n    }\n});\n// get training material\nexports.getTraining = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin || req.employee) {\n        const { groupName, jobProfileName } = req.query;\n        const filter = {};\n        if (groupName) {\n            // find group id from group model\n            const group = await groupModel_1.default.findOne({\n                groupName: groupName,\n            });\n            filter.groupId = group?._id;\n        }\n        if (jobProfileName) {\n            // find allJobProfiles from jobProfile model\n            const jobProfile = await jobProfileModel_1.default.findOne({\n                jobProfileName: jobProfileName,\n            });\n            filter.jobProfileId = jobProfile?._id;\n        }\n        if (req.employee) {\n            const trainingData = await trainingModel_1.default.findOne({ jobProfileId: req.employee._id });\n            resp.status(200).json({\n                success: true,\n                message: \"Training  data successfully.\",\n                trainingData: trainingData,\n            });\n        }\n        else {\n            const trainingData = await trainingModel_1.default.find(filter);\n            resp.status(200).json({\n                success: true,\n                message: \"Training  data successfully.\",\n                trainingData: trainingData,\n            });\n        }\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/trainingController.ts?");

/***/ }),

/***/ "./src/controllers/employee/v2attendanceController.ts":
/*!************************************************************!*\
  !*** ./src/controllers/employee/v2attendanceController.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateAttendanceDetails = exports.updatePunchOut = exports.getPunchRecordsNumber = exports.shopOverView = exports.departmentOverView = exports.groupOverView = exports.addAttendanceWithEmployeeIdV2 = exports.pendingUnderMe = exports.shopFilter = exports.deletePunchs = exports.updatePunchs = exports.addPunchs = exports.getMyApprovedAttendance = exports.getEmployeeByQRCode = exports.getGroupPunchRecords = exports.employeeStaffAttendance = exports.getPunchRecords = exports.myAttendance = exports.singleEmployeeAttendance = exports.absentAndPresentEmployee = exports.attendanceApproveImage = exports.updateAttendance = exports.addAttendanceWithEmployeeId = void 0;\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst errorHandler_1 = __importDefault(__webpack_require__(/*! ../../middleware/errorHandler */ \"./src/middleware/errorHandler.ts\"));\nconst dateTimeConverter_1 = __webpack_require__(/*! ../../middleware/dateTimeConverter */ \"./src/middleware/dateTimeConverter.ts\");\nconst v2attendanceModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/v2attendanceModel */ \"./src/database/models/v2attendanceModel.ts\"));\nconst QRCode = __importStar(__webpack_require__(/*! qrcode */ \"qrcode\"));\n// image\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst path_2 = __webpack_require__(/*! path */ \"path\");\nconst department_1 = __importDefault(__webpack_require__(/*! ../../database/models/department */ \"./src/database/models/department.ts\"));\nconst groupModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/groupModel */ \"./src/database/models/groupModel.ts\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst shopModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopModel */ \"./src/database/models/shopModel.ts\"));\nconst shopLogModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/shopLogModel */ \"./src/database/models/shopLogModel.ts\"));\nconst productionSlipController_1 = __webpack_require__(/*! ../bomControllers/productionSlipController */ \"./src/controllers/bomControllers/productionSlipController.ts\");\nconst adminModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/adminModel */ \"./src/database/models/adminModel.ts\"));\n(0, dotenv_1.config)({ path: path_1.default.join(__dirname, \"../../../\", \"public/.env\") });\naws_sdk_1.default.config.update({\n    secretAccessKey: process.env.ACCESS_SECRET,\n    accessKeyId: process.env.ACCESS_KEY,\n    region: process.env.REGION,\n});\nconst BUCKET = process.env.BUCKET;\nif (!BUCKET) {\n    console.error(\"No bucket specified in the environment configuration.\");\n    process.exit(1);\n}\nconst s3 = new aws_sdk_1.default.S3();\nexports.addAttendanceWithEmployeeId = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById(req.employee.jobProfileId);\n    }\n    let lastPunchOut;\n    let lastPunchIn;\n    const { id } = req.body;\n    let date = new Date();\n    let nextDay;\n    date = new Date(date);\n    date.setHours(0, 0, 0, 0);\n    date.setHours(date.getHours() - 11.5);\n    // date.setHours(date.getHours() - 6);\n    nextDay = new Date(date);\n    nextDay.setDate(nextDay.getDate() + 3);\n    nextDay.setHours(0, 0, 0, 0);\n    nextDay.setHours(nextDay.getHours() - 11.5);\n    // nextDay.setHours(nextDay.getHours() - 6);\n    date = (0, dateTimeConverter_1.getIndianTime)(date);\n    nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n    let message = ``;\n    if (req.admin ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee = await employeeModel_1.default.findOne({ _id: id })\n            .populate(\"jobProfileId\")\n            .populate(\"groupId\")\n            .exec();\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        let currentDate = new Date();\n        currentDate = (0, dateTimeConverter_1.getIndianTime)(currentDate);\n        let attendanceRecord = await v2attendanceModel_1.default.findOne({\n            employeeId: employee?._id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n        });\n        if (!attendanceRecord) {\n            attendanceRecord = new v2attendanceModel_1.default({\n                employeeId: employee?._id,\n                date: currentDate,\n                punches: [\n                    {\n                        employeeId: employee?._id,\n                        punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                        punchInBy: req.employee?._id || req.admin?._id,\n                    },\n                ],\n                isPresent: true,\n            });\n            message = `Attendance punch In successfully.`;\n        }\n        else {\n            let attDate = new Date(attendanceRecord.date);\n            // condition added for night shift\n            if (currentDate.getDate() !== attDate.getDate() &&\n                currentDate.getHours() > 18) {\n                attendanceRecord = new v2attendanceModel_1.default({\n                    employeeId: employee?._id,\n                    date: currentDate,\n                    punches: [\n                        {\n                            employeeId: employee?._id,\n                            punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                            punchInBy: req.employee?._id || req.admin?._id,\n                            status: \"pending\",\n                        },\n                    ],\n                    isPresent: true,\n                });\n                message = `Attendance punch In successfully.`;\n                return resp.status(200).json({\n                    success: true,\n                    message,\n                    attendance: attendanceRecord,\n                    employee,\n                });\n            }\n            const todayAttendance = attendanceRecord.punches;\n            if (!todayAttendance) {\n                attendanceRecord.punches.push({\n                    punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                    punchInBy: req.employee?._id || req.admin?._id,\n                });\n                message = `Attendance punch In successfully.`;\n            }\n            else {\n                const lastPunch = todayAttendance[todayAttendance.length - 1];\n                if (lastPunch && lastPunch.punchOut) {\n                    const newPunch = {\n                        employeeId: employee?._id,\n                        punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                        punchInBy: req.employee?._id || req.admin?._id,\n                    };\n                    attendanceRecord.punches.push(newPunch);\n                    message = `Attendance punch In successfully.1`;\n                }\n                else {\n                    const FirstPunchIn = new Date(attendanceRecord.punches[0].punchIn);\n                    FirstPunchIn.setHours(FirstPunchIn.getHours() - 330 * 60 * 1000);\n                    const lastPunchout = new Date();\n                    const data = await (0, productionSlipController_1.getProductivityPerEmployee)(employee._id, FirstPunchIn, lastPunchout);\n                    console.log(\"data for productionSlip\", data);\n                    if (data) {\n                        attendanceRecord.productiveHours = data.productiveHours;\n                        attendanceRecord.productionSlipNumbers =\n                            data.productionSlipNumbers;\n                    }\n                    lastPunch.punchOut = (0, dateTimeConverter_1.getIndianTime)(new Date());\n                    lastPunch.punchOutBy = req.employee?._id || req.admin?._id;\n                    message = `Attendance punch Out successfully.`;\n                }\n            }\n        }\n        await attendanceRecord.save();\n        resp.status(200).json({\n            success: true,\n            message,\n            attendance: attendanceRecord,\n            // employee,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security or admin or hr.\",\n        });\n    }\n});\nexports.updateAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let employee = null;\n        let approverId;\n        let shopOfLoggedIn = null;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id)\n                .populate(\"jobProfileId\")\n                .exec();\n            const loggedInJobProfile = employee?.jobProfileId;\n            if (loggedInJobProfile.isSupervisor) {\n                approverId = employee?._id;\n                shopOfLoggedIn = await shopModel_1.default.findOne({\n                    \"jobProfile.jobProfileId\": loggedInJobProfile._id,\n                });\n                if (!shopOfLoggedIn) {\n                    resp.status(404).json({\n                        success: false,\n                        message: \"LoggedIn user is not in  any shop\",\n                    });\n                }\n            }\n            else if (loggedInJobProfile.isSupervisor == false) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"you are not supervisor\",\n                });\n            }\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Employee not found\",\n                });\n            }\n        }\n        else {\n            approverId = req.admin?._id;\n        }\n        let { employeeId, status, punchInTime, date, shift } = req.body;\n        let nextDay;\n        if (date) {\n            date = new Date(date);\n            date.setHours(0, 0, 0, 0);\n            date.setHours(date.getHours() - (6 + 5.5));\n            nextDay = new Date(date);\n            nextDay.setDate(nextDay.getDate() + 3);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setHours(nextDay.getHours() - (6 + 5.5));\n            date = (0, dateTimeConverter_1.getIndianTime)(date);\n            nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n        }\n        const employee1 = await employeeModel_1.default.findById(employeeId);\n        if (!employee1) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        const punchIn = new Date(punchInTime);\n        const atten = await v2attendanceModel_1.default.find({\n            employeeId,\n            date: { $gte: date, $lt: nextDay },\n            shift,\n        });\n        const attendanceId = atten[atten.length - 1]?._id;\n        let attendanceRecord = await v2attendanceModel_1.default.findById(attendanceId);\n        if (!attendanceRecord) {\n            return next(new errorHandler_1.default(\"Attendance record not found.\", 404));\n        }\n        let previousArray = false;\n        const approvedImage = attendanceRecord.approvedImage;\n        if (attendanceRecord.status == \"approved\") {\n            return resp.status(400).json({\n                success: false,\n                message: \"Attendance already approved\",\n            });\n        }\n        if (status == \"approved\" ||\n            status == \"Approved\" ||\n            status == \"APPROVED\") {\n            if (approvedImage) {\n                attendanceRecord.approvedBy = approverId;\n                attendanceRecord.approvedTime = (0, dateTimeConverter_1.getIndianTime)(new Date());\n                attendanceRecord.status = status;\n                const obj = {\n                    employeeId: employeeId,\n                    employeeName: employee1.name,\n                };\n                const shopLogData = await shopLogModel_1.default.findOne({\n                    date: { $gte: date, $lt: nextDay },\n                    shopId: shopOfLoggedIn._id,\n                });\n                if (!shopLogData) {\n                    const Arr = [];\n                    Arr.push(obj);\n                    await shopLogModel_1.default.create({\n                        shopId: shopOfLoggedIn._id,\n                        date: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                        employees: Arr,\n                    });\n                }\n                else {\n                    shopLogData.employees.push(obj);\n                    await shopLogData.save();\n                }\n            }\n            else {\n                resp.status(400).json({\n                    success: false,\n                    message: \"Image should be uploaded.\",\n                });\n            }\n        }\n        if (status == \"rejected\" ||\n            status == \"Rejected\" ||\n            status == \"REJECTED\") {\n            attendanceRecord.approvedBy = approverId;\n            attendanceRecord.status = status;\n        }\n        await attendanceRecord.save();\n        resp.status(200).json({\n            success: true,\n            message: \"Attendance approved successfully.\",\n            attendance: attendanceRecord,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\nexports.attendanceApproveImage = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const file = req.file;\n    // finding employee by group\n    const allowedExtensions = [\".jpg\", \".jpeg\", \".png\"];\n    let { employeeId, date } = req.body;\n    const employee1 = await employeeModel_1.default.findById(employeeId);\n    if (!employee1) {\n        return next(new errorHandler_1.default(\"Employee not found.\", 404));\n    }\n    let nextDay;\n    if (date) {\n        date = new Date(date);\n        date.setHours(0, 0, 0, 0);\n        date.setHours(date.getHours() - (6 + 5));\n        // date.setHours(date.getHours() - 6);\n        nextDay = new Date(date);\n        nextDay.setDate(nextDay.getDate() + 3);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() - (6 + 5));\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    date = (0, dateTimeConverter_1.getIndianTime)(date);\n    nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n    const atten = await v2attendanceModel_1.default.find({\n        employeeId,\n        date: {\n            $gte: date,\n            $lt: nextDay,\n        },\n    });\n    const id = atten[atten.length - 1]._id;\n    const attendanceRecord = await v2attendanceModel_1.default.findById(id);\n    if (!attendanceRecord) {\n        return next(new errorHandler_1.default(\"Attendance record not found.\", 404));\n    }\n    let fileUrl;\n    if (!file) {\n        return res.status(400).json({\n            success: false,\n            message: \"No file uploaded.\",\n        });\n    }\n    const fileExt = (0, path_2.extname)(file.originalname).toLowerCase();\n    if (!allowedExtensions.includes(fileExt)) {\n        return res.status(400).json({\n            success: false,\n            message: \"Invalid file type. Only JPG, JPEG, PNG images are allowed.\",\n        });\n    }\n    const fileKey = `uploads/${(0, uuid_1.v4)()}-${file.originalname}`;\n    const uploadParams = {\n        Bucket: BUCKET,\n        Key: fileKey,\n        Body: file.buffer,\n        ACL: \"public-read\",\n    };\n    // documentJpg.docs\n    await s3.putObject(uploadParams).promise();\n    fileUrl = `https://${BUCKET}.s3.amazonaws.com/${fileKey}`;\n    attendanceRecord.approvedImage = fileUrl;\n    await attendanceRecord.save();\n    res.status(200).json({\n        success: true,\n        message: \"Approved image added successfully.\",\n        attendanceRecord,\n    });\n});\nexports.absentAndPresentEmployee = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let employee = null;\n    let jobProfile = null;\n    let { date, nextDate, groupName, departmentName, jobProfileName, name, limit = 20, page = 1, } = req.body;\n    limit = +limit;\n    page = +page;\n    const skip = (page - 1) * limit;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    // const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n    // const isAdmin = req.admin;\n    const filter = {};\n    const filter1 = {};\n    let jobProfileIds = [];\n    if (groupName &&\n        Array.isArray(groupName) &&\n        groupName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyGroupNames = groupName.filter((name) => name.trim() !== \"\");\n        const groups = await groupModel_1.default\n            .find({ groupName: { $in: nonEmptyGroupNames } })\n            .exec();\n        const groupIds = groups.map((group) => group._id);\n        filter.groupId = { $in: groupIds };\n    }\n    // Add departmentName filter if provided and non-empty\n    if (departmentName &&\n        Array.isArray(departmentName) &&\n        departmentName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyDepartmentNames = departmentName.filter((name) => name.trim() !== \"\");\n        const departments = await department_1.default\n            .find({ departmentName: { $in: nonEmptyDepartmentNames } })\n            .exec();\n        const departmentIds = departments.map((department) => department._id);\n        const jobProfiles = await jobProfileModel_1.default.find({\n            department: { $in: departmentIds },\n        }).exec();\n        const jobProfileIds = jobProfiles.map((jobProfile) => jobProfile._id);\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    // Add jobProfileName filter if provided and non-empty\n    if (jobProfileName &&\n        Array.isArray(jobProfileName) &&\n        jobProfileName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyJobProfileNames = jobProfileName.filter((name) => name.trim() !== \"\");\n        const jobProfiles = await jobProfileModel_1.default.find({\n            jobProfileName: { $in: nonEmptyJobProfileNames },\n        }).exec();\n        const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n        jobProfileIds = [...jobProfileIds, ...ids];\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    if (name) {\n        filter.$or = [{ name: name }, { employeeCode: name }];\n        filter1.$or = [{ name: name }, { employeeCode: name }];\n    }\n    const employeeDocsStore = {};\n    const employeeDocs = await employeeDocsModel_1.default.find({}).lean();\n    employeeDocs.forEach((e) => {\n        const id = e.employeeId + \"\";\n        employeeDocsStore[id] = {\n            profilePicture: e.profilePicture,\n        };\n    });\n    const allShops = await shopModel_1.default.find({}).lean();\n    const shopStore = {};\n    allShops.forEach((a) => {\n        const id = a.jobProfile.jobProfileId + \"\";\n        shopStore[id] = {\n            shopId: a._id,\n            shop: a.shopName,\n            shopCode: a.shopCode,\n        };\n    });\n    const allAdmin = await adminModel_1.default.find({}).lean();\n    const adminStore = {};\n    allAdmin.forEach((a) => {\n        const id = a._id + \"\";\n        adminStore[id] = {\n            id: a._id,\n            name: a.name,\n        };\n    });\n    const allEmp = await employeeModel_1.default.find({}).lean();\n    const empStore = {};\n    allEmp.forEach((a) => {\n        const id = a._id + \"\";\n        empStore[id] = {\n            id: a._id,\n            name: a.name,\n        };\n    });\n    // admin condition\n    const employeeIds = await employeeModel_1.default.find(filter)\n        .skip(skip)\n        .limit(limit)\n        .exec();\n    const employeeid = await employeeModel_1.default.find(filter).exec();\n    const empids = employeeid.map((employee) => employee._id);\n    const ids = employeeIds.map((employee) => employee._id);\n    const documnetLength = await v2attendanceModel_1.default.countDocuments({\n        employeeId: { $in: empids },\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    });\n    const attendanceRecords = await v2attendanceModel_1.default\n        .find({\n        employeeId: { $in: ids },\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    })\n        .populate({\n        path: \"approvedBy\",\n        select: \"name\",\n        populate: {\n            path: \"jobProfileId\",\n            select: \"jobProfileName\",\n        },\n    })\n        .populate({\n        path: \"employeeId\",\n        select: { name: 1, employeeCode: 1, jobProfileId: 1, groupId: 1 },\n        populate: {\n            path: \"jobProfileId\",\n            select: {\n                jobProfileName: 1,\n                jobDescription: 1,\n                isSupervisor: 1,\n            },\n        },\n    })\n        .populate({\n        path: \"employeeId\",\n        select: { name: 1, employeeCode: 1, jobProfileId: 1, groupId: 1 },\n        populate: {\n            path: \"groupId\",\n            select: { groupName: 1 },\n        },\n    })\n        .select(\"-createdAt -updatedAt\")\n        .exec();\n    attendanceRecords.sort((a, b) => a.employeeId.name.localeCompare(b.employeeId.name));\n    let newRecords = [];\n    for (let rec of attendanceRecords) {\n        const id = rec.employeeId._id + \"\";\n        const docs = employeeDocsStore[id];\n        if (docs) {\n            const doc = {\n                ...rec.toObject(),\n                profilePicture: docs.profilePicture,\n            };\n            if (rec.approvedBy) {\n                const id = rec.approvedBy.jobProfileId?._id + \"\";\n                const shop = shopStore[id];\n                if (shop) {\n                    doc.shopName = shop.shop;\n                    doc.shopCode = shop.shopCode;\n                }\n            }\n            if (rec.remarks) {\n                const by = rec.remarks[rec.remarks.length - 1]?.by;\n                //console.log(by);\n                const admin = adminStore[by];\n                const emp = empStore[by];\n                if (emp) {\n                    doc.remarksBy = emp.name;\n                }\n                if (admin) {\n                    doc.remarksBy = admin.name;\n                }\n            }\n            newRecords.push(doc);\n        }\n        else if (docs === undefined) {\n            if (rec.approvedBy) {\n                const doc = {\n                    ...rec.toObject(),\n                };\n                const id = rec.approvedBy.jobProfileId?._id + \"\";\n                const shop = shopStore[id];\n                if (shop) {\n                    doc.shopName = shop.shop;\n                    doc.shopCode = shop.shopCode;\n                }\n                newRecords.push(doc);\n            }\n            else {\n                newRecords.push(rec);\n            }\n        }\n        else {\n            newRecords.push(rec);\n        }\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"Employee punches fetched successfully.\",\n        attendanceRecords: newRecords,\n        documnetLength: documnetLength,\n    });\n}\n// }\n);\nexports.singleEmployeeAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { date, nextDate } = req.query;\n    let { employeeId } = req.params;\n    let employee = await employeeModel_1.default.findOne({ _id: employeeId });\n    if (!employee) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Employee not found .\",\n        });\n    }\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        filterDate.setHours(filterDate.getHours() - 6);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 2);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 2);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    filterDate = (0, dateTimeConverter_1.getIndianTime)(filterDate);\n    nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n    const data = await v2attendanceModel_1.default\n        .find({\n        employeeId: employee._id,\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    })\n        .sort({ date: -1 })\n        .exec();\n    resp.status(200).json({\n        success: true,\n        message: \"Getting all attendance successfully.\",\n        data,\n    });\n});\nexports.myAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee) {\n        let { date, nextDate } = req.query;\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        filterDate = (0, dateTimeConverter_1.getIndianTime)(filterDate);\n        nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n        const data = await v2attendanceModel_1.default\n            .find({\n            employeeId: req.employee._id,\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        })\n            .sort({ date: -1 })\n            .populate(\"approvedBy\")\n            .exec();\n        resp.status(200).json({\n            success: true,\n            message: \"Getting all attendance successfully.\",\n            data,\n        });\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login as employee\", 404));\n    }\n});\nexports.getPunchRecords = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin || req.employee) {\n        const { date, nextDate } = req.query;\n        let nextDay;\n        let filterDate;\n        let date1;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            // filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            // filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 1);\n            // nextDay.setHours(nextDay.getHours() - 6);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 1);\n            nextDay.setHours(0, 0, 0, 0);\n            // nextDay.setHours(nextDay.getHours() - 6);\n        }\n        date1 = (0, dateTimeConverter_1.getIndianTime)(filterDate);\n        nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n        const punchIn = [];\n        const punchOut = [];\n        let countIn = 0;\n        let countOut = 0;\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            _id: req.employee?.jobProfileId,\n        });\n        if (jobProfile?.jobProfileName.toLowerCase() === \"security\" ||\n            jobProfile?.jobProfileName.toLowerCase() === \"security head\") {\n            const allData = await v2attendanceModel_1.default\n                .find({\n                date: {\n                    $gte: date1,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .populate(\"approvedBy\")\n                .exec();\n            for (let data of allData) {\n                for (let punch of data.punches) {\n                    if (punch.punchInBy?.toString() ===\n                        (req.employee?._id?.toString() || req.admin?._id?.toString())) {\n                        const emp = { employee: data.employeeId, punchIn: punch.punchIn };\n                        punchIn.push(emp);\n                        countIn++;\n                    }\n                    if (punch.punchOutBy?.toString() ===\n                        (req.employee?._id?.toString() || req.admin?._id?.toString())) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchOut: punch.punchOut,\n                        };\n                        punchOut.push(emp);\n                        countOut++;\n                    }\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully security.\",\n                punchIn,\n                punchOut,\n                countIn,\n                countOut,\n            });\n        }\n        else if (jobProfile?.jobProfileName === \"hr\" || req.admin) {\n            let totalPresent = 0;\n            const totalEmployees = await employeeModel_1.default.countDocuments();\n            const allData = await v2attendanceModel_1.default\n                .find({\n                date: {\n                    $gte: date1,\n                    $lt: nextDay,\n                },\n            })\n                .populate(\"employeeId\")\n                .populate(\"punches.punchInBy\")\n                .populate(\"punches.punchOutBy\")\n                .populate(\"approvedBy\")\n                .exec();\n            totalPresent = allData.length;\n            for (let data of allData) {\n                for (let punch of data.punches) {\n                    if (punch.punchIn) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchIn: punch.punchIn,\n                            punchInBy: punch.punchInBy,\n                        };\n                        punchIn.push(emp);\n                    }\n                    if (punch.punchOut) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchOut: punch.punchOut,\n                            punchOutBy: punch.punchOutBy,\n                        };\n                        punchOut.push(emp);\n                    }\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully.\",\n                punchIn,\n                punchOut,\n                countIn: punchIn.length,\n                countOut: punchOut.length,\n                totalEmployees,\n                totalPresent,\n            });\n        }\n        else {\n            let totalEmployees = 0;\n            let totalPresent = 0;\n            const employeeIds = await employeeModel_1.default.aggregate([\n                {\n                    $lookup: {\n                        from: \"jobprofiles\",\n                        localField: \"jobProfileId\",\n                        foreignField: \"_id\",\n                        as: \"jobProfile\",\n                    },\n                },\n                {\n                    $unwind: \"$jobProfile\",\n                },\n                {\n                    $match: {\n                        \"jobProfile.parentJobProfileId\": jobProfile?._id,\n                    },\n                },\n            ]).exec();\n            const ids = employeeIds.map((employee) => employee._id);\n            totalEmployees = ids.length;\n            const allData = await v2attendanceModel_1.default\n                .find({\n                date: {\n                    $gte: date1,\n                    $lt: nextDay,\n                },\n                employeeId: { $in: ids },\n            })\n                .populate(\"employeeId\")\n                .populate(\"approvedBy\")\n                .populate(\"punches.punchInBy\")\n                .populate(\"punches.punchOutBy\")\n                .exec();\n            totalPresent = allData.length;\n            for (let data of allData) {\n                for (let punch of data.punches) {\n                    if (punch.punchIn) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchIn: punch.punchIn,\n                            punchInBy: punch.punchInBy,\n                        };\n                        punchIn.push(emp);\n                    }\n                    if (punch.punchOut) {\n                        const emp = {\n                            employee: data.employeeId,\n                            punchOut: punch.punchOut,\n                            punchOutBy: punch.punchOutBy,\n                        };\n                        punchOut.push(emp);\n                    }\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully.\",\n                punchIn,\n                punchOut,\n                countIn: punchIn.length,\n                countOut: punchOut.length,\n                totalEmployees,\n                totalPresent,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 403));\n    }\n});\nexports.employeeStaffAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        let employee = null;\n        let jobProfile = null;\n        let { date, nextDate } = req.query;\n        if (req.employee) {\n            employee = await employeeModel_1.default.findById(req.employee._id).exec();\n            if (!employee) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Employee not found\",\n                });\n            }\n            jobProfile = await jobProfileModel_1.default.findById(employee?.jobProfileId);\n            if (!jobProfile) {\n                resp.status(404).json({\n                    success: false,\n                    message: \"Job profile not found\",\n                });\n            }\n        }\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n        }\n        const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n        const isAdmin = req.admin;\n        if (!isHR && !isAdmin) {\n            const myJobProfile = await jobProfileModel_1.default.findOne({\n                _id: jobProfile?._id,\n            });\n            const childJobProfile = myJobProfile?.childProfileId;\n            const data = [];\n            if (childJobProfile) {\n                for (let jobProfile of childJobProfile) {\n                    const thisJobProfile = await jobProfileModel_1.default.findOne({\n                        _id: jobProfile,\n                    });\n                    const employees = await employeeModel_1.default.find({\n                        jobProfileId: jobProfile,\n                    });\n                    const totalEmployees = employees.length;\n                    const ids = employees.map((employee) => employee._id);\n                    const attendanceRecords = await v2attendanceModel_1.default\n                        .find({\n                        employeeId: { $in: ids },\n                        date: {\n                            $gte: filterDate,\n                            $lt: nextDay,\n                        },\n                    })\n                        .sort({ date: -1 })\n                        .populate(\"employeeId\")\n                        .populate(\"approvedBy\")\n                        .populate({\n                        path: \"employeeId\",\n                        populate: {\n                            path: \"jobProfileId\",\n                        },\n                    })\n                        .exec();\n                    const todayPresent = attendanceRecords.length;\n                    const dataa = {\n                        todayPresent,\n                        totalEmployees,\n                        thisJobProfile,\n                    };\n                    data.push(dataa);\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"Employee punches fetched successfully.\",\n                data,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 404));\n    }\n});\nexports.getGroupPunchRecords = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin || req.employee) {\n        const { date, nextDate } = req.query;\n        const employeeStore = {};\n        const attendanceStore = {};\n        let filterDate;\n        let nextDay;\n        if (typeof date === \"string\") {\n            filterDate = new Date(date);\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        else {\n            filterDate = new Date();\n            filterDate.setHours(0, 0, 0, 0);\n            filterDate.setHours(filterDate.getHours() - 6);\n        }\n        if (typeof nextDate === \"string\") {\n            nextDay = new Date(nextDate);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setDate(nextDay.getDate() + 2);\n            nextDay.setHours(nextDay.getHours() - 11.5);\n        }\n        else {\n            nextDay = new Date(filterDate);\n            nextDay.setDate(filterDate.getDate() + 2);\n            nextDay.setHours(0, 0, 0, 0);\n            nextDay.setHours(nextDay.getHours() - 11.5);\n        }\n        const allEmployee = await employeeModel_1.default.find({});\n        const allAttendance = await v2attendanceModel_1.default\n            .find({\n            date: {\n                $gte: filterDate,\n                $lt: nextDay,\n            },\n        })\n            .populate(\"approvedBy\")\n            .exec();\n        allEmployee.forEach((e) => {\n            const id = e.groupId + \"\";\n            if (!employeeStore[id]) {\n                employeeStore[id] = {\n                    value: [],\n                };\n            }\n            employeeStore[id].value.push({\n                ...e.toObject(),\n            });\n        });\n        allAttendance.forEach((a) => {\n            const id = a.employeeId + \"\";\n            attendanceStore[id] = {\n                ...a.toObject(),\n            };\n        });\n        const jobProfile = await jobProfileModel_1.default.findOne({\n            _id: req.employee?.jobProfileId,\n        });\n        if (req.admin || jobProfile?.jobProfileName.toLowerCase() === \"hr\") {\n            const groups = await groupModel_1.default.find();\n            const groupPresent = [];\n            for (let group of groups) {\n                const punchIn = [];\n                const punchOut = [];\n                const groupId = group._id + \"\";\n                const employees = employeeStore[groupId];\n                if (employees) {\n                    let count = 0;\n                    const ids = employees.value.map((employee) => employee._id);\n                    ids.forEach((i) => {\n                        const id = i;\n                        const data = attendanceStore[id];\n                        if (data) {\n                            count++;\n                            for (let punch of data.punches) {\n                                if (punch.punchInBy) {\n                                    const emp = {\n                                        employee: data.employeeId,\n                                        punchIn: punch.punchIn,\n                                    };\n                                    punchIn.push(emp);\n                                }\n                                if (punch.punchOutBy) {\n                                    const emp = {\n                                        employee: data.employeeId,\n                                        punchOut: punch.punchOut,\n                                    };\n                                    punchOut.push(emp);\n                                }\n                            }\n                        }\n                    });\n                    const obj = {\n                        present: count,\n                        punchIn,\n                        punchOut,\n                        groupName: group.groupName,\n                        totalEmployeesInGroup: ids.length,\n                    };\n                    groupPresent.push(obj);\n                }\n            }\n            resp.status(200).json({\n                success: true,\n                message: \"All attendance successfully.\",\n                groupPresent,\n            });\n        }\n    }\n    else {\n        return next(new errorHandler_1.default(\"Login first\", 403));\n    }\n});\nexports.getEmployeeByQRCode = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById({\n            _id: req.employee.jobProfileId,\n        });\n    }\n    const { data, shift } = req.body;\n    // console.log(new Date() , new Date() +\"\");\n    let qrCode;\n    try {\n        qrCode = await QRCode.toDataURL(data); // Using email as an example\n    }\n    catch (err) {\n        return next(new errorHandler_1.default(\"QR Code generation failed.\", 500));\n    }\n    if (req.admin ||\n        jobProfile?.isSupervisor ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee = await employeeModel_1.default.findOne({ currentBarCode: qrCode })\n            .populate(\"jobProfileId\")\n            .populate(\"groupId\");\n        let employee1 = await employeeModel_1.default.findOne({ permanentBarCode: qrCode })\n            .populate(\"jobProfileId\")\n            .populate(\"groupId\");\n        if (!employee && !employee1) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        if (employee?.BarCodeStatus === false ||\n            employee1?.BarCodeStatus === false) {\n            return next(new errorHandler_1.default(\"Employee not active.\", 404));\n        }\n        if (employee1) {\n            employee = employee1;\n        }\n        if (!employee) {\n            return resp.status(404).json({\n                success: false,\n                message: \"Employee Not found.\",\n            });\n        }\n        const id = employee._id;\n        // console.log(employee?._id,employee1?._id)\n        let docs = await employeeDocsModel_1.default.findOne({ employeeId: id });\n        let nextDay;\n        let date = new Date();\n        date.setHours(0, 0, 0, 0);\n        // date.setHours(date.getHours() +5.5);\n        if (shift === \"night\") {\n            date.setHours(date.getHours() - 6);\n        }\n        nextDay = new Date(date);\n        nextDay.setDate(nextDay.getDate() + 3);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() - 11.5);\n        let atten = await v2attendanceModel_1.default\n            .find({\n            employeeId: id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n            shift,\n        })\n            .populate(\"approvedBy\")\n            .exec();\n        let attendanceId = atten[atten.length - 1]?._id;\n        let attendanceRecord = await v2attendanceModel_1.default.findById(attendanceId);\n        let message = \"\";\n        let lastMessage = \"\";\n        let length = attendanceRecord?.punches\n            ? attendanceRecord?.punches.length - 1\n            : 0;\n        if (attendanceRecord) {\n            let attendanceDate = new Date(attendanceRecord.date);\n            const time = new Date(attendanceDate).getUTCHours(); // 8   10      // 11  10\n            if (shift === \"night\") {\n                // for checking last recode in night\n                let atten = await v2attendanceModel_1.default.find({\n                    employeeId: id,\n                    date: {\n                        $gte: date,\n                        $lt: nextDay,\n                    },\n                    shift: \"day\",\n                });\n                let attendanceId = atten[atten.length - 1]?._id;\n                let dayRecords = await v2attendanceModel_1.default.findById(attendanceId);\n                let length = dayRecords?.punches ? dayRecords?.punches.length - 1 : 0;\n                const dayPunch = attendanceRecord?.punches[length];\n                const DayPunchOut = dayPunch.punchOut;\n                if (DayPunchOut === null) {\n                    lastMessage = \"punch out day record\";\n                    message = \"Punch In\";\n                }\n                //end\n                //true &&true  &&  true  || true &&\n                const lastPunchIn = attendanceRecord.punches[length];\n                const currentTime = (0, dateTimeConverter_1.getIndianTime)(new Date());\n                const lastPnch = lastPunchIn.punchIn;\n                // checking for punch out if punch in before 1 min\n                const diff = currentTime - lastPnch;\n                const timed = diff / (1000 * 60);\n                let min = timed;\n                if ((time > 18 &&\n                    new Date().getDate() !== attendanceDate.getUTCDate() &&\n                    new Date().getHours() > 18) ||\n                    (attendanceDate.getUTCDate() === new Date().getDate() &&\n                        attendanceDate.getUTCHours() < 18 &&\n                        new Date().getHours() > 18)) {\n                    message = \"Punch In\";\n                }\n                else if (attendanceRecord.punches[length].punchOut) {\n                    message = \"Punch In\";\n                }\n                else {\n                    if (min < 1) {\n                        message = \"Punch Out after 1 min\";\n                    }\n                    else {\n                        message = \"Punch Out\";\n                    }\n                }\n            }\n            else {\n                // for checking last recode in night\n                let atten = await v2attendanceModel_1.default.find({\n                    employeeId: id,\n                    date: {\n                        $gte: date,\n                        $lt: nextDay,\n                    },\n                    shift: \"night\",\n                });\n                let attendanceId = atten[atten.length - 1]?._id;\n                let nightRecords = await v2attendanceModel_1.default.findById(attendanceId);\n                let length = nightRecords?.punches\n                    ? nightRecords?.punches.length - 1\n                    : 0;\n                const nightPunch = attendanceRecord?.punches[length];\n                const NightPunchOut = nightPunch.punchOut;\n                //end\n                const lastPunchIn = attendanceRecord.punches[length];\n                const currentTime = (0, dateTimeConverter_1.getIndianTime)(new Date());\n                const lastPnch = lastPunchIn.punchIn;\n                // checking for punch out if punch in before 1 min\n                const diff = currentTime - lastPnch;\n                const timed = diff / (1000 * 60);\n                let min = timed;\n                if (attendanceRecord.punches[length].punchOut) {\n                    if (NightPunchOut === null) {\n                        lastMessage = \"night punch out is pending\";\n                        message = \"Punch In\";\n                    }\n                    else {\n                        message = \"Punch In\";\n                    }\n                }\n                else {\n                    if (min < 1) {\n                        message = \"Punch Out after 1 min\";\n                    }\n                    else {\n                        message = \"Punch Out\";\n                    }\n                }\n            }\n        }\n        else {\n            // for check night recode\n            let oldShift = null;\n            if (shift === \"day\") {\n                oldShift = \"night\";\n            }\n            else if (shift === \"night\") {\n                oldShift = \"day\";\n            }\n            let atten = await v2attendanceModel_1.default.find({\n                employeeId: id,\n                date: { $gte: date, $lt: nextDay },\n                shift: oldShift,\n            });\n            let attendanceId = atten[atten.length - 1]?._id;\n            let attendanceRecords = await v2attendanceModel_1.default.findById(attendanceId);\n            if (attendanceRecords) {\n                let length = attendanceRecords?.punches\n                    ? attendanceRecords?.punches.length - 1\n                    : 0;\n                const nightPunch = attendanceRecords.punches[length];\n                const NightPunchOut = nightPunch.punchOut;\n                if (NightPunchOut === null) {\n                    lastMessage = `punch out ${oldShift} record`;\n                    message = `punch in`;\n                }\n                else {\n                    message = `punch in`;\n                }\n            }\n            else {\n                message = `punch in`;\n            }\n        }\n        let profilePicture;\n        if (docs) {\n            profilePicture = docs.profilePicture;\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"getting employee data successfully.\",\n            employee,\n            profilePicture: profilePicture,\n            docs: docs,\n            punch: message,\n            lastMessage: lastMessage,\n            attendanceRecord,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security .\",\n        });\n    }\n});\nexports.getMyApprovedAttendance = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let emp;\n    let { date, nextDate, groupName, shift } = req.query;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        filterDate.setHours(filterDate.getHours() - 6);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        // nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(nextDay.getHours() + 6);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n        // nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() + 6);\n    }\n    let data;\n    if (req.employee) {\n        emp = await employeeModel_1.default.findById(req.employee._id);\n        let filter = {};\n        if (groupName) {\n            const groups = await groupModel_1.default.find({ groupName: { $in: groupName } });\n            const groupIds = groups.map((e) => e._id);\n            const empGroup = await employeeModel_1.default.find({\n                groupId: { $in: groupIds },\n            });\n            const empgroupIds = empGroup.map((a) => a._id);\n            filter.employeeId = { $in: empgroupIds };\n        }\n        if (shift) {\n            filter.shift = shift;\n        }\n        filter.approvedBy = emp?._id;\n        data = await v2attendanceModel_1.default\n            .find({ ...filter, date: { $gte: date, $lt: nextDay } })\n            .populate({\n            path: \"approvedBy\",\n            select: { name: 1 },\n        })\n            .populate({\n            path: \"employeeId\",\n            select: { name: 1, employeeCode: 1, groupId: 1 },\n            populate: [\n                {\n                    path: \"jobProfileId\",\n                    select: \"jobProfileName\",\n                },\n                {\n                    path: \"groupId\",\n                    select: \"groupName\",\n                },\n            ],\n        })\n            .exec();\n    }\n    data.sort((a, b) => a.employeeId.name.localeCompare(b.employeeId.name));\n    resp.status(200).json({\n        success: true,\n        message: \"attendance successfully.\",\n        total: data.length,\n        data: data,\n    });\n});\nexports.addPunchs = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin) {\n        let { id } = req.params;\n        let { punchIn, punchOut, date, remarks, shift } = req.body;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: \"Employee not found.\",\n            });\n        }\n        let nextDay;\n        date = new Date(date);\n        date.setHours(0, 0, 0, 0);\n        date.setHours(date.getHours() - 11.5);\n        // date.setHours(date.getHours() - 6);\n        nextDay = new Date(date);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() - 11.5);\n        // nextDay.setHours(nextDay.getHours() - 6);\n        date = (0, dateTimeConverter_1.getIndianTime)(date);\n        nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n        const attendanceRecord = await v2attendanceModel_1.default.find({\n            employeeId: employee?._id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n        });\n        if (attendanceRecord.length === 0) {\n            let obj;\n            const remark = [\n                {\n                    remark: remarks,\n                    createdAt: Date.now(),\n                    by: req.admin._id,\n                },\n            ];\n            if (punchOut && punchIn) {\n                obj = [\n                    {\n                        punchIn: punchIn,\n                        punchOut: punchOut,\n                        employeeId: employee?._id,\n                        punchInBy: req.admin._id,\n                        punchOutBy: req.admin._id,\n                    },\n                ];\n            }\n            else if (punchIn && !punchOut) {\n                obj = [\n                    {\n                        punchIn: punchIn,\n                        punchOut: punchOut,\n                        employeeId: employee?._id,\n                        punchInBy: req.admin._id,\n                        punchOutBy: null,\n                    },\n                ];\n            }\n            else if (!punchIn && !punchOut) {\n                resp.status(400).json({\n                    success: false,\n                    message: \"add punches record failed\",\n                });\n            }\n            const createRecord = await v2attendanceModel_1.default.create({\n                employeeId: employee?._id,\n                date: punchIn,\n                remarks: remark,\n                shift: shift,\n                status: \"added Manually by administrator\",\n                punches: obj,\n            });\n            resp.status(200).json({\n                success: true,\n                createRecord,\n                message: \"record created successfully\",\n            });\n        }\n        else {\n            resp.status(400).json({\n                success: false,\n                message: \"Record found successfully.\",\n            });\n        }\n    }\n    else if (req.attendanceManager) {\n        let { id } = req.params;\n        let { punchIn, punchOut, date, remarks, shift } = req.body;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: \"Employee not found.\",\n            });\n        }\n        let nextDay;\n        date = new Date(date);\n        date.setHours(0, 0, 0, 0);\n        date.setHours(date.getHours() - 11.5);\n        // date.setHours(date.getHours() - 6);\n        nextDay = new Date(date);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setHours(nextDay.getHours() - 11.5);\n        // nextDay.setHours(nextDay.getHours() - 6);\n        date = (0, dateTimeConverter_1.getIndianTime)(date);\n        nextDay = (0, dateTimeConverter_1.getIndianTime)(nextDay);\n        const attendanceRecord = await v2attendanceModel_1.default.find({\n            employeeId: employee?._id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n        });\n        if (attendanceRecord.length === 0) {\n            let obj;\n            const remark = [\n                {\n                    remark: remarks,\n                    createdAt: Date.now(),\n                    by: req.attendanceManager._id,\n                },\n            ];\n            if (punchOut && punchIn) {\n                obj = [\n                    {\n                        punchIn: punchIn,\n                        punchOut: punchOut,\n                        employeeId: employee?._id,\n                        punchInBy: req.attendanceManager._id,\n                        punchOutBy: req.attendanceManager._id,\n                    },\n                ];\n            }\n            else if (punchIn && !punchOut) {\n                obj = [\n                    {\n                        punchIn: punchIn,\n                        punchOut: punchOut,\n                        employeeId: employee?._id,\n                        punchInBy: req.attendanceManager._id,\n                        punchOutBy: null,\n                    },\n                ];\n            }\n            else if (!punchIn && !punchOut) {\n                resp.status(400).json({\n                    success: false,\n                    message: \"add punches record failed\",\n                });\n            }\n            const createRecord = await v2attendanceModel_1.default.create({\n                employeeId: employee?._id,\n                date: punchIn,\n                remarks: remark,\n                shift: shift,\n                status: \"added Manually by administrator\",\n                punches: obj,\n            });\n            resp.status(200).json({\n                success: true,\n                createRecord,\n                message: \"record created successfully\",\n            });\n        }\n        else {\n            resp.status(400).json({\n                success: false,\n                message: \"Record found successfully.\",\n            });\n        }\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Login first as admin or attendance manager \",\n        });\n    }\n});\nexports.updatePunchs = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin) {\n        let { id } = req.params;\n        let { punchIn, punchOut, date, remarks, shift } = req.body;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: req.admin._id,\n            });\n        }\n        const attendanceRecord = await v2attendanceModel_1.default.findOne({\n            employeeId: employee?._id,\n            date: date,\n        });\n        if (attendanceRecord) {\n            const obj = [\n                {\n                    punchIn: punchIn,\n                    punchOut: punchOut,\n                    employeeId: employee?._id,\n                    punchInBy: req.admin._id,\n                },\n            ];\n            const remark = [\n                {\n                    remark: remarks,\n                    createdAt: Date.now(),\n                    by: req.admin._id,\n                },\n            ];\n            const updateAttendance = await v2attendanceModel_1.default.findByIdAndUpdate(attendanceRecord._id, {\n                shift: shift,\n                $push: { remarks: remark },\n                punches: obj,\n                status: \"added Manually by administrator\",\n            }, { new: true });\n            resp.status(200).json({\n                success: true,\n                updateAttendance,\n                message: \"record updated successfully\",\n            });\n        }\n        else {\n            resp.status(400).json({\n                success: false,\n                message: \"Record not found create new.\",\n            });\n        }\n    }\n    else if (req.attendanceManager) {\n        let { id } = req.params;\n        let { punchIn, punchOut, date, remarks, shift } = req.body;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: req.attendanceManager._id,\n            });\n        }\n        const attendanceRecord = await v2attendanceModel_1.default.findOne({\n            employeeId: employee?._id,\n            date: date,\n        });\n        if (attendanceRecord) {\n            const obj = [\n                {\n                    punchIn: punchIn,\n                    punchOut: punchOut,\n                    employeeId: employee?._id,\n                    punchInBy: req.attendanceManager._id,\n                },\n            ];\n            const remark = [\n                {\n                    remark: remarks,\n                    createdAt: Date.now(),\n                    by: req.attendanceManager._id,\n                },\n            ];\n            const updateAttendance = await v2attendanceModel_1.default.findByIdAndUpdate(attendanceRecord._id, {\n                shift: shift,\n                $push: { remarks: remark },\n                punches: obj,\n                status: \"added Manually by administrator\",\n            }, { new: true });\n            resp.status(200).json({\n                success: true,\n                updateAttendance,\n                message: \"record updated successfully\",\n            });\n        }\n        else {\n            resp.status(400).json({\n                success: false,\n                message: \"Record not found create new.\",\n            });\n        }\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Login first as admin\",\n        });\n    }\n});\nexports.deletePunchs = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.admin) {\n        let { id } = req.params;\n        let { punchsId } = req.query;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: \"Employee not found.\",\n            });\n        }\n        const attendanceRecords = await v2attendanceModel_1.default.find({\n            employeeId: employee?._id,\n        });\n        if (attendanceRecords.length === 0) {\n            resp.status(400).json({\n                success: false,\n                message: \"Record not found create new.\",\n            });\n            return;\n        }\n        for (const record of attendanceRecords) {\n            record.punches = record.punches.filter((item) => {\n                return item._id.toString() !== punchsId;\n            });\n            if (record.punches.length === 0) {\n                await v2attendanceModel_1.default.findOneAndDelete({ _id: record._id });\n            }\n            else {\n                await record.save();\n            }\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"Record deleted successfully\",\n        });\n    }\n    else if (req.attendanceManager) {\n        let { id } = req.params;\n        let { punchsId } = req.query;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: \"Employee not found.\",\n            });\n        }\n        const attendanceRecords = await v2attendanceModel_1.default.find({\n            employeeId: employee?._id,\n        });\n        if (attendanceRecords.length === 0) {\n            resp.status(400).json({\n                success: false,\n                message: \"Record not found create new.\",\n            });\n            return;\n        }\n        for (const record of attendanceRecords) {\n            record.punches = record.punches.filter((item) => {\n                return item._id.toString() !== punchsId;\n            });\n            if (record.punches.length === 0) {\n                await v2attendanceModel_1.default.findOneAndDelete({ _id: record._id });\n            }\n            else {\n                await record.save();\n            }\n        }\n        resp.status(200).json({\n            success: true,\n            message: \"Record deleted successfully\",\n        });\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Login first as admin\",\n        });\n    }\n});\nexports.shopFilter = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { date, shopNames, groupNames, nextDate, limit = 20, page = 1, } = req.body;\n    limit = +limit;\n    page = +page;\n    const skip = (page - 1) * limit;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    let filter = {};\n    if (shopNames.length > 0) {\n        const shops = await shopModel_1.default.find({ shopName: { $in: shopNames } });\n        const jobProfileIdsUnderShop = shops.map((shop) => shop.jobProfile.jobProfileId);\n        const jobprofile = await jobProfileModel_1.default.find({\n            _id: { $in: jobProfileIdsUnderShop },\n        });\n        const jobprofileIds = jobprofile.map((job) => job._id);\n        const employee = await employeeModel_1.default.find({\n            jobProfileId: { $in: jobprofileIds },\n        });\n        const empIds = employee.map((e) => e._id);\n        filter.approvedBy = { $in: empIds };\n    }\n    if (groupNames.length > 0) {\n        const groups = await groupModel_1.default.find({ groupName: { $in: groupNames } });\n        const groupIds = groups.map((e) => e._id);\n        const empGroup = await employeeModel_1.default.find({ groupId: { $in: groupIds } });\n        const empgroupIds = empGroup.map((a) => a._id);\n        filter.employeeId = { $in: empgroupIds };\n    }\n    if (shopNames.length === 0 && groupNames.length === 0) {\n        filter.status = { $in: \"approved\" };\n    }\n    const attendance1 = await v2attendanceModel_1.default.find({\n        ...filter,\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    });\n    const attendance = await v2attendanceModel_1.default\n        .find({\n        ...filter,\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    })\n        .skip(skip)\n        .limit(limit)\n        .sort({ date: -1 })\n        .populate({\n        path: \"employeeId\",\n        select: { name: 1, employeeCode: 1, jobProfileId: 1, group: 1 },\n        populate: {\n            path: \"jobProfileId\",\n            select: \"jobProfileName\",\n        },\n    })\n        .populate({\n        path: \"employeeId\",\n        select: { name: 1, employeeCode: 1, jobProfileId: 1, group: 1 },\n        populate: {\n            path: \"groupId\",\n            select: \"groupName\",\n        },\n    })\n        .populate({\n        path: \"approvedBy\",\n        select: \"name\",\n        populate: {\n            path: \"jobProfileId\",\n            select: \"jobProfileName\",\n        },\n    });\n    const allShop = await shopModel_1.default.find();\n    let shopStore = {};\n    allShop.forEach((a) => {\n        const id = a.jobProfile.jobProfileId + \"\";\n        shopStore[id] = {\n            shopId: a._id,\n            shop: a.shopName,\n            shopCode: a.shopCode,\n        };\n    });\n    let newRecords = [];\n    for (let rec of attendance) {\n        if (rec.approvedBy) {\n            const doc = {\n                ...rec.toObject(),\n            };\n            const id = rec.approvedBy.jobProfileId?._id + \"\";\n            const shop = shopStore[id];\n            if (shop) {\n                doc.shopName = shop.shop;\n                doc.shopCode = shop.shopCode;\n            }\n            newRecords.push(doc);\n        }\n        else {\n            newRecords.push(rec);\n        }\n    }\n    resp.status(200).json({\n        success: 200,\n        message: \"Shop(s) found successfully\",\n        total: attendance1.length,\n        attendance: newRecords,\n    });\n});\nexports.pendingUnderMe = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { date, nextDate, page = 1, limit = 100, } = req.query;\n    limit = +limit;\n    page = +page;\n    const skip = (page - 1) * limit;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    if (req.employee) {\n        const employee = await employeeModel_1.default.findOne({ _id: req.employee._id });\n        if (employee) {\n            const jobProfileName = await jobProfileModel_1.default.findOne({\n                _id: employee.jobProfileId,\n            });\n            const childJobProfile = jobProfileName?.childProfileId;\n            // find employess of childJobProfile\n            const employeeProfile = await employeeModel_1.default.find({\n                jobProfileId: childJobProfile,\n            }).select({ name: 1, employeeCode: 1, jobProfileId: 1 });\n            const attendance = await v2attendanceModel_1.default\n                .find({\n                employeeId: {\n                    $in: employeeProfile.map((employee) => employee._id),\n                },\n                date: {\n                    $gte: filterDate,\n                    $lt: nextDay,\n                },\n            })\n                .skip(skip)\n                .limit(limit)\n                .sort({ date: -1 })\n                .populate({\n                path: \"employeeId\",\n                select: { name: 1, employeeCode: 1 },\n                populate: {\n                    path: \"jobProfileId\",\n                    select: \"jobProfileName\",\n                },\n            });\n            resp.status(200).json({\n                success: true,\n                total: attendance.length,\n                childJobProfile,\n                attendance,\n                message: \"Shop not found\",\n            });\n        }\n    }\n});\nexports.addAttendanceWithEmployeeIdV2 = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let jobProfile;\n    // checking the jobProfile Name\n    if (req.employee) {\n        jobProfile = await jobProfileModel_1.default.findById(req.employee.jobProfileId);\n    }\n    let lastPunchOut;\n    let lastPunchIn;\n    const { id, shift } = req.body;\n    let date = new Date();\n    let nextDay;\n    date = new Date(date);\n    date.setHours(0, 0, 0, 0); // 12:00 am\n    //  console.log(\"date.........................\",date)\n    // date.setHours(date.getHours() - 6);\n    if (shift === \"night\") {\n        // console.log(\"in night condition.........................\")\n        date.setHours(date.getHours() - 6); // 6:00 pm prev day\n    }\n    // console.log(date,nextDay);\n    nextDay = new Date(date);\n    nextDay.setDate(nextDay.getDate() + 3);\n    nextDay.setHours(0, 0, 0, 0);\n    nextDay.setHours(nextDay.getHours() - 11.5);\n    console.log(\"date nextday .................................\", date, nextDay);\n    let message = ``;\n    if (req.admin ||\n        jobProfile?.jobProfileName.toLowerCase() === \"hr\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security head\" ||\n        jobProfile?.jobProfileName.toLowerCase() === \"security\") {\n        let employee = await employeeModel_1.default.findOne({ _id: id })\n            .populate(\"jobProfileId\")\n            .populate(\"groupId\")\n            .exec();\n        if (!employee) {\n            return next(new errorHandler_1.default(\"Employee not found.\", 404));\n        }\n        if (employee.BarCodeStatus === false) {\n            return next(new errorHandler_1.default(\"Employee not active.\", 404));\n        }\n        let currentDate = new Date();\n        currentDate = (0, dateTimeConverter_1.getIndianTime)(currentDate);\n        let atten = await v2attendanceModel_1.default.find({\n            employeeId: employee?._id,\n            date: {\n                $gte: date,\n                $lt: nextDay,\n            },\n            shift: shift,\n        });\n        const attendanceId = atten[atten.length - 1]?._id;\n        let attendanceRecord = await v2attendanceModel_1.default.findById(attendanceId);\n        if (!attendanceRecord) {\n            attendanceRecord = new v2attendanceModel_1.default({\n                employeeId: employee?._id,\n                date: currentDate,\n                shift: shift,\n                punches: [\n                    {\n                        employeeId: employee?._id,\n                        punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                        punchInBy: req.employee?._id || req.admin?._id,\n                    },\n                ],\n                isPresent: true,\n            });\n            message = `Attendance punch In successfully.`;\n        }\n        else {\n            let attDate = new Date(attendanceRecord.date);\n            // condition added for night shift\n            //  console.log( (currentDate.getDate() === attDate.getDate()\n            //  ? attDate.getUTCHours() < 18\n            //  : true));\n            //  console.log(currentDate.getUTCHours())\n            //  console.log(currentDate)\n            //  console.log(currentDate.getUTCHours() > 18);\n            if ((currentDate.getDate() === attDate.getDate()\n                ? attDate.getUTCHours() < 18\n                : true) &&\n                currentDate.getUTCHours() > 18 &&\n                shift === \"night\") {\n                attendanceRecord = new v2attendanceModel_1.default({\n                    employeeId: employee?._id,\n                    date: currentDate,\n                    shift: shift,\n                    punches: [\n                        {\n                            employeeId: employee?._id,\n                            punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                            punchInBy: req.employee?._id || req.admin?._id,\n                            status: \"pending\",\n                        },\n                    ],\n                    isPresent: true,\n                });\n                await attendanceRecord.save();\n                message = `Attendance punch In successfully.`;\n                return resp.status(200).json({\n                    success: true,\n                    message,\n                    attendance: attendanceRecord,\n                    employee,\n                });\n            }\n            const todayAttendance = attendanceRecord.punches;\n            if (!todayAttendance) {\n                attendanceRecord.punches.push({\n                    punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                    punchInBy: req.employee?._id || req.admin?._id,\n                });\n                message = `Attendance punch In successfully.`;\n            }\n            else {\n                const lastPunch = todayAttendance[todayAttendance.length - 1];\n                if (lastPunch && lastPunch.punchOut) {\n                    const newPunch = {\n                        employeeId: employee?._id,\n                        punchIn: (0, dateTimeConverter_1.getIndianTime)(new Date()),\n                        punchInBy: req.employee?._id || req.admin?._id,\n                    };\n                    attendanceRecord.punches.push(newPunch);\n                    message = `Attendance punch In successfully.1`;\n                }\n                else {\n                    const FirstPunchIn = new Date(attendanceRecord.punches[0].punchIn);\n                    FirstPunchIn.setTime(FirstPunchIn.getTime() - 330 * 60 * 1000);\n                    const lastPunchout = new Date();\n                    const data = await (0, productionSlipController_1.getProductivityPerEmployee)(employee._id, FirstPunchIn, lastPunchout);\n                    if (data) {\n                        attendanceRecord.productiveHours = data.productiveHours || 0;\n                        attendanceRecord.productionSlipNumbers =\n                            data.productionSlipNumbers;\n                    }\n                    lastPunch.punchOut = (0, dateTimeConverter_1.getIndianTime)(new Date());\n                    lastPunch.punchOutBy = req.employee?._id || req.admin?._id;\n                    const totalWorking = lastPunch.punchOut.getTime() - FirstPunchIn.getTime();\n                    attendanceRecord.totalWorking = totalWorking;\n                    message = `Attendance punch Out successfully.`;\n                }\n            }\n        }\n        await attendanceRecord.save();\n        resp.status(200).json({\n            success: true,\n            message,\n            attendance: attendanceRecord,\n        });\n    }\n    else {\n        resp.status(200).json({\n            success: false,\n            message: \"Login first as Security or admin or hr.\",\n        });\n    }\n});\nexports.groupOverView = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { date } = req.query;\n    let nextDay;\n    let date1;\n    if (typeof date === \"string\") {\n        date1 = new Date(date);\n        date1.setHours(0, 0, 0, 0);\n        // date1.setHours(date1.getHours() - 6);\n        nextDay = new Date(date1);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    else {\n        date1 = new Date();\n        date1.setHours(0, 0, 0, 0);\n        // date1.setHours(date1.getHours() - 6);\n        nextDay = new Date(date1);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    // date1 = getIndianTime(date1);\n    // nextDay = getIndianTime(nextDay);\n    const allGroups = await groupModel_1.default.find({});\n    const groupStore = [];\n    for (const group of allGroups) {\n        const employees = await employeeModel_1.default.find({ groupId: group._id })\n            .lean()\n            .exec();\n        const empids = employees.map((employee) => employee._id);\n        const attendance = await v2attendanceModel_1.default.find({\n            employeeId: { $in: empids },\n            date: {\n                $gte: date1,\n                $lt: nextDay,\n            },\n        });\n        let approved = 0;\n        let pending = 0;\n        let rejected = 0;\n        for (let temp of attendance) {\n            if (temp.status === \"approved\") {\n                approved += 1;\n            }\n            if (temp.status === \"pending\") {\n                pending += 1;\n            }\n            if (temp.status === \"rejected\") {\n                rejected += 1;\n            }\n        }\n        groupStore.push({\n            groupName: group.groupName,\n            totalEmployeesInGroup: employees.length,\n            employeeIds: employees.map((employee) => employee._id),\n            total: attendance,\n            totalPresent: attendance.length,\n            approved: approved,\n            pending: pending,\n            rejected: rejected,\n        });\n    }\n    res.status(200).json({\n        success: true,\n        groupStore,\n    });\n});\nexports.departmentOverView = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { date } = req.query;\n    let nextDay;\n    let date1;\n    if (typeof date === \"string\") {\n        date1 = new Date(date);\n        date1.setHours(0, 0, 0, 0);\n        // date1.setHours(date1.getHours() - 6);\n        nextDay = new Date(date1);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    else {\n        date1 = new Date();\n        date1.setHours(0, 0, 0, 0);\n        // date1.setHours(date1.getHours() - 6);\n        nextDay = new Date(date1);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    // date1 = getIndianTime(date1);\n    // nextDay = getIndianTime(nextDay);\n    const allDepartment = await department_1.default.find({});\n    const departmentStore = [];\n    for (const depart of allDepartment) {\n        const jobProfiles = await jobProfileModel_1.default.find({\n            department: depart._id,\n        }).exec();\n        const employees = await employeeModel_1.default.find({\n            jobProfileId: { $in: jobProfiles },\n        })\n            .lean()\n            .exec();\n        const empids = employees.map((employee) => employee._id);\n        const attendance = await v2attendanceModel_1.default.find({\n            employeeId: { $in: empids },\n            date: {\n                $gte: date1,\n                $lt: nextDay,\n            },\n        });\n        let approved = 0;\n        let pending = 0;\n        let rejected = 0;\n        for (let temp of attendance) {\n            if (temp.status === \"approved\") {\n                approved += 1;\n            }\n            if (temp.status === \"pending\") {\n                pending += 1;\n            }\n            if (temp.status === \"rejected\") {\n                rejected += 1;\n            }\n        }\n        departmentStore.push({\n            departmentName: depart.departmentName,\n            totalEmployeesInGroup: employees.length,\n            //employeeIds: employees.map((employee) => employee._id),\n            totalPresent: attendance.length,\n            approved: approved,\n            pending: pending,\n            rejected: rejected,\n        });\n    }\n    res.status(200).json({\n        success: true,\n        departmentStore,\n    });\n});\nexports.shopOverView = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { date } = req.query;\n    let nextDay;\n    let date1;\n    if (typeof date === \"string\") {\n        date1 = new Date(date);\n        date1.setHours(0, 0, 0, 0);\n        // date1.setHours(date1.getHours() - 6);\n        nextDay = new Date(date1);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    else {\n        date1 = new Date();\n        date1.setHours(0, 0, 0, 0);\n        // date1.setHours(date1.getHours() - 6);\n        nextDay = new Date(date1);\n        nextDay.setDate(nextDay.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n    }\n    // date1 = getIndianTime(date1);\n    // nextDay = getIndianTime(nextDay);\n    const allShops = await shopModel_1.default.find({})\n        .populate({\n        path: \"jobProfile\",\n    })\n        .exec();\n    const shopStore = [];\n    for (const shop of allShops) {\n        const jobprofile = await jobProfileModel_1.default.find({\n            _id: shop.jobProfile.jobProfileId,\n        });\n        //console.log(\"HIII\",jobprofile)\n        const jobprofileIds = jobprofile.map((job) => job._id);\n        const employee = await employeeModel_1.default.find({\n            jobProfileId: { $in: jobprofileIds },\n        });\n        const empIds = employee.map((e) => e._id);\n        //console.log(\"temp\",empIds)\n        const attendance = await v2attendanceModel_1.default.find({\n            approvedBy: { $in: empIds },\n            date: {\n                $gte: date1,\n                $lt: nextDay,\n            },\n        });\n        let approved = 0;\n        let pending = 0;\n        let rejected = 0;\n        let manual = 0;\n        for (let temp of attendance) {\n            if (temp.status === \"approved\") {\n                approved += 1;\n            }\n            if (temp.status === \"pending\") {\n                pending += 1;\n            }\n            if (temp.status === \"rejected\") {\n                rejected += 1;\n            }\n            if (temp.status === \"added Manually by administrator\") {\n                manual += 1;\n            }\n        }\n        shopStore.push({\n            shopName: shop.shopName,\n            //totalEmployeesInGroup: employees.length,\n            //employeeIds: employees.map((employee) => employee._id),\n            total: attendance,\n            totalPresent: attendance.length,\n            approved: approved,\n            //pending: pending,\n            manual: manual,\n            rejected: rejected,\n        });\n    }\n    res.status(200).json({\n        success: true,\n        shopStore,\n    });\n});\nexports.getPunchRecordsNumber = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    let { date, nextDate, groupName, departmentName, jobProfileName, name, limit = 20, page = 1, } = req.body;\n    limit = +limit;\n    page = +page;\n    const skip = (page - 1) * limit;\n    let filterDate;\n    let nextDay;\n    if (typeof date === \"string\") {\n        filterDate = new Date(date);\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    else {\n        filterDate = new Date();\n        filterDate.setHours(0, 0, 0, 0);\n        // filterDate.setHours(filterDate.getHours() - 6);\n    }\n    if (typeof nextDate === \"string\") {\n        nextDay = new Date(nextDate);\n        nextDay.setHours(0, 0, 0, 0);\n        nextDay.setDate(nextDay.getDate() + 1);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    else {\n        nextDay = new Date(filterDate);\n        nextDay.setDate(filterDate.getDate() + 1);\n        nextDay.setHours(0, 0, 0, 0);\n        // nextDay.setHours(nextDay.getHours() - 6);\n    }\n    // const isHR = jobProfile?.jobProfileName.toLowerCase() === \"hr\";\n    // const isAdmin = req.admin;\n    const filter = {};\n    const filter1 = {};\n    let jobProfileIds = [];\n    if (groupName &&\n        Array.isArray(groupName) &&\n        groupName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyGroupNames = groupName.filter((name) => name.trim() !== \"\");\n        const groups = await groupModel_1.default\n            .find({ groupName: { $in: nonEmptyGroupNames } })\n            .exec();\n        const groupIds = groups.map((group) => group._id);\n        filter.groupId = { $in: groupIds };\n    }\n    // Add departmentName filter if provided and non-empty\n    if (departmentName &&\n        Array.isArray(departmentName) &&\n        departmentName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyDepartmentNames = departmentName.filter((name) => name.trim() !== \"\");\n        const departments = await department_1.default\n            .find({ departmentName: { $in: nonEmptyDepartmentNames } })\n            .exec();\n        const departmentIds = departments.map((department) => department._id);\n        const jobProfiles = await jobProfileModel_1.default.find({\n            department: { $in: departmentIds },\n        }).exec();\n        const jobProfileIds = jobProfiles.map((jobProfile) => jobProfile._id);\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    // Add jobProfileName filter if provided and non-empty\n    if (jobProfileName &&\n        Array.isArray(jobProfileName) &&\n        jobProfileName.some((name) => name.trim() !== \"\")) {\n        const nonEmptyJobProfileNames = jobProfileName.filter((name) => name.trim() !== \"\");\n        const jobProfiles = await jobProfileModel_1.default.find({\n            jobProfileName: { $in: nonEmptyJobProfileNames },\n        }).exec();\n        const ids = jobProfiles.map((jobProfile) => jobProfile._id);\n        jobProfileIds = [...jobProfileIds, ...ids];\n        filter.jobProfileId = { $in: jobProfileIds };\n    }\n    if (name) {\n        filter.$or = [{ name: name }, { employeeCode: name }];\n        filter1.$or = [{ name: name }, { employeeCode: name }];\n    }\n    // const punchIn: any[] = [];\n    // const punchOut: any[] = [];\n    let countIn = 0;\n    let countOut = 0;\n    let totalPresent = 0;\n    const totalEmployees = await employeeModel_1.default.countDocuments();\n    const employeeid = await employeeModel_1.default.find(filter).exec();\n    const ids = employeeid.map((employee) => employee._id);\n    const allData = await v2attendanceModel_1.default\n        .find({\n        employeeId: { $in: ids },\n        date: {\n            $gte: filterDate,\n            $lt: nextDay,\n        },\n    })\n        .populate({ path: \"employeeId\", select: \"name\" })\n        .populate({ path: \"punches.punchInBy\", select: \"name\" })\n        .populate({ path: \"punches.punchOutBy\", select: \"name\" })\n        .populate(\"approvedBy\")\n        .exec();\n    totalPresent = allData.length;\n    for (let data of allData) {\n        const firstPunchIn = data.punches[0].punchIn;\n        const lastPunchOut = data.punches[data.punches.length - 1].punchOut;\n        if (firstPunchIn !== null) {\n            countIn += 1;\n        }\n        if (lastPunchOut !== null) {\n            countOut += 1;\n        }\n    }\n    resp.status(200).json({\n        success: true,\n        message: \"All attendance successfully.\",\n        countIn: countIn,\n        countOut: countOut,\n        totalEmployees,\n        totalPresent,\n    });\n});\nexports.updatePunchOut = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    if (req.supervisor) {\n        let { id } = req.params;\n        let { punchIn, punchOut, date, remarks, shift } = req.body;\n        let employee = await employeeModel_1.default.findById(id);\n        if (!employee) {\n            resp.status(400).json({\n                success: false,\n                message: req.supervisor._id,\n            });\n        }\n        const attendanceRecord = await v2attendanceModel_1.default.findOne({\n            employeeId: employee?._id,\n            date: date,\n        });\n        if (attendanceRecord) {\n            const obj = [\n                {\n                    punchIn: punchIn,\n                    punchOut: punchOut,\n                    employeeId: employee?._id,\n                    punchInBy: req.supervisor._id,\n                },\n            ];\n            const remark = [\n                {\n                    remark: remarks,\n                    createdAt: Date.now(),\n                    by: req.supervisor._id,\n                },\n            ];\n            const updateAttendance = await v2attendanceModel_1.default.findByIdAndUpdate(attendanceRecord._id, {\n                shift: shift,\n                $push: { remarks: remark },\n                punches: obj,\n                status: \"added Manually by administrator\",\n            }, { new: true });\n            resp.status(200).json({\n                success: true,\n                updateAttendance,\n                message: \"record updated successfully\",\n            });\n        }\n        else {\n            resp.status(400).json({\n                success: false,\n                message: \"Record not found create new.\",\n            });\n        }\n    }\n    else {\n        resp.status(400).json({\n            success: false,\n            message: \"Login first as supervisor\",\n        });\n    }\n});\n// update attendance for one day only for all employee\nexports.updateAttendanceDetails = (0, catchAsyncError_1.default)(async (req, resp, next) => {\n    const date = new Date(\"2023-11-10\");\n    const nextDate = new Date(\"2023-11-11\");\n    const attendance = await v2attendanceModel_1.default.find({\n        shift: \"day\",\n        date: {\n            $gt: date,\n            $lt: nextDate,\n        },\n    });\n    for (let data of attendance) {\n        const punchIn = data.punches[0].punchIn;\n        let punchOut = data.punches[data.punches.length - 1].punchOut;\n        if (punchOut && new Date(punchOut) >= new Date(\"2023-11-10T16:30:00.000Z\")) {\n            punchOut = new Date(\"2023-11-10T16:30:00.000Z\");\n        }\n        if (punchOut === null) {\n            punchOut = new Date(\"2023-11-10T16:30:00.000Z\");\n        }\n        const obj = [\n            {\n                punchIn: punchIn,\n                punchOut: punchOut,\n                employeeId: data.employeeId,\n                punchInBy: data.punches[0].punchInBy,\n                punchOutBy: data.punches[0].punchOutBy,\n            },\n        ];\n        const updateAttendance = await v2attendanceModel_1.default.findByIdAndUpdate(data._id, {\n            punches: obj,\n        }, { new: true });\n    }\n    resp.status(200).json({\n        success: true,\n        total: attendance.length,\n        attendance,\n    });\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/v2attendanceController.ts?");

/***/ }),

/***/ "./src/controllers/employee/workingDayController.ts":
/*!**********************************************************!*\
  !*** ./src/controllers/employee/workingDayController.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMonthData = exports.deleteMonth = exports.updateWorkingDay = exports.addWorkingDay = void 0;\nconst workingDayModel_1 = __importDefault(__webpack_require__(/*! ../../database/models/workingDayModel */ \"./src/database/models/workingDayModel.ts\"));\nconst dateTimeConverter_1 = __webpack_require__(/*! ../../middleware/dateTimeConverter */ \"./src/middleware/dateTimeConverter.ts\");\nconst catchAsyncError_1 = __importDefault(__webpack_require__(/*! ../../utils/catchAsyncError */ \"./src/utils/catchAsyncError.ts\"));\nexports.addWorkingDay = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { year, monthName, workingDay } = req.body;\n    const currentDate = (0, dateTimeConverter_1.getIndianTime)(new Date());\n    if (!monthName || monthName.trim() === \"\") {\n        return res.status(400).json({\n            success: false,\n            message: \"Month name is required and must not be empty.\",\n        });\n    }\n    const existingYearData = await workingDayModel_1.default.findOne({ year });\n    if (existingYearData) {\n        const isMonthNameDuplicate = existingYearData.month.some((month) => month.monthName === monthName);\n        if (isMonthNameDuplicate) {\n            return res.status(400).json({\n                success: false,\n                message: `Month '${monthName}' already exists for the given year.`,\n            });\n        }\n        existingYearData.month.push({\n            monthName,\n            workingDay,\n            createdAt: currentDate,\n        });\n        await existingYearData.save();\n        res.status(200).json({\n            success: true,\n            workingData: existingYearData,\n            message: \"Added working day successfully for the existing year.\",\n        });\n    }\n    else {\n        const workingData = await workingDayModel_1.default.create({\n            year: year,\n            month: [\n                {\n                    monthName: monthName,\n                    workingDay,\n                    createdAt: currentDate,\n                },\n            ],\n        });\n        res.status(200).json({\n            success: true,\n            workingData,\n            message: \"Added working day successfully for the new year.\",\n        });\n    }\n});\nexports.updateWorkingDay = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { year, monthName, workingDay } = req.body;\n    if (!monthName || monthName.trim() === \"\") {\n        return res.status(400).json({\n            success: false,\n            message: \"Month name is required and must not be empty.\",\n        });\n    }\n    try {\n        const existingYearData = await workingDayModel_1.default.findOne({ year });\n        if (existingYearData) {\n            const monthIndex = existingYearData.month.findIndex((month) => month.monthName === monthName);\n            if (monthIndex !== -1) {\n                existingYearData.month[monthIndex].workingDay = workingDay;\n                existingYearData.month[monthIndex].updatedAt = (0, dateTimeConverter_1.getIndianTime)(new Date());\n                await existingYearData.save();\n                res.status(200).json({\n                    success: true,\n                    workingData: existingYearData,\n                    message: `Updated working day for ${monthName} successfully.`,\n                });\n            }\n            else {\n                res.status(404).json({\n                    success: false,\n                    message: `Month '${monthName}' not found for the given year.`,\n                });\n            }\n        }\n        else {\n            res.status(404).json({\n                success: false,\n                message: `Year '${year}' not found.`,\n            });\n        }\n    }\n    catch (error) {\n        return next(error);\n    }\n});\nexports.deleteMonth = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { year, monthName } = req.body;\n    if (!monthName || monthName.trim() === \"\") {\n        return res.status(400).json({\n            success: false,\n            message: \"Month name is required and must not be empty.\",\n        });\n    }\n    const existingYearData = await workingDayModel_1.default.findOne({ year });\n    if (existingYearData) {\n        // Use $pull operator to remove the specified month\n        existingYearData.month = existingYearData.month.filter((month) => month.monthName !== monthName);\n        await existingYearData.save();\n        res.status(200).json({\n            success: true,\n            workingData: existingYearData,\n            message: `Deleted month '${monthName}' successfully.`,\n        });\n    }\n    else {\n        res.status(404).json({\n            success: false,\n            message: `Year '${year}' not found.`,\n        });\n    }\n});\nexports.getMonthData = (0, catchAsyncError_1.default)(async (req, res, next) => {\n    const { year } = req.query;\n    const workingData = await workingDayModel_1.default.find({ year: year });\n    if (workingData.length > 0) {\n        res.status(200).json({\n            success: true,\n            message: \"Working data fetched successfully.\",\n            workingData: workingData,\n        });\n    }\n    else {\n        res.status(404).json({\n            success: false,\n            message: `Year '${year}' not found.`,\n        });\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/controllers/employee/workingDayController.ts?");

/***/ }),

/***/ "./src/database/connection/connectDb.ts":
/*!**********************************************!*\
  !*** ./src/database/connection/connectDb.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connectDB = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst connectDB = async () => {\n    try {\n        const connect = await mongoose_1.default.connect(`${process.env.DB_URI}`);\n        console.log(\"DB connected\");\n        return connect;\n    }\n    catch (err) {\n        console.log(err.message);\n    }\n};\nexports.connectDB = connectDB;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/connection/connectDb.ts?");

/***/ }),

/***/ "./src/database/models/CNCProgramLogModel.ts":
/*!***************************************************!*\
  !*** ./src/database/models/CNCProgramLogModel.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst CNCProgramLog_1 = __importDefault(__webpack_require__(/*! ../schemas/CNCProgramLog */ \"./src/database/schemas/CNCProgramLog.ts\"));\nconst CNCProgramLogModel = mongoose_1.default.model(\"CNCProgramLog\", CNCProgramLog_1.default);\nexports[\"default\"] = CNCProgramLogModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/CNCProgramLogModel.ts?");

/***/ }),

/***/ "./src/database/models/CNCProgramModel.ts":
/*!************************************************!*\
  !*** ./src/database/models/CNCProgramModel.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst CNCProgramSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/CNCProgramSchema */ \"./src/database/schemas/CNCProgramSchema.ts\"));\nconst CNCProgramModel = mongoose_1.default.model(\"CNCProgram\", CNCProgramSchema_1.default);\nexports[\"default\"] = CNCProgramModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/CNCProgramModel.ts?");

/***/ }),

/***/ "./src/database/models/adminModel.ts":
/*!*******************************************!*\
  !*** ./src/database/models/adminModel.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst adminSchema_1 = __webpack_require__(/*! ../schemas/adminSchema */ \"./src/database/schemas/adminSchema.ts\");\nconst AdminModel = mongoose_1.default.model(\"Admin\", adminSchema_1.adminSchema);\nexports[\"default\"] = AdminModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/adminModel.ts?");

/***/ }),

/***/ "./src/database/models/attendanceModel.ts":
/*!************************************************!*\
  !*** ./src/database/models/attendanceModel.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst attendanceSchema_1 = __webpack_require__(/*! ../schemas/attendanceSchema */ \"./src/database/schemas/attendanceSchema.ts\");\nconst attendanceModel = (0, mongoose_1.model)(\"Attendance\", attendanceSchema_1.AttendanceSchema);\nexports[\"default\"] = attendanceModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/attendanceModel.ts?");

/***/ }),

/***/ "./src/database/models/barCodeModel.ts":
/*!*********************************************!*\
  !*** ./src/database/models/barCodeModel.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst barCodeSchema_1 = __webpack_require__(/*! ../schemas/barCodeSchema */ \"./src/database/schemas/barCodeSchema.ts\");\nconst BarCode = mongoose_1.default.model('BarCode', barCodeSchema_1.barCodeSchema);\nexports[\"default\"] = BarCode;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/barCodeModel.ts?");

/***/ }),

/***/ "./src/database/models/childPartModel.ts":
/*!***********************************************!*\
  !*** ./src/database/models/childPartModel.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst childPartSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/childPartSchema */ \"./src/database/schemas/childPartSchema.ts\"));\nconst ChildPartModel = mongoose_1.default.model(\"ChildPart\", childPartSchema_1.default);\nexports[\"default\"] = ChildPartModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/childPartModel.ts?");

/***/ }),

/***/ "./src/database/models/customerModel.ts":
/*!**********************************************!*\
  !*** ./src/database/models/customerModel.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst customerSchema_1 = __webpack_require__(/*! ../schemas/customerSchema */ \"./src/database/schemas/customerSchema.ts\");\nconst customerModel = mongoose_1.default.model(\"customer\", customerSchema_1.customerSchema);\nexports[\"default\"] = customerModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/customerModel.ts?");

/***/ }),

/***/ "./src/database/models/department.ts":
/*!*******************************************!*\
  !*** ./src/database/models/department.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst departmentSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/departmentSchema */ \"./src/database/schemas/departmentSchema.ts\"));\nconst departmentModel = mongoose_1.default.model(\"Department\", departmentSchema_1.default);\nexports[\"default\"] = departmentModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/department.ts?");

/***/ }),

/***/ "./src/database/models/employeeDocsModel.ts":
/*!**************************************************!*\
  !*** ./src/database/models/employeeDocsModel.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst employeeDocsSchema_1 = __webpack_require__(/*! ../schemas/employeeDocsSchema */ \"./src/database/schemas/employeeDocsSchema.ts\");\nconst EmployeeDocsModel = mongoose_1.default.model(\"EmployeeDocs\", employeeDocsSchema_1.employeeDocsSchema);\nexports[\"default\"] = EmployeeDocsModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/employeeDocsModel.ts?");

/***/ }),

/***/ "./src/database/models/employeeModel.ts":
/*!**********************************************!*\
  !*** ./src/database/models/employeeModel.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst employeeSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/employeeSchema */ \"./src/database/schemas/employeeSchema.ts\"));\nconst EmployeeModel = mongoose_1.default.model(\"Employee\", employeeSchema_1.default);\nexports[\"default\"] = EmployeeModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/employeeModel.ts?");

/***/ }),

/***/ "./src/database/models/finishItemGroupModel.ts":
/*!*****************************************************!*\
  !*** ./src/database/models/finishItemGroupModel.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst finishItemGroupSchema_1 = __webpack_require__(/*! ../schemas/finishItemGroupSchema */ \"./src/database/schemas/finishItemGroupSchema.ts\");\nconst FinishItemGroupModel = mongoose_1.default.model(\"finishItemGroup\", finishItemGroupSchema_1.finishItemGroupSchema);\nexports[\"default\"] = FinishItemGroupModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/finishItemGroupModel.ts?");

/***/ }),

/***/ "./src/database/models/finishedItemModel.ts":
/*!**************************************************!*\
  !*** ./src/database/models/finishedItemModel.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst finishedItem_1 = __importDefault(__webpack_require__(/*! ../schemas/finishedItem */ \"./src/database/schemas/finishedItem.ts\"));\nconst FinishedItemModel = mongoose_1.default.model(\"FinishedItem\", finishedItem_1.default);\nexports[\"default\"] = FinishedItemModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/finishedItemModel.ts?");

/***/ }),

/***/ "./src/database/models/globalProcessModel.ts":
/*!***************************************************!*\
  !*** ./src/database/models/globalProcessModel.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst globalProcessSchema_1 = __webpack_require__(/*! ../schemas/globalProcessSchema */ \"./src/database/schemas/globalProcessSchema.ts\");\nconst globalProcessModel = mongoose_1.default.model(\"GlobalProcess\", globalProcessSchema_1.globalProcessSchema);\nexports[\"default\"] = globalProcessModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/globalProcessModel.ts?");

/***/ }),

/***/ "./src/database/models/godownModel.ts":
/*!********************************************!*\
  !*** ./src/database/models/godownModel.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst GodownSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/GodownSchema */ \"./src/database/schemas/GodownSchema.ts\"));\nconst GodownModel = mongoose_1.default.model(\"Godown\", GodownSchema_1.default);\nexports[\"default\"] = GodownModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/godownModel.ts?");

/***/ }),

/***/ "./src/database/models/groupModel.ts":
/*!*******************************************!*\
  !*** ./src/database/models/groupModel.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst groupSchema_1 = __webpack_require__(/*! ../schemas/groupSchema */ \"./src/database/schemas/groupSchema.ts\");\nconst groupModel = (0, mongoose_1.model)(\"Group\", groupSchema_1.groupSchema);\nexports[\"default\"] = groupModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/groupModel.ts?");

/***/ }),

/***/ "./src/database/models/jobProfileModel.ts":
/*!************************************************!*\
  !*** ./src/database/models/jobProfileModel.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst jobProfileSchema_1 = __webpack_require__(/*! ../schemas/jobProfileSchema */ \"./src/database/schemas/jobProfileSchema.ts\");\nconst JobProfileModel = (0, mongoose_1.model)(\"JobProfile\", jobProfileSchema_1.JobProfileSchema);\nexports[\"default\"] = JobProfileModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/jobProfileModel.ts?");

/***/ }),

/***/ "./src/database/models/leaveModel.ts":
/*!*******************************************!*\
  !*** ./src/database/models/leaveModel.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst leaveSchema_1 = __webpack_require__(/*! ../schemas/leaveSchema */ \"./src/database/schemas/leaveSchema.ts\");\nconst LeaveModel = mongoose_1.default.model(\"Leave\", leaveSchema_1.leaveSchema);\nexports[\"default\"] = LeaveModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/leaveModel.ts?");

/***/ }),

/***/ "./src/database/models/loginHistoryModel.ts":
/*!**************************************************!*\
  !*** ./src/database/models/loginHistoryModel.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst loginHistroy_1 = __webpack_require__(/*! ../schemas/loginHistroy */ \"./src/database/schemas/loginHistroy.ts\");\nconst loginHistoryModel = mongoose_1.default.model(\"loginHistory\", loginHistroy_1.loginHistorySchema);\nexports[\"default\"] = loginHistoryModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/loginHistoryModel.ts?");

/***/ }),

/***/ "./src/database/models/machineModel.ts":
/*!*********************************************!*\
  !*** ./src/database/models/machineModel.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst machineSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/machineSchema */ \"./src/database/schemas/machineSchema.ts\"));\nconst machineModel = mongoose_1.default.model(\"machine\", machineSchema_1.default);\nexports[\"default\"] = machineModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/machineModel.ts?");

/***/ }),

/***/ "./src/database/models/machineQrCodeLogModel.ts":
/*!******************************************************!*\
  !*** ./src/database/models/machineQrCodeLogModel.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst machineQrCodeSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/machineQrCodeSchema */ \"./src/database/schemas/machineQrCodeSchema.ts\"));\nconst MachineQrCodeModel = mongoose_1.default.model(\"machineQrLogs\", machineQrCodeSchema_1.default);\nexports[\"default\"] = MachineQrCodeModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/machineQrCodeLogModel.ts?");

/***/ }),

/***/ "./src/database/models/notificationModel.ts":
/*!**************************************************!*\
  !*** ./src/database/models/notificationModel.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst notificationSchema_1 = __webpack_require__(/*! ../schemas/notificationSchema */ \"./src/database/schemas/notificationSchema.ts\");\nconst notificationModel = (0, mongoose_1.model)(\"Notification\", notificationSchema_1.notificationSchema);\nexports[\"default\"] = notificationModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/notificationModel.ts?");

/***/ }),

/***/ "./src/database/models/parentDepartment.ts":
/*!*************************************************!*\
  !*** ./src/database/models/parentDepartment.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst parentDepartmentSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/parentDepartmentSchema */ \"./src/database/schemas/parentDepartmentSchema.ts\"));\nconst parentDepartmentModel = mongoose_1.default.model(\"ParentDepartment\", parentDepartmentSchema_1.default);\nexports[\"default\"] = parentDepartmentModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/parentDepartment.ts?");

/***/ }),

/***/ "./src/database/models/planningModel.ts":
/*!**********************************************!*\
  !*** ./src/database/models/planningModel.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst planningSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/planningSchema */ \"./src/database/schemas/planningSchema.ts\"));\nconst PlanningModel = mongoose_1.default.model(\"Planning\", planningSchema_1.default);\nexports[\"default\"] = PlanningModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/planningModel.ts?");

/***/ }),

/***/ "./src/database/models/productionSlipModel.ts":
/*!****************************************************!*\
  !*** ./src/database/models/productionSlipModel.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst productionSilpSchema_1 = __webpack_require__(/*! ../schemas/productionSilpSchema */ \"./src/database/schemas/productionSilpSchema.ts\");\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst ProductionSlipModel = mongoose_1.default.model(\"ProductionSlip\", productionSilpSchema_1.productionSlipSchema);\nexports[\"default\"] = ProductionSlipModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/productionSlipModel.ts?");

/***/ }),

/***/ "./src/database/models/quizModel.ts":
/*!******************************************!*\
  !*** ./src/database/models/quizModel.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst quizSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/quizSchema */ \"./src/database/schemas/quizSchema.ts\"));\nconst QuizModel = mongoose_1.default.model(\"Quiz\", quizSchema_1.default);\nexports[\"default\"] = QuizModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/quizModel.ts?");

/***/ }),

/***/ "./src/database/models/rawMaterialGroup.ts":
/*!*************************************************!*\
  !*** ./src/database/models/rawMaterialGroup.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst rawMaterialGroupSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/rawMaterialGroupSchema */ \"./src/database/schemas/rawMaterialGroupSchema.ts\"));\nconst rawMaterialGroupModel = mongoose_1.default.model(\"RawMaterialGroup\", rawMaterialGroupSchema_1.default);\nexports[\"default\"] = rawMaterialGroupModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/rawMaterialGroup.ts?");

/***/ }),

/***/ "./src/database/models/salaryLogModel.ts":
/*!***********************************************!*\
  !*** ./src/database/models/salaryLogModel.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst salaryLogSchema_1 = __webpack_require__(/*! ../schemas/salaryLogSchema */ \"./src/database/schemas/salaryLogSchema.ts\");\nconst SalaryLogModel = mongoose_1.default.model('SalaryLog', salaryLogSchema_1.salaryLogSchema);\nexports[\"default\"] = SalaryLogModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/salaryLogModel.ts?");

/***/ }),

/***/ "./src/database/models/scanSlipModel.ts":
/*!**********************************************!*\
  !*** ./src/database/models/scanSlipModel.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst scanSlipSchema_1 = __webpack_require__(/*! ../schemas/scanSlipSchema */ \"./src/database/schemas/scanSlipSchema.ts\");\nconst scannedSlipModel = mongoose_1.default.model(\"scanedSlip\", scanSlipSchema_1.scanSlipSchema);\nexports[\"default\"] = scannedSlipModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/scanSlipModel.ts?");

/***/ }),

/***/ "./src/database/models/shopLogModel.ts":
/*!*********************************************!*\
  !*** ./src/database/models/shopLogModel.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst shopLogSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/shopLogSchema */ \"./src/database/schemas/shopLogSchema.ts\"));\nconst ShopLogModel = mongoose_1.default.model(\"ShopLog\", shopLogSchema_1.default);\nexports[\"default\"] = ShopLogModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/shopLogModel.ts?");

/***/ }),

/***/ "./src/database/models/shopModel.ts":
/*!******************************************!*\
  !*** ./src/database/models/shopModel.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst shopSchema_1 = __importDefault(__webpack_require__(/*! ../schemas/shopSchema */ \"./src/database/schemas/shopSchema.ts\"));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst ShopModel = mongoose_1.default.model(\"shop\", shopSchema_1.default);\nexports[\"default\"] = ShopModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/shopModel.ts?");

/***/ }),

/***/ "./src/database/models/trainingModel.ts":
/*!**********************************************!*\
  !*** ./src/database/models/trainingModel.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst trainingSchema_1 = __webpack_require__(/*! ../schemas/trainingSchema */ \"./src/database/schemas/trainingSchema.ts\");\nconst TrainingModel = mongoose_1.default.model(\"Training\", trainingSchema_1.trainingSchema);\nexports[\"default\"] = TrainingModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/trainingModel.ts?");

/***/ }),

/***/ "./src/database/models/v2attendanceModel.ts":
/*!**************************************************!*\
  !*** ./src/database/models/v2attendanceModel.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst v2AttendanceSchema_1 = __webpack_require__(/*! ../schemas/v2AttendanceSchema */ \"./src/database/schemas/v2AttendanceSchema.ts\");\nconst v2AttendanceModel = mongoose_1.default.model(\"v2Attendance\", v2AttendanceSchema_1.Attendance);\nexports[\"default\"] = v2AttendanceModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/v2attendanceModel.ts?");

/***/ }),

/***/ "./src/database/models/workOrderModel.ts":
/*!***********************************************!*\
  !*** ./src/database/models/workOrderModel.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst workOrderSchema_1 = __webpack_require__(/*! ../schemas/workOrderSchema */ \"./src/database/schemas/workOrderSchema.ts\");\nconst workOrderModel = mongoose_1.default.model(\"workOrder\", workOrderSchema_1.workOrderSchema);\nexports[\"default\"] = workOrderModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/workOrderModel.ts?");

/***/ }),

/***/ "./src/database/models/workingDayModel.ts":
/*!************************************************!*\
  !*** ./src/database/models/workingDayModel.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst workingDaySchema_1 = __webpack_require__(/*! ../schemas/workingDaySchema */ \"./src/database/schemas/workingDaySchema.ts\");\nconst workingDayModel = mongoose_1.default.model(\"workingDay\", workingDaySchema_1.workingDaySchema);\nexports[\"default\"] = workingDayModel;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/models/workingDayModel.ts?");

/***/ }),

/***/ "./src/database/schemas/CNCProgramLog.ts":
/*!***********************************************!*\
  !*** ./src/database/schemas/CNCProgramLog.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst CNCProgramLogSchema = new mongoose_1.default.Schema({\n    CNCProgramId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"CNCProgram\",\n    },\n    logNumber: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    processName: {\n        type: String\n    },\n    processId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n    },\n    weight: { type: Number },\n    programName: { type: String },\n    rawMaterialName: { type: String },\n    rawMaterialCode: { type: String },\n    nesting: {\n        file: { type: String },\n        description: { type: String }\n    },\n    DXF: {\n        file: { type: String },\n        description: { type: String },\n    },\n    drawing: {\n        file: { type: String },\n        description: { type: String },\n    },\n    startTime: {\n        type: Date,\n    },\n    endTime: {\n        type: Date,\n    },\n    sheetConsumed: {\n        type: Number,\n    },\n    cycleTimeAsProgram: {\n        type: Number,\n    },\n    currentCycleTime: {\n        type: Number,\n    },\n    programLogNumber: {\n        type: String,\n    },\n    employees: [\n        {\n            employeeId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n            },\n            employeeName: {\n                type: String,\n            },\n        },\n    ],\n    machines: [\n        {\n            machineId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"machine\",\n            },\n            machineName: {\n                type: String,\n            },\n        },\n    ],\n    productionSlipNumber: [String],\n    by: {\n        name: {\n            type: String,\n        },\n        id: {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n        },\n    },\n}, {\n    timestamps: true,\n});\nexports[\"default\"] = CNCProgramLogSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/CNCProgramLog.ts?");

/***/ }),

/***/ "./src/database/schemas/CNCProgramSchema.ts":
/*!**************************************************!*\
  !*** ./src/database/schemas/CNCProgramSchema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst CNCProgramSchema = new mongoose_1.default.Schema({\n    programName: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    programNumber: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    rawMaterialName: {\n        type: String,\n    },\n    rawMaterialCode: {\n        type: String,\n    },\n    rawMaterialId: {\n        type: mongoose_1.default.Schema.Types.ObjectId\n    },\n    weight: {\n        type: Number,\n    },\n    processName: {\n        type: String,\n    },\n    processId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n    },\n    DXF: {\n        file: { type: String },\n        description: {\n            type: String,\n        },\n    },\n    drawing: {\n        file: { type: String },\n        description: {\n            type: String,\n        },\n    },\n    status: {\n        type: String,\n    },\n    nesting: {\n        file: {\n            type: String,\n        },\n        description: {\n            type: String,\n        },\n    },\n    scrap: {\n        quantity: {\n            type: Number,\n        },\n        unit: {\n            type: String,\n        },\n    },\n    cycleTime: {\n        type: Number,\n    },\n    childParts: [\n        {\n            childPart: {\n                childPartName: { type: String },\n                id: { type: mongoose_1.default.Schema.Types.ObjectId },\n            },\n            childPartProduced: {\n                type: Number,\n            },\n            weightPerChildPart: {\n                type: Number,\n            },\n            weightUnit: {\n                type: String,\n            },\n        },\n    ],\n    isCompleted: {\n        type: Boolean,\n        default: false,\n    },\n});\nexports[\"default\"] = CNCProgramSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/CNCProgramSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/GodownSchema.ts":
/*!**********************************************!*\
  !*** ./src/database/schemas/GodownSchema.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst GodownSchema = new mongoose_1.default.Schema({\n    godownName: {\n        type: String,\n        unique: true,\n    },\n    godownCode: {\n        type: String,\n        unique: true,\n    },\n}, {\n    timestamps: true,\n});\nexports[\"default\"] = GodownSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/GodownSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/adminSchema.ts":
/*!*********************************************!*\
  !*** ./src/database/schemas/adminSchema.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.adminSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.adminSchema = new mongoose_1.default.Schema({\n    name: {\n        type: String,\n        required: [true, \"Name is required\"]\n    },\n    email: {\n        type: String,\n        required: [true, \"Email is required\"]\n    },\n    password: {\n        type: String,\n        required: [true, \"Password is required\"],\n        select: false\n    },\n    role: {\n        type: String,\n        default: \"admin\"\n    }\n}, {\n    timestamps: true\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/adminSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/attendanceSchema.ts":
/*!**************************************************!*\
  !*** ./src/database/schemas/attendanceSchema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttendanceSchema = void 0;\nconst mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.AttendanceSchema = new mongoose_1.Schema({\n    employeeId: {\n        type: mongoose_1.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    date: {\n        type: Date,\n        default: Date.now,\n    },\n    punches: [\n        {\n            employeeId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n            },\n            punchIn: {\n                type: Date,\n                default: null,\n            },\n            punchOut: {\n                type: Date,\n                default: null,\n            },\n            approvedImage: {\n                type: String,\n                // default: null,\n            },\n            punchInBy: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n                default: null,\n            },\n            punchOutBy: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n                default: null,\n            },\n            approvedBy: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n                default: null,\n            },\n            status: {\n                type: String,\n                default: \"pending\",\n            },\n        },\n    ],\n    workingHours: {\n        type: Number,\n        default: 0,\n    },\n    pendingHours: {\n        type: Number,\n        default: 0,\n    },\n    totalEarning: {\n        type: Number,\n        default: 0,\n    },\n    isPresent: {\n        type: Boolean,\n        default: false,\n    },\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/attendanceSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/barCodeSchema.ts":
/*!***********************************************!*\
  !*** ./src/database/schemas/barCodeSchema.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.barCodeSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.barCodeSchema = new mongoose_1.default.Schema({\n    employeeId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\"\n    },\n    barCodeNumber: {\n        type: String,\n    },\n    assignedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\"\n    },\n    proofPicture: {\n        type: String\n    }\n}, {\n    timestamps: true\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/barCodeSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/childPartSchema.ts":
/*!*************************************************!*\
  !*** ./src/database/schemas/childPartSchema.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst childPartSchema = new mongoose_1.default.Schema({\n    partName: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    productionGodown: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Godown\"\n    },\n    group: {\n        groupId: {\n            type: mongoose_1.default.Schema.Types.ObjectId\n        },\n        groupName: {\n            type: String\n        }\n    },\n    finishedItemId: {\n        type: mongoose_1.default.Schema.Types.ObjectId\n    },\n    // for raw materials \n    childPartType: {\n        type: String\n    },\n    materialCode: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    typeOfMaterial: {\n        type: String\n    },\n    unit: {\n        type: String\n    },\n    numberOfItem: {\n        type: Number\n    },\n    processId: {\n        type: mongoose_1.default.Schema.Types.ObjectId\n    },\n    processName: {\n        type: String\n    },\n    // ------------------\n    consumedItem: [{\n            itemId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"ChildPart\"\n            },\n            itemName: {\n                type: String\n            },\n            itemType: {\n                type: String\n            },\n            consumedItemQuantity: {\n                type: Number\n            },\n            consumptionGodown: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Godown\"\n            }\n        }]\n}, {\n    timestamps: true\n});\nexports[\"default\"] = childPartSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/childPartSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/customerSchema.ts":
/*!************************************************!*\
  !*** ./src/database/schemas/customerSchema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.customerSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.customerSchema = new mongoose_1.default.Schema({\n    customerName: {\n        type: String,\n    },\n    code: {\n        type: String,\n        unique: true,\n    },\n    date: {\n        type: Date,\n    },\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/customerSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/departmentSchema.ts":
/*!**************************************************!*\
  !*** ./src/database/schemas/departmentSchema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst departmentSchema = new mongoose_1.default.Schema({\n    departmentName: {\n        type: String,\n        required: true,\n    },\n    parentDepartmentId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"ParentDepartment\",\n    },\n    description: {\n        type: String,\n        required: true,\n    },\n});\nexports[\"default\"] = departmentSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/departmentSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/employeeDocsSchema.ts":
/*!****************************************************!*\
  !*** ./src/database/schemas/employeeDocsSchema.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.employeeDocsSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.employeeDocsSchema = new mongoose_1.default.Schema({\n    employeeId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    profilePicture: {\n        type: String,\n    },\n    proofPicture: [{ type: String }],\n    document: [\n        {\n            docsName: String,\n            docs: String,\n            status: {\n                type: String,\n                default: \"pending\"\n            }\n        },\n    ],\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/employeeDocsSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/employeeSchema.ts":
/*!************************************************!*\
  !*** ./src/database/schemas/employeeSchema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst employeeSchema = new mongoose_1.default.Schema({\n    name: {\n        type: String,\n    },\n    active: {\n        type: Boolean,\n        default: true,\n    },\n    groupId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Group\",\n    },\n    jobProfileId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"JobProfile\",\n    },\n    role: {\n        type: String,\n        enum: [\n            \"admin\",\n            \"dbManager\",\n            \"attendanceManager\",\n            \"employee\",\n            \"manufacturing\",\n            \"security\",\n            \"supervisor\",\n            \"attendanceViewer\",\n        ],\n        default: \"employee\",\n    },\n    optionForRole: [String],\n    employeeCode: {\n        type: String,\n        trim: true,\n        unique: true,\n    },\n    email: {\n        type: String,\n    },\n    contactNumber: {\n        type: Number,\n        unique: true,\n    },\n    verified: {\n        type: Boolean,\n        default: false,\n    },\n    password: {\n        type: String,\n    },\n    dateOfBirth: {\n        type: Date,\n    },\n    gender: {\n        type: String,\n    },\n    dateOfJoining: {\n        type: Date,\n    },\n    lunchTime: {\n        type: Number,\n    },\n    salary: {\n        type: Number,\n    },\n    expactedSalary: {\n        type: Number,\n    },\n    leaveTaken: {\n        type: Number,\n        default: 0,\n    },\n    currentBarCode: {\n        type: String,\n    },\n    BarCodeStatus: {\n        type: Boolean,\n        default: true,\n    },\n    permanentBarCode: {\n        type: String,\n    },\n    permanentBarCodeNumber: {\n        type: String,\n    },\n    permanentQrCodeAssign: {\n        type: Date,\n    },\n    assignedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    workingDays: {\n        type: Number,\n    },\n    workingHours: {\n        type: Number,\n    },\n    overTime: {\n        type: Boolean,\n    },\n    overTimeRate: {\n        type: Number,\n    },\n    trainingStatus: {\n        type: String,\n        default: \"Not started\",\n    },\n    // new details for Employee\n    PF_UAN_Number: {\n        type: String,\n        trim: true,\n    },\n    ESI_ID: {\n        type: String,\n        trim: true,\n    },\n    PAN_Number: {\n        type: String,\n        trim: true,\n        unique: true,\n    },\n    salaryMode: {\n        type: String,\n        enum: [\"cash\", \"bank\"],\n    },\n    bankDetails: {\n        bankName: {\n            type: String,\n        },\n        branch: {\n            type: String,\n        },\n        accountNumber: {\n            type: Number,\n            trim: true,\n        },\n        IFSC_Code: {\n            type: String,\n            trim: true,\n        },\n    },\n    aadharNumber: {\n        type: String,\n        trim: true,\n        unique: true,\n    },\n    updateBy: {\n        by: mongoose_1.default.Schema.Types.ObjectId,\n        name: String\n    },\n    addedby: {\n        by: mongoose_1.default.Schema.Types.ObjectId,\n        name: String\n    },\n    marks: [\n        {\n            type: Number,\n        },\n    ],\n    productionLogs: [\n        {\n            productionSlipId: {\n                type: mongoose_1.default.Schema.Types.ObjectId\n            },\n            time: {\n                type: Date\n            },\n        }\n    ]\n}, {\n    timestamps: true,\n});\nexports[\"default\"] = employeeSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/employeeSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/finishItemGroupSchema.ts":
/*!*******************************************************!*\
  !*** ./src/database/schemas/finishItemGroupSchema.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.finishItemGroupSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.finishItemGroupSchema = new mongoose_1.default.Schema({\n    groupName: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    groupDescription: {\n        type: String\n    }\n}, {\n    timestamps: true\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/finishItemGroupSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/finishedItem.ts":
/*!**********************************************!*\
  !*** ./src/database/schemas/finishedItem.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst FinishedItemSchema = new mongoose_1.default.Schema({\n    itemName: {\n        type: String,\n        unique: true,\n        trim: true,\n    },\n    MCode: {\n        type: String,\n        unique: true,\n        trim: true,\n    },\n    partCode: {\n        type: String,\n        unique: true,\n        trim: true,\n    },\n    status: {\n        type: String,\n    },\n    bomCompleted: {\n        type: Boolean,\n        default: false,\n    },\n    finishItemGroups: [\n        {\n            groupId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n            },\n            groupName: {\n                type: String,\n            },\n        },\n    ],\n    masterBom: [\n        {\n            childPart: {\n                id: { type: mongoose_1.default.Schema.Types.ObjectId, ref: \"ChildPart\" },\n                childPartName: { type: String },\n            },\n            process: {\n                id: { type: mongoose_1.default.Schema.Types.ObjectId },\n                processName: { type: String },\n            },\n            quantity: {\n                type: Number,\n                default: 1,\n            },\n        },\n    ],\n    customer: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"customer\",\n    },\n    numberOfProcess: {\n        type: Number,\n    },\n}, {\n    timestamps: true\n});\nexports[\"default\"] = FinishedItemSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/finishedItem.ts?");

/***/ }),

/***/ "./src/database/schemas/globalProcessSchema.ts":
/*!*****************************************************!*\
  !*** ./src/database/schemas/globalProcessSchema.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.globalProcessSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.globalProcessSchema = new mongoose_1.default.Schema({\n    processName: {\n        type: String,\n        unique: true,\n    },\n    processCode: {\n        type: String,\n        unique: true,\n    },\n    // departmentId: {\n    //   type: mongoose.Schema.Types.ObjectId,\n    //   ref: \"Department\",\n    // },\n    shop: {\n        shopId: {\n            type: mongoose_1.default.Schema.Types.ObjectId\n        },\n        shopName: {\n            type: String\n        }\n    }\n}, { timestamps: true });\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/globalProcessSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/groupSchema.ts":
/*!*********************************************!*\
  !*** ./src/database/schemas/groupSchema.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.groupSchema = void 0;\nconst mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.groupSchema = new mongoose_1.Schema({\n    groupName: {\n        type: String,\n    },\n    parentGroupId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Group\",\n        default: null\n    },\n    description: {\n        type: String\n    },\n    childGroupId: [\n        {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n            ref: \"Group\",\n        },\n    ],\n    employeesInGroup: {\n        type: Number,\n    },\n    newFields: [\n        {\n            fieldName: {\n                type: String\n            },\n            fieldValue: {\n                type: String,\n                default: \"\"\n            }\n        }\n    ]\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/groupSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/jobProfileSchema.ts":
/*!**************************************************!*\
  !*** ./src/database/schemas/jobProfileSchema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JobProfileSchema = void 0;\nconst mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.JobProfileSchema = new mongoose_1.Schema({\n    jobProfileName: {\n        type: String,\n    },\n    parentJobProfileId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"JobProfile\",\n        default: null,\n    },\n    jobRank: {\n        type: Number\n    },\n    jobDescription: {\n        type: String\n    },\n    childProfileId: [{\n            type: mongoose_1.default.Schema.Types.ObjectId,\n            ref: \"JobProfile\",\n        }],\n    numberOfEmployees: {\n        type: Number,\n    },\n    employmentType: {\n        type: String\n    },\n    jobSkill: {\n        type: String\n    },\n    department: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Department\"\n    },\n    isSupervisor: {\n        type: Boolean,\n        default: false\n    },\n    newFields: [\n        {\n            fieldName: {\n                type: String\n            },\n            fieldValue: {\n                type: String,\n                default: \"\"\n            }\n        }\n    ]\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/jobProfileSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/leaveSchema.ts":
/*!*********************************************!*\
  !*** ./src/database/schemas/leaveSchema.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.leaveSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.leaveSchema = new mongoose_1.default.Schema({\n    employeeId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\"\n    },\n    appliedDate: {\n        type: Date\n    },\n    appliedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\"\n    },\n    from: {\n        type: Date\n    },\n    to: {\n        type: Date\n    },\n    message: {\n        type: String\n    },\n    status: {\n        type: String\n    },\n    acceptedDate: {\n        type: Date\n    },\n    acceptedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    rejectedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    rejectedDate: {\n        type: Date\n    },\n    rejectedReason: {\n        type: String\n    },\n    approvedDate: {\n        type: Date\n    },\n    gatePassDate: {\n        type: Date\n    },\n    gatePassTime: {\n        type: String\n    },\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/leaveSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/loginHistroy.ts":
/*!**********************************************!*\
  !*** ./src/database/schemas/loginHistroy.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loginHistorySchema = void 0;\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nexports.loginHistorySchema = new mongoose_1.Schema({\n    user: {\n        type: mongoose_1.Schema.Types.ObjectId,\n    },\n    userInfo: {\n        name: String,\n        jobProfile: String,\n        employeeCode: String,\n        role: String,\n    },\n    logInTime: {\n        type: Date,\n    },\n    ipAddress: {\n        type: String,\n    },\n    device: {\n        userAgent: {\n            type: String,\n        },\n        platform: {\n            type: String,\n        },\n    },\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/loginHistroy.ts?");

/***/ }),

/***/ "./src/database/schemas/machineQrCodeSchema.ts":
/*!*****************************************************!*\
  !*** ./src/database/schemas/machineQrCodeSchema.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst machineQrCodeSchema = new mongoose_1.default.Schema({\n    machine: {\n        machineName: {\n            type: String,\n        },\n        id: {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n        },\n    },\n    AssignBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId\n    },\n    QrCode: {\n        type: String,\n    },\n    date: {\n        type: Date,\n    },\n    proofPicture: {\n        type: String,\n        required: false, // Set 'required' to 'false' to make it optional\n    },\n});\nexports[\"default\"] = machineQrCodeSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/machineQrCodeSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/machineSchema.ts":
/*!***********************************************!*\
  !*** ./src/database/schemas/machineSchema.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst machineSchema = new mongoose_1.default.Schema({\n    machineName: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    code: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    process: [{ type: mongoose_1.default.Schema.Types.ObjectId, ref: \"GlobalProcess\" }],\n    QrCode: {\n        type: String\n    },\n    proofPicture: {\n        type: String,\n        required: false, // Set 'required' to 'false' to make it optional\n    },\n    picture: {\n        type: String,\n        required: false, // Set 'required' to 'false' to make it optional\n    },\n    logs: [{\n            productionSlipId: {\n                type: mongoose_1.default.Schema.Types.ObjectId\n            },\n            time: {\n                type: Date\n            }\n        }]\n}, {\n    timestamps: true,\n});\nexports[\"default\"] = machineSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/machineSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/notificationSchema.ts":
/*!****************************************************!*\
  !*** ./src/database/schemas/notificationSchema.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.notificationSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.notificationSchema = new mongoose_1.default.Schema({\n    notification: [{\n            notificationType: {\n                type: String\n            },\n            message: {\n                type: String\n            },\n            date: {\n                type: Date\n            }\n        }],\n    employeeId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\"\n    }\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/notificationSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/parentDepartmentSchema.ts":
/*!********************************************************!*\
  !*** ./src/database/schemas/parentDepartmentSchema.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst parentDeparmentSchema = new mongoose_1.default.Schema({\n    departmentName: {\n        type: String,\n        required: true,\n    },\n    childDepartmentId: [\n        {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n            ref: \"Department\",\n        },\n    ],\n    description: {\n        type: String,\n        required: true,\n    },\n});\nexports[\"default\"] = parentDeparmentSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/parentDepartmentSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/planningSchema.ts":
/*!************************************************!*\
  !*** ./src/database/schemas/planningSchema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst PlanningSchema = new mongoose_1.default.Schema({\n    finishedItemId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"FinishedItem\",\n    },\n    finishedItemName: {\n        type: String\n    },\n    status: {\n        type: String,\n        enum: [\"active\", \"inactive\"],\n    },\n    minimumInventory: {\n        type: Number,\n    },\n    month: {\n        type: Date,\n    },\n    dates: [\n        {\n            date: {\n                type: Date,\n            },\n            day: {\n                type: String,\n            },\n            orderValue: {\n                type: Number,\n                default: 0\n            },\n            dispatchValue: {\n                type: Number,\n                default: 0\n            },\n            by: [{\n                    date: { type: Date },\n                    employeeId: { type: mongoose_1.default.Schema.Types.ObjectId },\n                    name: { type: String },\n                    orderValue: {\n                        type: Number\n                    }\n                }],\n        },\n    ],\n}, {\n    timestamps: true\n});\nexports[\"default\"] = PlanningSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/planningSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/productionSilpSchema.ts":
/*!******************************************************!*\
  !*** ./src/database/schemas/productionSilpSchema.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.productionSlipSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.productionSlipSchema = new mongoose_1.default.Schema({\n    productionSlipNumber: {\n        type: String,\n        unique: true,\n    },\n    workOrderId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        required: [true, \"WorkOrder Id is required.\"],\n        ref: \"workOrder\",\n    },\n    printCount: {\n        type: Number,\n        default: 0\n    },\n    QRCode: {\n        type: String,\n    },\n    origin: {\n        type: String,\n    },\n    part: {\n        _id: {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n        },\n        partName: {\n            type: String,\n        },\n    },\n    shop: {\n        shopName: {\n            type: String,\n        },\n        shopId: {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n        },\n    },\n    durationFrom: {\n        type: Date,\n    },\n    durationTo: {\n        type: Date,\n    },\n    process: {\n        processId: {\n            type: mongoose_1.default.Schema.Types.ObjectId,\n        },\n        processName: {\n            type: String,\n        },\n    },\n    numberOfItems: {\n        type: Number,\n    },\n    itemPerWorkOrder: {\n        type: Number\n    },\n    itemProduced: {\n        type: Number,\n        default: 0,\n    },\n    status: {\n        type: String,\n        default: \"inactive\",\n    },\n    manualRemark: {\n        type: String\n    },\n    consumedItem: [\n        {\n            _id: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n            },\n            partName: {\n                type: String,\n            },\n            materialCode: {\n                type: String,\n            },\n            typeOfMaterial: {\n                type: String,\n            },\n            consumptionGodownId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n            },\n            consumptionGodownName: {\n                type: String,\n            },\n            childPartType: {\n                type: String,\n            },\n            unit: {\n                type: String,\n            },\n            numberOfItem: {\n                type: Number,\n            },\n            numberOfItemConsumed: {\n                type: Number,\n                default: 0,\n            },\n        },\n    ],\n    createdBy: {\n        name: {\n            type: String\n        },\n        employeeId: {\n            type: mongoose_1.default.Schema.Types.ObjectId\n        }\n    },\n    activatedBy: {\n        name: {\n            type: String\n        },\n        employeeId: {\n            type: mongoose_1.default.Schema.Types.ObjectId\n        }\n    },\n    completedBy: {\n        name: {\n            type: String\n        },\n        employeeId: {\n            type: mongoose_1.default.Schema.Types.ObjectId\n        }\n    },\n    working: [\n        {\n            updatedBy: {\n                name: {\n                    type: String\n                },\n                employeeId: {\n                    type: mongoose_1.default.Schema.Types.ObjectId\n                }\n            },\n            itemProduced: {\n                type: Number,\n                default: 0,\n            },\n            startTime: {\n                type: Date,\n            },\n            endTime: {\n                type: Date,\n            },\n            employees: [\n                {\n                    employeeId: {\n                        type: mongoose_1.default.Schema.Types.ObjectId,\n                        ref: \"Employee\",\n                    },\n                    employeeName: {\n                        type: String,\n                    },\n                },\n            ],\n            machines: [\n                {\n                    machineId: {\n                        type: mongoose_1.default.Schema.Types.ObjectId,\n                        ref: \"machine\",\n                    },\n                    machineName: {\n                        type: String,\n                    },\n                },\n            ],\n        },\n    ],\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/productionSilpSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/quizSchema.ts":
/*!********************************************!*\
  !*** ./src/database/schemas/quizSchema.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst quizSchema = new mongoose_1.default.Schema({\n    question: {\n        type: String,\n        required: true,\n    },\n    options: [\n        {\n            type: String,\n            required: true,\n        },\n    ],\n    correctAnswer: {\n        type: String,\n        required: true,\n    },\n    points: {\n        type: Number,\n        required: true,\n    },\n    jobProfileId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"JobProfile\"\n    },\n    createdBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\"\n    }\n}, {\n    timestamps: true\n});\nexports[\"default\"] = quizSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/quizSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/rawMaterialGroupSchema.ts":
/*!********************************************************!*\
  !*** ./src/database/schemas/rawMaterialGroupSchema.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst rawMaterialGroupSchema = new mongoose_1.default.Schema({\n    groupName: {\n        type: String\n    },\n    description: {\n        type: String\n    }\n});\nexports[\"default\"] = rawMaterialGroupSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/rawMaterialGroupSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/salaryLogSchema.ts":
/*!*************************************************!*\
  !*** ./src/database/schemas/salaryLogSchema.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.salaryLogSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.salaryLogSchema = new mongoose_1.default.Schema({\n    employeeId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    applicableMonth: {\n        type: Date,\n    },\n    salary: {\n        type: Number,\n    },\n    changedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/salaryLogSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/scanSlipSchema.ts":
/*!************************************************!*\
  !*** ./src/database/schemas/scanSlipSchema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scanSlipSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.scanSlipSchema = new mongoose_1.default.Schema({\n    date: String,\n    shift: String,\n    shop: [\n        {\n            shop: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: 'shop',\n            },\n            shopName: String,\n            scannedSlip: [String],\n            registered: {\n                type: Number,\n                default: 0\n            },\n            manual: {\n                type: Number,\n                default: 0\n            },\n        },\n    ],\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/scanSlipSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/shopLogSchema.ts":
/*!***********************************************!*\
  !*** ./src/database/schemas/shopLogSchema.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst ShopLogSchema = new mongoose_1.default.Schema({\n    shopId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n    },\n    date: {\n        type: Date\n    },\n    employees: [{\n            employeeId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n            },\n            employeeName: {\n                type: String,\n            }\n        }]\n});\nexports[\"default\"] = ShopLogSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/shopLogSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/shopSchema.ts":
/*!********************************************!*\
  !*** ./src/database/schemas/shopSchema.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst ShopSchema = new mongoose_1.default.Schema({\n    shopName: {\n        type: String,\n        unique: true,\n        required: true,\n    },\n    jobProfile: {\n        jobProfileId: { type: mongoose_1.default.Schema.Types.ObjectId },\n        jobProfileName: {\n            type: String\n        }\n    },\n    shopCode: {\n        type: String,\n        unique: true,\n        required: true\n    }\n}, {\n    timestamps: true\n});\nexports[\"default\"] = ShopSchema;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/shopSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/trainingSchema.ts":
/*!************************************************!*\
  !*** ./src/database/schemas/trainingSchema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.trainingSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.trainingSchema = new mongoose_1.default.Schema({\n    jobProfileId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"JobProfile\",\n    },\n    groupId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Group\",\n    },\n    trainingMaterial: [\n        {\n            resourceName: {\n                type: String,\n            },\n            resourceUrl: {\n                type: String,\n            },\n        },\n    ],\n    status: {\n        type: String,\n    },\n    marks: {\n        type: String,\n    },\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/trainingSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/v2AttendanceSchema.ts":
/*!****************************************************!*\
  !*** ./src/database/schemas/v2AttendanceSchema.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Attendance = void 0;\nconst mongoose_1 = __importStar(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.Attendance = new mongoose_1.Schema({\n    employeeId: {\n        type: mongoose_1.Schema.Types.ObjectId,\n        ref: \"Employee\",\n    },\n    date: {\n        type: Date,\n        default: Date.now,\n    },\n    approvedImage: {\n        type: String,\n    },\n    approvedBy: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"Employee\",\n        default: null,\n    },\n    approvedTime: {\n        type: Date,\n        default: null,\n    },\n    status: {\n        type: String,\n        default: \"pending\",\n    },\n    shift: {\n        type: String,\n    },\n    remarks: [\n        {\n            remark: String,\n            by: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                // ref: \"Employee\",\n            },\n            createdAt: Date,\n        },\n    ],\n    punches: [\n        {\n            employeeId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n            },\n            punchIn: {\n                type: Date,\n                default: null,\n            },\n            punchOut: {\n                type: Date,\n                default: null,\n            },\n            punchInBy: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n                default: null,\n            },\n            punchOutBy: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n                ref: \"Employee\",\n                default: null,\n            },\n        },\n    ],\n    totalWorking: {\n        type: Number,\n        default: 0\n    },\n    productiveHours: {\n        type: Number\n    },\n    productionSlipNumbers: [{\n            type: String\n        }]\n}, { timestamps: true });\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/v2AttendanceSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/workOrderSchema.ts":
/*!*************************************************!*\
  !*** ./src/database/schemas/workOrderSchema.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.workOrderSchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.workOrderSchema = new mongoose_1.default.Schema({\n    date: {\n        type: Date,\n    },\n    orderNumber: {\n        type: String,\n        unique: true,\n        trim: true\n    },\n    customerId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n    },\n    customerName: {\n        type: String,\n        trim: true\n    },\n    finishedItemId: {\n        type: mongoose_1.default.Schema.Types.ObjectId,\n        ref: \"FinishedItem\",\n    },\n    finishItemName: {\n        type: String,\n    },\n    partCode: {\n        type: String,\n    },\n    MCode: {\n        type: String,\n    },\n    orderQuantity: {\n        type: Number,\n    },\n    status: {\n        type: String,\n        default: \"pending\",\n        enum: [\"pending\", \"inProgress\", \"completed\", \"cancel\"],\n    },\n    masterBom: [\n        {\n            partName: {\n                type: String,\n            },\n            _id: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n            },\n            process: {\n                type: String,\n            },\n            processId: {\n                type: mongoose_1.default.Schema.Types.ObjectId\n            },\n            unit: {\n                type: String,\n            },\n            numberOfItem: {\n                type: Number,\n                default: 1,\n            },\n            productionGodownId: {\n                type: mongoose_1.default.Schema.Types.ObjectId,\n            },\n            productionGodownName: {\n                type: String,\n            },\n            itemProduced: {\n                type: Number,\n                default: 0,\n            },\n            newChild: [\n                {\n                    _id: {\n                        type: mongoose_1.default.Schema.Types.ObjectId,\n                    },\n                    partName: {\n                        type: String,\n                    },\n                    materialCode: {\n                        type: String,\n                    },\n                    typeOfMaterial: {\n                        type: String,\n                    },\n                    consumptionGodownId: {\n                        type: mongoose_1.default.Schema.Types.ObjectId\n                    },\n                    consumptionGodownName: {\n                        type: String\n                    },\n                    childPartType: {\n                        type: String,\n                    },\n                    unit: {\n                        type: String,\n                    },\n                    numberOfItem: {\n                        type: Number,\n                    },\n                },\n            ],\n        },\n    ],\n}, {\n    timestamps: true,\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/workOrderSchema.ts?");

/***/ }),

/***/ "./src/database/schemas/workingDaySchema.ts":
/*!**************************************************!*\
  !*** ./src/database/schemas/workingDaySchema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.workingDaySchema = void 0;\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nexports.workingDaySchema = new mongoose_1.default.Schema({\n    year: Number,\n    month: [\n        {\n            monthName: {\n                type: String,\n                unique: true,\n                trim: true,\n            },\n            workingDay: {\n                type: Number,\n                trim: true,\n            },\n            createdAt: Date,\n            updatedAt: Date,\n        },\n    ],\n});\n\n\n//# sourceURL=webpack://chawla-ispat/./src/database/schemas/workingDaySchema.ts?");

/***/ }),

/***/ "./src/middleware/auth.ts":
/*!********************************!*\
  !*** ./src/middleware/auth.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAuthenticatedSupervisor = exports.isAuthenticatedAdminOrDbManager = exports.isAuthenticatedAdminOrAttendanceManager = exports.isAuthenticatedAdminOrHR = void 0;\nconst jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\"));\nconst adminModel_1 = __importDefault(__webpack_require__(/*! ../database/models/adminModel */ \"./src/database/models/adminModel.ts\"));\nconst employeeModel_1 = __importDefault(__webpack_require__(/*! ../database/models/employeeModel */ \"./src/database/models/employeeModel.ts\"));\nconst jobProfileModel_1 = __importDefault(__webpack_require__(/*! ../database/models/jobProfileModel */ \"./src/database/models/jobProfileModel.ts\"));\nconst isAuthenticatedAdminOrHR = async (req, resp, next) => {\n    const { token } = req.cookies;\n    if (!token) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Login first.\",\n        });\n    }\n    try {\n        const decodedData = jsonwebtoken_1.default.verify(token, process.env.JWT_KEY);\n        if (decodedData) {\n            const admin = await adminModel_1.default.findById({ _id: decodedData.user });\n            if (admin) {\n                req.admin = admin;\n                return next();\n            }\n            else {\n                const employee = await employeeModel_1.default.findById({ _id: decodedData.user });\n                if (employee) {\n                    req.employee = employee;\n                    return next();\n                }\n                else {\n                    return resp.status(404).json({\n                        success: false,\n                        message: \"Employee not found in middleware.\",\n                    });\n                }\n            }\n        }\n        else {\n            return resp.status(401).json({\n                success: false,\n                message: \"Invalid token.\",\n            });\n        }\n    }\n    catch (error) {\n        return resp.status(401).json({\n            success: false,\n            message: \"Invalid token in catch.\",\n        });\n    }\n};\nexports.isAuthenticatedAdminOrHR = isAuthenticatedAdminOrHR;\nconst isAuthenticatedAdminOrAttendanceManager = async (req, resp, next) => {\n    const { token } = req.cookies;\n    if (!token) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Login first.\",\n        });\n    }\n    try {\n        const decodedData = jsonwebtoken_1.default.verify(token, process.env.JWT_KEY);\n        if (decodedData) {\n            const admin = await adminModel_1.default.findById({ _id: decodedData.user });\n            if (admin) {\n                req.admin = admin;\n                return next();\n            }\n            else {\n                const employee = await employeeModel_1.default.findById({ _id: decodedData.user });\n                if (employee) {\n                    const role = employee.role;\n                    if (role === \"attendanceManager\") {\n                        req.attendanceManager = employee;\n                        return next();\n                    }\n                }\n                else {\n                    return resp.status(404).json({\n                        success: false,\n                        message: \"Employee is not attendanceManager.\",\n                    });\n                }\n            }\n        }\n        else {\n            return resp.status(401).json({\n                success: false,\n                message: \"Invalid token.\",\n            });\n        }\n    }\n    catch (error) {\n        return resp.status(401).json({\n            success: false,\n            message: \"Invalid token in catch.\",\n        });\n    }\n};\nexports.isAuthenticatedAdminOrAttendanceManager = isAuthenticatedAdminOrAttendanceManager;\nconst isAuthenticatedAdminOrDbManager = async (req, resp, next) => {\n    const { token } = req.cookies;\n    if (!token) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Login first.\",\n        });\n    }\n    try {\n        const decodedData = jsonwebtoken_1.default.verify(token, process.env.JWT_KEY);\n        if (decodedData) {\n            const admin = await adminModel_1.default.findById({ _id: decodedData.user });\n            if (admin) {\n                req.admin = admin;\n                return next();\n            }\n            else {\n                const employee = await employeeModel_1.default.findById({ _id: decodedData.user });\n                if (employee) {\n                    const role = employee.role;\n                    if (role === \"dbManager\") {\n                        req.dbManager = employee;\n                        return next();\n                    }\n                    else {\n                        return resp.status(404).json({\n                            success: false,\n                            message: \"Employee is not Database Manager.\",\n                        });\n                    }\n                }\n                else {\n                    return resp.status(404).json({\n                        success: false,\n                        message: \"Employee is not found.\",\n                    });\n                }\n            }\n        }\n        else {\n            return resp.status(401).json({\n                success: false,\n                message: \"Invalid token.\",\n            });\n        }\n    }\n    catch (error) {\n        return resp.status(401).json({\n            success: false,\n            message: \"Invalid token in catch.\",\n        });\n    }\n};\nexports.isAuthenticatedAdminOrDbManager = isAuthenticatedAdminOrDbManager;\nconst isAuthenticatedSupervisor = async (req, resp, next) => {\n    const { token } = req.cookies;\n    if (!token) {\n        return resp.status(404).json({\n            success: false,\n            message: \"Login first.\",\n        });\n    }\n    try {\n        const decodedData = jsonwebtoken_1.default.verify(token, process.env.JWT_KEY);\n        if (decodedData) {\n            const admin = await adminModel_1.default.findById({ _id: decodedData.user });\n            if (admin) {\n                req.admin = admin;\n                return next();\n            }\n            else {\n                const employee = await employeeModel_1.default.findById({ _id: decodedData.user });\n                if (employee) {\n                    const role = employee.role;\n                    const job = await jobProfileModel_1.default.findOne({ _id: employee.jobProfileId });\n                    if (role === \"supervisor\" && job?.isSupervisor) {\n                        req.supervisor = employee;\n                        return next();\n                    }\n                    else {\n                        return resp.status(404).json({\n                            success: false,\n                            message: \"Employee is not supervisor.\",\n                        });\n                    }\n                }\n                else {\n                    return resp.status(404).json({\n                        success: false,\n                        message: \"Employee is not supervisor.\",\n                    });\n                }\n            }\n        }\n        else {\n            return resp.status(401).json({\n                success: false,\n                message: \"Invalid token.\",\n            });\n        }\n    }\n    catch (error) {\n        return resp.status(401).json({\n            success: false,\n            message: \"Invalid token in catch.\",\n        });\n    }\n};\nexports.isAuthenticatedSupervisor = isAuthenticatedSupervisor;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/middleware/auth.ts?");

/***/ }),

/***/ "./src/middleware/dateTimeConverter.ts":
/*!*********************************************!*\
  !*** ./src/middleware/dateTimeConverter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getIndianTime = void 0;\nfunction getIndianTime(date) {\n    const currentTime = new Date(date);\n    const utcOffsetInMinutes = 330; // Indian timezone offset is +5:30 (5 hours * 60 minutes + 30 minutes)\n    const indianTime = new Date(currentTime.getTime() + utcOffsetInMinutes * 60 * 1000);\n    return indianTime;\n}\nexports.getIndianTime = getIndianTime;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/middleware/dateTimeConverter.ts?");

/***/ }),

/***/ "./src/middleware/errorHandler.ts":
/*!****************************************!*\
  !*** ./src/middleware/errorHandler.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.errorMiddleware = void 0;\nclass ErrorHandler extends Error {\n    statusCode;\n    constructor(message, statusCode) {\n        super(message);\n        this.statusCode = statusCode;\n    }\n}\nconst errorMiddleware = (err, req, resp, next) => {\n    return resp.status(err.statusCode || 400).json({\n        success: false,\n        message: err.message,\n    });\n};\nexports.errorMiddleware = errorMiddleware;\nexports[\"default\"] = ErrorHandler;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/middleware/errorHandler.ts?");

/***/ }),

/***/ "./src/routes/CNCProgramRoutes.ts":
/*!****************************************!*\
  !*** ./src/routes/CNCProgramRoutes.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst multer_1 = __importDefault(__webpack_require__(/*! multer */ \"multer\"));\nconst CNCProgramController_1 = __webpack_require__(/*! ../controllers/bomControllers/CNCProgramController */ \"./src/controllers/bomControllers/CNCProgramController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst CNCProgramRouter = express_1.default.Router();\nconst storage = multer_1.default.memoryStorage();\nconst upload = (0, multer_1.default)({ storage: storage });\nCNCProgramRouter.route(\"/addNew\").post(upload.fields([{ name: 'DFX', maxCount: 1 }, { name: 'drawing', maxCount: 1 }, { name: 'nesting', maxCount: 1 }]), CNCProgramController_1.addCNCProgram);\n// add childPart in CNCProgram\nCNCProgramRouter.route(\"/addChildPart/:programId\").post(CNCProgramController_1.addChildPartInCNCProgram);\n// get All\nCNCProgramRouter.route(\"/getAll\").post(CNCProgramController_1.allProgram);\n// Finalize the Program\nCNCProgramRouter.route(\"/finalize/:programId\").post(upload.single(\"file\"), CNCProgramController_1.finalizeProgram);\n// update production of childPart\nCNCProgramRouter.route(\"/updateProduction/:programId\").post(CNCProgramController_1.updateProduction);\n// update fields of CNC Program\nCNCProgramRouter.route(\"/updateProgram/:programId\").post(upload.fields([{ name: 'DFX', maxCount: 1 }, { name: 'drawing', maxCount: 1 }, { name: 'nesting', maxCount: 1 }]), CNCProgramController_1.updateCNCProgram);\n// create logs\nCNCProgramRouter.route(\"/createLog/:programId\").post(auth_1.isAuthenticatedAdminOrHR, CNCProgramController_1.addProgramProductionSlip);\n// get workOrder by ChildPart\nCNCProgramRouter.route(\"/getWorkOrderByChildPart/:childPartId\").get(CNCProgramController_1.getWorkOrderByChildPart);\n// getting all logs Of CNC program\nCNCProgramRouter.route(\"/logs\").post(CNCProgramController_1.CNCProgramLogs);\n// delete CNCProgramLog\nCNCProgramRouter.route(\"/log/:logId\").delete(CNCProgramController_1.CNCProgramLogsDelete);\n// Delete ChildPart from CNCProgram\nCNCProgramRouter.route(\"/removeChild/:id\").patch(CNCProgramController_1.deleteChildPartFromProgram);\n// get single Program and Delete Program\nCNCProgramRouter.route(\"/:id\").get(CNCProgramController_1.singleProgram).delete(CNCProgramController_1.deleteCNCProgram);\n// add rawMaterial ID \n// CNCProgramRouter.route(\"/addRawMaterialId\").post(addRawMaterialId);\nexports[\"default\"] = CNCProgramRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/CNCProgramRoutes.ts?");

/***/ }),

/***/ "./src/routes/adminRoutes.ts":
/*!***********************************!*\
  !*** ./src/routes/adminRoutes.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst adminController_1 = __webpack_require__(/*! ../controllers/admin/adminController */ \"./src/controllers/admin/adminController.ts\");\nconst adminRouter = (0, express_1.Router)();\nadminRouter.route(\"/add\").post(adminController_1.addAdmin);\nadminRouter.route(\"/\").get(adminController_1.getAllAdmin);\nadminRouter.route(\"/:id\").patch(adminController_1.updateAdmin).delete(adminController_1.deleteAdmin);\nexports[\"default\"] = adminRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/adminRoutes.ts?");

/***/ }),

/***/ "./src/routes/attendanceRoutes.ts":
/*!****************************************!*\
  !*** ./src/routes/attendanceRoutes.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst attendanceController_1 = __webpack_require__(/*! ../controllers/employee/attendanceController */ \"./src/controllers/employee/attendanceController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst attendanceRouter = (0, express_1.Router)();\n// by QR Code\nattendanceRouter.route(\"/addAttendance\").post(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.markAttendanceWithEmployeeId); //v1\nattendanceRouter.route(\"/find-employee-by-Qr\").post(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.getEmployeeByQRCode);\n// attendanceRouter.route(\"/getTodaysPunchIns\").get(getTodaysPunchIns);//data\n// attendanceRouter.route(\"/getEmployeeTotalHours\").get(getEmployeeTotalHours);\nattendanceRouter.route(\"/updateAttendance\").patch(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.updateAttendance); //update v1\nattendanceRouter.route(\"/\").get(attendanceController_1.absentAndPresentEmployee); //v1\nattendanceRouter.route(\"/myAttendance\").get(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.myAttendance); //v1\nattendanceRouter.route(\"/singleEmployee/:employeeId\").get(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.singleEmployeeAttendance); //v1\n// security\nattendanceRouter.route(\"/getPunchInPunchOut\").get(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.getPunchRecords); //v1\nattendanceRouter.route(\"/staffAttendance\").get(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.employeeStaffAttendance); //v1\nattendanceRouter.route(\"/groupPresent\").get(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.getGroupPunchRecords); //v1\n// attendanceRouter.router('/getAllPunchInPunchOutData',isAuthenticatedAdminOrHR)\n// get group salary record with attendance\nattendanceRouter.route(\"/groupSalary\").get(auth_1.isAuthenticatedAdminOrHR, attendanceController_1.getGroupRecordPerDay);\nattendanceRouter.route(\"/lastPunchOut\").get(attendanceController_1.getFirstPunchInLastPunchOut);\n// attendanceRouter.route(\"/getallpunches\").get(isAuthenticatedAdminOrHR,getAllEmployeePunches); // Get all punched without approved\n// attendanceRouter.route(\"/getattendancebydate\").get(isAuthenticatedAdminOrHR,getEmployeePunchesByDate);\n// attendanceRouter.route(\"/myattendance\").get(isAuthenticatedAdminOrHR,getMyAttendanceSortedByDate);\n// // filter by date\n// attendanceRouter.route(\"/getAllEmployeeByDate\").post(allEmployeeByDate);\n// attendanceRouter.route(\"/getPresentNumber\").get(getPresentNumber);//number\n// attendanceRouter.route(\"/getpresentbelow\").get(isAuthenticatedAdminOrHR,getPresentEmployeeBelowJobProfile);\n// // get total working hours in a range of date \n// attendanceRouter.route(\"/getTotalWorkingHours\").post(getTotalWorkingHours);\nexports[\"default\"] = attendanceRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/attendanceRoutes.ts?");

/***/ }),

/***/ "./src/routes/authRoutes.ts":
/*!**********************************!*\
  !*** ./src/routes/authRoutes.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst adminController_1 = __webpack_require__(/*! ../controllers/admin/adminController */ \"./src/controllers/admin/adminController.ts\");\nconst employeeController_1 = __webpack_require__(/*! ../controllers/employee/employeeController */ \"./src/controllers/employee/employeeController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst authRouter = (0, express_1.Router)();\nauthRouter.route(\"/admin/login\").post(adminController_1.adminLogin);\nauthRouter.route(\"/login\").post(employeeController_1.loginEmployee);\nauthRouter.route(\"/myprofile\").get(auth_1.isAuthenticatedAdminOrHR, adminController_1.myProfile);\nauthRouter.route(\"/logout\").get(adminController_1.logout);\nauthRouter.route(\"/changePassword\").post(auth_1.isAuthenticatedAdminOrHR, employeeController_1.changePassword);\nexports[\"default\"] = authRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/authRoutes.ts?");

/***/ }),

/***/ "./src/routes/childPartRouter.ts":
/*!***************************************!*\
  !*** ./src/routes/childPartRouter.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst childPartController_1 = __webpack_require__(/*! ../controllers/bomControllers/childPartController */ \"./src/controllers/bomControllers/childPartController.ts\");\nconst childPartRouter = express_1.default.Router();\n// childPartRouter.route(\"/singleUse\").post(deleteUnwanted)\nchildPartRouter.route(\"/\").get(childPartController_1.getAllChildPart);\nchildPartRouter.route(\"/:id\").get(childPartController_1.getChild);\nchildPartRouter.route(\"/add\").post(childPartController_1.addChildPart);\nchildPartRouter.route(\"/:id\").delete(childPartController_1.deleteChildPart);\n//update childpart\nchildPartRouter.route(\"/:id\").patch(childPartController_1.updateChildPart);\n// update childPartName\nchildPartRouter.route(\"/editName/:id\").patch(childPartController_1.editChildPartName);\nexports[\"default\"] = childPartRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/childPartRouter.ts?");

/***/ }),

/***/ "./src/routes/customerRouter.ts":
/*!**************************************!*\
  !*** ./src/routes/customerRouter.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst customController_1 = __webpack_require__(/*! ../controllers/bomControllers/customController */ \"./src/controllers/bomControllers/customController.ts\");\nconst customerRouter = express_1.default.Router();\ncustomerRouter.route(\"/\").get(customController_1.getAllCustomer); // added search and filter with Customer COde , query is name and code;\ncustomerRouter.route(\"/:id\").get(customController_1.getCustomer);\ncustomerRouter.route(\"/add\").post(customController_1.addCustomer);\ncustomerRouter.route(\"/:id\").delete(customController_1.deleteCustomer);\ncustomerRouter.route(\"/:id\").patch(customController_1.updateCoustomer);\nexports[\"default\"] = customerRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/customerRouter.ts?");

/***/ }),

/***/ "./src/routes/departmentRoutes.ts":
/*!****************************************!*\
  !*** ./src/routes/departmentRoutes.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst departmentController_1 = __webpack_require__(/*! ../controllers/employee/departmentController */ \"./src/controllers/employee/departmentController.ts\");\nconst departmentRouter = (0, express_1.Router)();\ndepartmentRouter.route(\"/add\").post(departmentController_1.addDepartment);\ndepartmentRouter.route(\"/updateDepartment/:id\").patch(departmentController_1.updateDepartment);\ndepartmentRouter.route(\"/updateParentDepartment/:id\").patch(departmentController_1.updateParentDepartment);\ndepartmentRouter.route(\"/addParent\").post(departmentController_1.addParentDepartment);\ndepartmentRouter.route(\"/updateHierarchy\").patch(departmentController_1.updateHierarchyDepartment);\ndepartmentRouter.route(\"/getAllParent\").get(departmentController_1.getAllParentDepartment);\ndepartmentRouter.route(\"/getAllDepartment\").get(departmentController_1.getAllDepartment);\ndepartmentRouter.route(\"/getDepartmentByParent\").get(departmentController_1.getDepartmentByParent); //  query departmentName of parent\ndepartmentRouter.route(\"/getJobProfile\").get(departmentController_1.getJobProfileInDepartment); // query departmentName of department\ndepartmentRouter.route(\"/data\").get(departmentController_1.childDepartmentAllData); // query departmentName of department\ndepartmentRouter.route(\"/newData\").get(departmentController_1.newChildDepartmentAllData); // query departmentName of department\ndepartmentRouter.route(\"/delete/:id\").delete(departmentController_1.deleteDepartment);\nexports[\"default\"] = departmentRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/departmentRoutes.ts?");

/***/ }),

/***/ "./src/routes/employeeDocsRouters.ts":
/*!*******************************************!*\
  !*** ./src/routes/employeeDocsRouters.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst multer_1 = __importDefault(__webpack_require__(/*! multer */ \"multer\"));\nconst employeeDocsController_1 = __webpack_require__(/*! ../controllers/employee/employeeDocsController */ \"./src/controllers/employee/employeeDocsController.ts\");\nconst EmployeeDocsRouter = express_1.default.Router();\nconst storage = multer_1.default.memoryStorage();\nconst upload = (0, multer_1.default)({ storage: storage, limits: { fileSize: 1024 * 1024 * 50 } });\nEmployeeDocsRouter.post(\"/upload\", upload.single(\"file\"), employeeDocsController_1.uploadDocument);\nEmployeeDocsRouter.post(\"/uploadImage\", upload.single(\"file\"), employeeDocsController_1.uploadImage);\nEmployeeDocsRouter.get(\"/getProfile/:id\", employeeDocsController_1.getEmployeeProfile);\nEmployeeDocsRouter.get(\"/getProofPicture/:id\", employeeDocsController_1.getProofPicture);\nEmployeeDocsRouter.get(\"/getAll\", employeeDocsController_1.allDocuments);\nEmployeeDocsRouter.get(\"/uploadEmpDocs\", upload.single(\"file\"), employeeDocsController_1.uploadEmpDocs);\n// for aadhar and docs\nEmployeeDocsRouter.post(\"/uploadEmpDoc\", upload.single(\"file\"), employeeDocsController_1.uploadEmpDoc);\n// adding proof picture when we assigning Qr code\nEmployeeDocsRouter.post(\"/uploadproofImage\", upload.single(\"file\"), employeeDocsController_1.uploadProofImage);\n// adding approve picture while approving attendance\nEmployeeDocsRouter.post(\"/uploadApproveImage\", upload.single(\"file\"), employeeDocsController_1.attendanceApproveImage);\n// delete\nEmployeeDocsRouter.post(\"/delete\", employeeDocsController_1.deleteDocs);\n// EmployeeDocsRouter.delete(\"/delete/:filename\",a)\n// get all from bucket\n// EmployeeDocsRouter.get(\"/list\",catchErrorAsync(async (req: Request, res: Response) => {\n//     let r = await s3.listObjectsV2({ Bucket: BUCKET }).promise();\n//     let x = r.Contents ?? []; // Use an empty array as a fallback if r.Contents is undefined\n//     res.send(x);\n//   })\n// );\n// EmployeeDocsRouter.get(\n//   \"/listOne\",\n//   catchErrorAsync(async (req: Request, res: Response) => {\n//     const { id } = req.body;\n//     const docs = await EmployeeDocsModel.findById({ _id: id });\n//     res.send({\n//       success: true,\n//       message: \"successfully get file\",\n//       fileUrl: docs?.document,\n//     });\n//   })\n// );\n// EmployeeDocsRouter.get(\n//   \"/download/:filename\",\n//   catchErrorAsync(async (req: Request, res: Response) => {\n//     const filename = req.params.filename;\n//     // Check if the filename exists in the database\n//     const fileExists = await EmployeeDocsModel.findOne({ file: filename });\n//     if (!fileExists) {\n//       return res.status(404).send(\"Filename does not exist.\");\n//     }\n//     let file = await s3.getObject({ Bucket: BUCKET, Key: filename }).promise();\n//     res.send(file.Body);\n//   })\n// );\n// EmployeeDocsRouter.delete(\n//   \"/delete/:filename\",\n//   catchErrorAsync(async (req: Request, res: Response) => {\n//     const filename = req.params.filename;\n//     // Check if the filename exists in the database\n//     const fileExists = await EmployeeDocsModel.findOne({ file: filename });\n//     if (!fileExists) {\n//       return res.status(404).send(\"Filename does not exist.\");\n//     }\n//     try {\n//       await s3.deleteObject({ Bucket: BUCKET, Key: filename }).promise();\n//       res.send(\"File Deleted Successfully\");\n//     } catch (error) {\n//       res.status(500).send(\"Error deleting file.\");\n//     }\n//   })\n// );\nexports[\"default\"] = EmployeeDocsRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/employeeDocsRouters.ts?");

/***/ }),

/***/ "./src/routes/employeeRoutes.ts":
/*!**************************************!*\
  !*** ./src/routes/employeeRoutes.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst employeeController_1 = __webpack_require__(/*! ../controllers/employee/employeeController */ \"./src/controllers/employee/employeeController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst salaryController_1 = __webpack_require__(/*! ../controllers/employee/salaryController */ \"./src/controllers/employee/salaryController.ts\");\nconst adminController_1 = __webpack_require__(/*! ../controllers/admin/adminController */ \"./src/controllers/admin/adminController.ts\");\n// import { updateField } from \"../controllers/employee/groupController\";\nconst employeeRouter = express_1.default.Router();\nemployeeRouter.route(\"/add\").post(auth_1.isAuthenticatedAdminOrDbManager, employeeController_1.addEmployee);\nemployeeRouter.route(\"/:id\").patch(auth_1.isAuthenticatedAdminOrHR, employeeController_1.updateEmployee)\n    .delete(auth_1.isAuthenticatedAdminOrDbManager, employeeController_1.deleteEmployee);\nemployeeRouter.route(\"/\").post(employeeController_1.getAllEmployee);\nemployeeRouter.route(\"/emp\").get(employeeController_1.getEmployeeByGroupAndJobProfile);\n// some changes\n// assign Qr code\nemployeeRouter.route(\"/assign-qr/:employeeId\").patch(auth_1.isAuthenticatedAdminOrHR, employeeController_1.assignQrCode);\nemployeeRouter.route(\"/qrAssignedByMe\").get(auth_1.isAuthenticatedAdminOrHR, employeeController_1.assignedByMe); // can get limit and page in query \nemployeeRouter.route(\"/getSingle/:employeeId\").get(auth_1.isAuthenticatedAdminOrHR, employeeController_1.getSingle);\nemployeeRouter.route(\"/changePassword\").put(auth_1.isAuthenticatedAdminOrHR, employeeController_1.changePassword);\nemployeeRouter.route(\"/changePasswordAdmin\").put(auth_1.isAuthenticatedAdminOrHR, adminController_1.changePasswordAdmin);\nemployeeRouter.route(\"/newPassword/:employeeId\").put(auth_1.isAuthenticatedAdminOrHR, employeeController_1.newPasswordGenerator);\nemployeeRouter.route(\"/salaryLog/:employeeId\").get(auth_1.isAuthenticatedAdminOrHR, employeeController_1.salaryLogPerEmployee);\nemployeeRouter.route(\"/employeeBarCode\").get(employeeController_1.employeeBarCode);\nemployeeRouter.route(\"/getSalary\").get(salaryController_1.getSalary);\nexports[\"default\"] = employeeRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/employeeRoutes.ts?");

/***/ }),

/***/ "./src/routes/finishedRoutes.ts":
/*!**************************************!*\
  !*** ./src/routes/finishedRoutes.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst finishedItemController_1 = __webpack_require__(/*! ../controllers/bomControllers/finishedItemController */ \"./src/controllers/bomControllers/finishedItemController.ts\");\nconst finishedItemRouter = express_1.default.Router();\n// // for single use\n// finishedItemRouter.route(\"/singleUse\").patch(updateFinishedItemStatus)\n// delete childPart from masterBom\nfinishedItemRouter.route(\"/deleteInMasterBom/:id\").patch(finishedItemController_1.DeleteChildPartFromFinishedItem);\n// added by dakshay\nfinishedItemRouter.route(\"/addBom\").post(finishedItemController_1.addPartInBom);\nfinishedItemRouter.route(\"/finishedItem/:finishedItemId\").get(async (req, resp, next) => {\n    try {\n        const id = req.params.finishedItemId;\n        const orderQuantity = 1;\n        const data = await (0, finishedItemController_1.getBomItemWithQuantity)(req, resp, id, orderQuantity);\n        // const cncData = await getCNCProgramPerFinishedItem(id);\n        resp.status(200).json({\n            success: true,\n            message: \"Getting finished item successfully.\",\n            // newFinishItem:{cncProgram:cncData,...data}});\n            newFinishItem: { ...data }\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n});\n// finishItem groups -----------------------------------------------------------\nfinishedItemRouter.route(\"/addGroup\").post(finishedItemController_1.AddGroup);\nfinishedItemRouter.route(\"/getAllGroup\").post(finishedItemController_1.getAllGroup);\nfinishedItemRouter.route(\"/updateGroup/:groupId\").patch(finishedItemController_1.updateGroup);\nfinishedItemRouter.route(\"/deleteGroup/:groupId\").delete(finishedItemController_1.deleteGroup);\n// for adding finishedItemId in childParts\n// finishedItemRouter.route(\"/singleUse\").get(addFinishedItemInChildPart);\n// finishedItemRouter.route(\"/masterBom/:finishedItemId\").get(getBomData);\n// API for adding a childPart In BETWEEN a master bom \nfinishedItemRouter.route(\"/editMasterBom\").post(finishedItemController_1.addPartInBetweenBom);\n// api for updating process in master bom \nfinishedItemRouter.route(\"/updateProcess/:id\").post(finishedItemController_1.updateProcess);\n// adding filters and searching\nfinishedItemRouter.route(\"/\").post(finishedItemController_1.getAllFinished);\nfinishedItemRouter.route(\"/add\").post(finishedItemController_1.addFinished);\nfinishedItemRouter.route(\"/:id\").get(finishedItemController_1.getFinished).patch(finishedItemController_1.updateFinished).delete(finishedItemController_1.deleteFinishedItem);\n//\n// finishedItemRouter.route(\"/statusUpdate\").post(addBomComplete);\n// Add process in in every childPart\n// finishedItemRouter.route(\"/addProcessInChild\").post(addProcessInEachChildPart);\nexports[\"default\"] = finishedItemRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/finishedRoutes.ts?");

/***/ }),

/***/ "./src/routes/gobalProcessRouter.ts":
/*!******************************************!*\
  !*** ./src/routes/gobalProcessRouter.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst globalProcessController_1 = __webpack_require__(/*! ../controllers/bomControllers/globalProcessController */ \"./src/controllers/bomControllers/globalProcessController.ts\");\nconst globalProcessRouter = express_1.default.Router();\nglobalProcessRouter.route(\"/\").post(globalProcessController_1.getAllGlobalProcess); // added shop WIse filter and name search where search by processName , code or shopName\nglobalProcessRouter.route(\"/add\").post(globalProcessController_1.addGlobalProcess);\nglobalProcessRouter.route(\"/:id\").delete(globalProcessController_1.deleteGlobalProcess).patch(globalProcessController_1.updateGlobalProcess).get(globalProcessController_1.getGlobalProcess);\nexports[\"default\"] = globalProcessRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/gobalProcessRouter.ts?");

/***/ }),

/***/ "./src/routes/godownRouter.ts":
/*!************************************!*\
  !*** ./src/routes/godownRouter.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst godownController_1 = __webpack_require__(/*! ../controllers/bomControllers/godownController */ \"./src/controllers/bomControllers/godownController.ts\");\nconst godownRouter = express_1.default.Router();\ngodownRouter.route(\"/\").get(godownController_1.getAllGodown);\ngodownRouter.route(\"/add\").post(godownController_1.addGodown);\ngodownRouter.route(\"/:id\").get(godownController_1.getGodown).delete(godownController_1.deleteGodown).patch(godownController_1.updateGodown);\nexports[\"default\"] = godownRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/godownRouter.ts?");

/***/ }),

/***/ "./src/routes/groupRoutes.ts":
/*!***********************************!*\
  !*** ./src/routes/groupRoutes.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst groupController_1 = __webpack_require__(/*! ../controllers/employee/groupController */ \"./src/controllers/employee/groupController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst groupRouter = (0, express_1.Router)();\ngroupRouter.route(\"/\").get(groupController_1.allGroup);\ngroupRouter.route(\"/add\").post(groupController_1.addGroup);\ngroupRouter.route(\"/getEmployeeGroup\").get(groupController_1.getEmployeeByGroup); //get employee count by group name\ngroupRouter.route(\"/delete\").delete(auth_1.isAuthenticatedAdminOrDbManager, groupController_1.deleteGroup);\ngroupRouter.route(\"/:id\").patch(auth_1.isAuthenticatedAdminOrDbManager, groupController_1.updateGroup);\ngroupRouter.route(\"/update/hr\").patch(auth_1.isAuthenticatedAdminOrDbManager, groupController_1.updateHierarchy);\ngroupRouter.route(\"/getSingleGroup/:groupId\").get(groupController_1.getSingleGroup);\n// new fields\ngroupRouter.route(\"/newField\").post(groupController_1.addNewField).patch(groupController_1.updateField).delete(groupController_1.deleteField);\n// getting \ngroupRouter.route(\"/getgroupnoparent\").get(groupController_1.getAllGroupsWithNoParent);\ngroupRouter.route(\"/getchildren/:groupId\").get(groupController_1.getChildGroups);\nexports[\"default\"] = groupRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/groupRoutes.ts?");

/***/ }),

/***/ "./src/routes/inventoryRoutes.ts":
/*!***************************************!*\
  !*** ./src/routes/inventoryRoutes.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst InventoryController_1 = __webpack_require__(/*! ../controllers/bomControllers/InventoryController */ \"./src/controllers/bomControllers/InventoryController.ts\");\nconst inventoryRouter = express_1.default.Router();\n// get inventory data\ninventoryRouter.route(\"/\").post(InventoryController_1.getDataInventory);\n// inventory \ninventoryRouter.route(\"/workOrder\").post(InventoryController_1.getAllInventoryByWorkOrder);\n// // testing\n// inventoryRouter.route(\"/testing\").get(testing);\n// inventoryRouter.route(\"/\").post();\nexports[\"default\"] = inventoryRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/inventoryRoutes.ts?");

/***/ }),

/***/ "./src/routes/jobProfileRoutes.ts":
/*!****************************************!*\
  !*** ./src/routes/jobProfileRoutes.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst jobProfileController_1 = __webpack_require__(/*! ../controllers/employee/jobProfileController */ \"./src/controllers/employee/jobProfileController.ts\");\nconst departmentController_1 = __webpack_require__(/*! ../controllers/employee/departmentController */ \"./src/controllers/employee/departmentController.ts\");\nconst jobProfileRoute = (0, express_1.Router)();\n// get jobProfile with no parent\njobProfileRoute.route(\"/getjobprofilewithnoparent\").get(jobProfileController_1.getAllJobProfileWithNoParent);\njobProfileRoute.route(\"/getchildjobprofile/:jobprofielId\").get(jobProfileController_1.getChildJobProfile);\n// for empty all child and parent fields in all jobProfile\njobProfileRoute.route(\"/removeParentAndChild\").get(jobProfileController_1.emptyAllChildAndParentFields);\njobProfileRoute.route(\"/\").get(jobProfileController_1.allJobProfile);\njobProfileRoute.route(\"/add\").post(jobProfileController_1.addJobProfile);\njobProfileRoute.route(\"/delete/:id\").delete(jobProfileController_1.deleteJobProfile);\njobProfileRoute.route(\"/updateHierarchy\").patch(jobProfileController_1.updateHierarchy);\njobProfileRoute.route(\"/update/:id\").patch(jobProfileController_1.updateJobProfile);\njobProfileRoute.route(\"/updateJobDescription\").patch(jobProfileController_1.updateJobDescription);\njobProfileRoute.route(\"/addDepartment\").patch(departmentController_1.addDepartmentToJobProfile);\njobProfileRoute.route(\"/deleteDepartment\").delete(departmentController_1.deleteDepartmentToJobProfile);\njobProfileRoute.route(\"/:id\").get(jobProfileController_1.getSingleJobProfile);\njobProfileRoute.route(\"/suggestion/:jobprofileId\").get(jobProfileController_1.suggestionForJobProfile);\nexports[\"default\"] = jobProfileRoute;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/jobProfileRoutes.ts?");

/***/ }),

/***/ "./src/routes/leaveRoutes.ts":
/*!***********************************!*\
  !*** ./src/routes/leaveRoutes.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst LeaveController_1 = __webpack_require__(/*! ../controllers/employee/LeaveController */ \"./src/controllers/employee/LeaveController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst leaveRouter = (0, express_1.Router)();\nleaveRouter.route(\"/\").post(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.requestLeave);\nleaveRouter.route(\"/pending\").get(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.getPendingLeaveRequest); //1\nleaveRouter.route(\"/accepted\").get(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.getAcceptedLeaveRequest);\nleaveRouter.route(\"/approved\").get(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.getApprovedLeaveRequest);\nleaveRouter.route(\"/rejected\").get(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.getRejectedLeaveRequest); //3\nleaveRouter.route(\"/all\").get(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.getAllLeaveAndGatePass);\n// get leave by employee\nleaveRouter.route(\"/myleave\").get(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.getLeaveRequestByEmployee);\n// approve leave\nleaveRouter.route(\"/acceptleave\").patch(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.updateLeaveRequestStatusAcceptedOrReject); //2\nleaveRouter.route(\"/approveleave\").patch(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.approveLeaveRequestOrReject); //3\n// approve gatePass\nleaveRouter.route(\"/acceptgatepass\").patch(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.updateGatePassRequestStatusAcceptedOrReject);\nleaveRouter.route(\"/approvegatepass\").patch(auth_1.isAuthenticatedAdminOrHR, LeaveController_1.approveGatePassRequestOrReject);\n// get all gatePassRequest\n// leaveRouter.route(\"/pendinggatepass\").get(isAuthenticatedAdminOrHR,getPendingGatePassRequest);\n// leaveRouter.route(\"/acceptedgatepass\").get(isAuthenticatedAdminOrHR,getAcceptedGatePassRequest);\n// leaveRouter.route(\"/approvedgatepass\").get(isAuthenticatedAdminOrHR,getApprovedGatePassRequest);\n// leaveRouter.route(\"/rejectedgatepass\").get(isAuthenticatedAdminOrHR,getRejectedGatePassRequest);\n// get leave data with filter\n// leaveRouter.route(\"/leavegatepass\").get(getLeaveData);\nexports[\"default\"] = leaveRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/leaveRoutes.ts?");

/***/ }),

/***/ "./src/routes/loggedInUserHistoryRouter.ts":
/*!*************************************************!*\
  !*** ./src/routes/loggedInUserHistoryRouter.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst loggInHistoryController_1 = __webpack_require__(/*! ../controllers/employee/loggInHistoryController */ \"./src/controllers/employee/loggInHistoryController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst loggedInUserHistoryRouter = (0, express_1.Router)();\nloggedInUserHistoryRouter.get(\"/\", auth_1.isAuthenticatedAdminOrHR, loggInHistoryController_1.getLoggedInUserHistory);\nloggedInUserHistoryRouter.delete(\"/:id\", auth_1.isAuthenticatedAdminOrHR, loggInHistoryController_1.deleteLoginHistory);\nexports[\"default\"] = loggedInUserHistoryRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/loggedInUserHistoryRouter.ts?");

/***/ }),

/***/ "./src/routes/machineRouter.ts":
/*!*************************************!*\
  !*** ./src/routes/machineRouter.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst machineController_1 = __webpack_require__(/*! ../controllers/bomControllers/machineController */ \"./src/controllers/bomControllers/machineController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst multer_1 = __importDefault(__webpack_require__(/*! multer */ \"multer\"));\nconst machineRouter = express_1.default.Router();\nconst storage = multer_1.default.memoryStorage();\nconst upload = (0, multer_1.default)({ storage: storage });\nmachineRouter.route(\"/\").post(machineController_1.getAllMachine); // added filter and search , name can be used for machineName , code or processName or code and Other Porcess is used to filter\nmachineRouter.route(\"/add\").post(machineController_1.addMachine);\n// assign qr code to a machine\nmachineRouter.route(\"/assignQr/:id\").post(auth_1.isAuthenticatedAdminOrHR, machineController_1.assignQrToMachine);\n// get machine data by QR code\nmachineRouter.route(\"/getMachineByQr\").post(machineController_1.getMachineByQrCode);\nmachineRouter.post(\"/get/uploadMachineProofImage\", upload.single(\"file\"), machineController_1.uploadMachineProofImage);\nmachineRouter.post(\"/uploadMachineImage\", upload.single(\"file\"), machineController_1.uploadMachineImage);\nmachineRouter.route(\"/:id\").get(machineController_1.getMachine).patch(machineController_1.updateMachine).delete(machineController_1.deleteMachine);\nexports[\"default\"] = machineRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/machineRouter.ts?");

/***/ }),

/***/ "./src/routes/otpRouter.ts":
/*!*********************************!*\
  !*** ./src/routes/otpRouter.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst otpController_1 = __webpack_require__(/*! ../controllers/employee/otpController */ \"./src/controllers/employee/otpController.ts\");\nconst otpRouter = (0, express_1.Router)();\notpRouter.get(\"/getotp\", otpController_1.getOtp);\notpRouter.get(\"/verifyotp\", otpController_1.verifyOtp);\nexports[\"default\"] = otpRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/otpRouter.ts?");

/***/ }),

/***/ "./src/routes/planningRoutes.ts":
/*!**************************************!*\
  !*** ./src/routes/planningRoutes.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst planningController_1 = __webpack_require__(/*! ../controllers/bomControllers/planningController */ \"./src/controllers/bomControllers/planningController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst planningRouter = express_1.default.Router();\n// add empty planning sheet per month of each child Part\nplanningRouter.route(\"/addEmpty\").post(planningController_1.addPlanningSheet);\nplanningRouter.route(\"/getAll\").post(planningController_1.getAllPlanning);\nplanningRouter.route(\"/update/:planningId\").patch(auth_1.isAuthenticatedAdminOrHR, planningController_1.updatePlanning);\n// delete Planning personal use only\nplanningRouter.route(\"/delete\").delete(planningController_1.deletePlanningPerMonth);\n// planningRouter.route(\"/checking\").post(checking);\nexports[\"default\"] = planningRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/planningRoutes.ts?");

/***/ }),

/***/ "./src/routes/productionSlipRoutes.ts":
/*!********************************************!*\
  !*** ./src/routes/productionSlipRoutes.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst productionSlipController_1 = __webpack_require__(/*! ../controllers/bomControllers/productionSlipController */ \"./src/controllers/bomControllers/productionSlipController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst productionRouter = express_1.default.Router();\n//add a completed ProductionSlip     // Manual\nproductionRouter\n    .route(\"/addCompletedSlip\")\n    .post(auth_1.isAuthenticatedAdminOrHR, async (req, resp, next) => {\n    if (req.employee || req.admin) {\n        try {\n            let name = \"\";\n            let employeeId;\n            let status = \"manual\";\n            if (req.employee) {\n                name = req.employee.name;\n                employeeId = req.employee._id;\n            }\n            if (req.admin) {\n                name = req.admin.name;\n                employeeId = req.admin._id;\n            }\n            const data = await (0, productionSlipController_1.addCompletedSlip)({\n                ...req.body,\n                name,\n                status,\n                employeeId,\n            });\n            resp.status(200).json(data);\n        }\n        catch (error) {\n            console.log(error);\n            resp.sendStatus(400);\n        }\n    }\n    else {\n        return resp.status(403).json({\n            success: false,\n            message: \"Not Authorised.\",\n        });\n    }\n});\n// get productionSlip\nproductionRouter\n    .route(\"/prd/:productionSlipNumber\")\n    .get(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.getProductionSlipData);\nproductionRouter\n    .route(\"/add\")\n    .post(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.addProductionSlip);\n// add multiple production slips\nproductionRouter\n    .route(\"/addMultiple\")\n    .post(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.addMultipleProductionSlips);\nproductionRouter\n    .route(\"/employeeSuggestion/:productionSlipNumber\")\n    .get(productionSlipController_1.employeeSuggestions);\nproductionRouter\n    .route(\"/machineSuggestion/:productionSlipNumber\")\n    .get(productionSlipController_1.machineSuggestions);\n// add machines and employees to a production slip\nproductionRouter\n    .route(\"/addEmployeeMachine\")\n    .post(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.addEmployeeAndMachine);\n// auto selected machines and employees\nproductionRouter\n    .route(\"/autoSelect/:productionSlipNumber\")\n    .get(productionSlipController_1.getLastWorkingData);\n// finishing a production Slip\n// productionRouter.route(\"/editLog/:productionSlipNumber\").patch(editLogProductionSlip);\n// get active production slips  add query for getting logs and active ProductionSlip    status == active || completed\nproductionRouter\n    .route(\"/getActive\")\n    .get(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.gettingAllActiveProductionSlip);\n// get all production slips with filters\nproductionRouter\n    .route(\"/getAll\")\n    .post(productionSlipController_1.gettingAllActiveProductionSlipAllWorkOrder);\nproductionRouter\n    .route(\"/excel\")\n    .get(productionSlipController_1.productionSlipExcel2);\nproductionRouter\n    .route(\"/workOrderexcel\")\n    .get(productionSlipController_1.productionSlipExcelPerWorkOrder);\n// get active and idle machines\nproductionRouter\n    .route(\"/getIdleActiveMachines\")\n    .post(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.activeIdleMachines);\n// getting active and idle employees\nproductionRouter\n    .route(\"/getIdleActiveEmployees\") // added last productionSlip with employee details\n    .get(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.activeIdleEmployees);\n// get all childPart With production slip count\nproductionRouter\n    .route(\"/getAllChildPartWithSlip/:workOrderId\")\n    .post(auth_1.isAuthenticatedAdminOrHR, productionSlipController_1.getChildPartWithProductionSlipCount);\n// API for getting multiple productionSlips details by an Array of productionSlip\nproductionRouter.route(\"/multiProductionSlip\").post(productionSlipController_1.multiProductionSlipEnglish);\nproductionRouter.route(\"/multiProductionSlipHindi\").post(productionSlipController_1.multiProductionSlip);\n// APi for counting Print Of production\nproductionRouter.route(\"/updatePdfCount\").patch(productionSlipController_1.countPdfPrint);\n// Edit Production In Completed ProductionSlip\nproductionRouter\n    .route(\"/editProduction/:productionSlipNumber\")\n    .patch(productionSlipController_1.EditProduction);\n// update status of production slip\nproductionRouter\n    .route(\"/updateStatus/:productionSlipNumber\")\n    .patch(productionSlipController_1.updateProductionSlipStatus);\n// STATUS CARDS\nproductionRouter\n    .route(\"/statusCards\")\n    .get(productionSlipController_1.statusCards);\nexports[\"default\"] = productionRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/productionSlipRoutes.ts?");

/***/ }),

/***/ "./src/routes/productivityReportRoutes.ts":
/*!************************************************!*\
  !*** ./src/routes/productivityReportRoutes.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst productivityReportController_1 = __webpack_require__(/*! ../controllers/bomControllers/productivityReportController */ \"./src/controllers/bomControllers/productivityReportController.ts\");\nconst productivityReportRouter = express_1.default.Router();\nproductivityReportRouter.route(\"/getReport\").post(productivityReportController_1.getReportPerEmployee);\nproductivityReportRouter.route(\"/getMachineReport\").post(productivityReportController_1.getNewReportPerMachine);\nproductivityReportRouter.route(\"/getReportApp\").post(productivityReportController_1.EmployeeReport);\nproductivityReportRouter.route(\"/singleEmployeeReport\").post(async (req, resp, next) => {\n    try {\n        const data = await (0, productivityReportController_1.SingleEmployeeReport)(req.body);\n        resp.status(200).json({ ...data });\n    }\n    catch (error) {\n        resp.sendStatus(400);\n    }\n});\nproductivityReportRouter.route(\"/singleMachineReport\").post(async (req, resp, next) => {\n    try {\n        const { machineId, date } = req.body;\n        const data = await (0, productivityReportController_1.MachineReport)({ machineId, date });\n        resp.status(200).json({ ...data });\n    }\n    catch (error) {\n        console.log(error);\n        resp.sendStatus(500);\n    }\n});\nexports[\"default\"] = productivityReportRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/productivityReportRoutes.ts?");

/***/ }),

/***/ "./src/routes/quizRoutes.ts":
/*!**********************************!*\
  !*** ./src/routes/quizRoutes.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst quizController_1 = __webpack_require__(/*! ../controllers/employee/quizController */ \"./src/controllers/employee/quizController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst quizRouter = (0, express_1.Router)();\nquizRouter.route(\"/getQuiz\").post(quizController_1.getQuizQuestion);\nquizRouter.route(\"/submitAnswer\").post(auth_1.isAuthenticatedAdminOrHR, quizController_1.submitAnswer);\nquizRouter.route(\"/addQuestion\").post(auth_1.isAuthenticatedAdminOrHR, quizController_1.addQuestion);\nquizRouter\n    .route(\"/updateQuestion\")\n    .patch(auth_1.isAuthenticatedAdminOrHR, quizController_1.updateQuestion);\nquizRouter\n    .route(\"/updateQuestion\")\n    .delete(auth_1.isAuthenticatedAdminOrHR, quizController_1.deleteQuestion);\nexports[\"default\"] = quizRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/quizRoutes.ts?");

/***/ }),

/***/ "./src/routes/rawMaterialRouter.ts":
/*!*****************************************!*\
  !*** ./src/routes/rawMaterialRouter.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst rawMaterialController_1 = __webpack_require__(/*! ../controllers/bomControllers/rawMaterialController */ \"./src/controllers/bomControllers/rawMaterialController.ts\");\nconst rawMaterialRouter = express_1.default.Router();\n// group router\nrawMaterialRouter.route(\"/addGroup\").post(rawMaterialController_1.createGroup);\nrawMaterialRouter.route(\"/getGroups\").post(rawMaterialController_1.getAllGroup);\nrawMaterialRouter.route(\"/updateGroup/:groupId\").patch(rawMaterialController_1.updateGroup);\nrawMaterialRouter.route(\"/deleteGroup/:groupId\").delete(rawMaterialController_1.deleteGroup);\n//----------------------------------------\n// get childParts which consumed this raw material whose Id we are getting in params\nrawMaterialRouter.route(\"/whereConsumed/:id\").get(rawMaterialController_1.getChildPartByRawMaterial);\nrawMaterialRouter.route(\"/\").get(rawMaterialController_1.getAllRawMaterial); // added search and filter with unit query is name and unit\nrawMaterialRouter.route(\"/add\").post(rawMaterialController_1.addRawMaterial);\nrawMaterialRouter.route(\"/:id\").get(rawMaterialController_1.getRawMaterial).delete(rawMaterialController_1.deleteRawMaterial).patch(rawMaterialController_1.updateRawMaterial);\nexports[\"default\"] = rawMaterialRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/rawMaterialRouter.ts?");

/***/ }),

/***/ "./src/routes/salaryReportRoutes.ts":
/*!******************************************!*\
  !*** ./src/routes/salaryReportRoutes.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst salaryReportController_1 = __webpack_require__(/*! ../controllers/bomControllers/salaryReportController */ \"./src/controllers/bomControllers/salaryReportController.ts\");\nconst salaryReportRouter = express_1.default.Router();\nsalaryReportRouter.route(\"/\").post(salaryReportController_1.getSalaryReport);\nsalaryReportRouter.route(\"/singlePartCostReport/:partId\").get(salaryReportController_1.getSinglePartCostReport);\nexports[\"default\"] = salaryReportRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/salaryReportRoutes.ts?");

/***/ }),

/***/ "./src/routes/salaryRouter.ts":
/*!************************************!*\
  !*** ./src/routes/salaryRouter.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst salaryController_1 = __webpack_require__(/*! ../controllers/employee/salaryController */ \"./src/controllers/employee/salaryController.ts\");\nconst salaryRouter = express_1.default.Router();\nsalaryRouter.route(\"/salary\").post(salaryController_1.newGetSalary);\nsalaryRouter.route(\"/month-salary\").post(salaryController_1.getMonthlySalary);\nsalaryRouter.route(\"/forAplicalbeMonth\").get(salaryController_1.month);\nexports[\"default\"] = salaryRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/salaryRouter.ts?");

/***/ }),

/***/ "./src/routes/scanSlipRouter.ts":
/*!**************************************!*\
  !*** ./src/routes/scanSlipRouter.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst scanSlipController_1 = __webpack_require__(/*! ../controllers/employee/scanSlipController */ \"./src/controllers/employee/scanSlipController.ts\");\nconst multer_1 = __importDefault(__webpack_require__(/*! multer */ \"multer\"));\nconst scanSlipRouter = express_1.default.Router();\nconst storage = multer_1.default.memoryStorage();\nconst upload = (0, multer_1.default)({ storage: storage });\n// scanSlipRouter.post(\"/add\", upload.single(\"file\"), createScanSlip);\nscanSlipRouter.post(\"/add\", upload.single(\"file\"), scanSlipController_1.addOrUpdateScanSlip);\nscanSlipRouter.get(\"/\", scanSlipController_1.getScannedSlip);\nexports[\"default\"] = scanSlipRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/scanSlipRouter.ts?");

/***/ }),

/***/ "./src/routes/shopRoutes.ts":
/*!**********************************!*\
  !*** ./src/routes/shopRoutes.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst shopController_1 = __webpack_require__(/*! ../controllers/bomControllers/shopController */ \"./src/controllers/bomControllers/shopController.ts\");\nconst shopRouter = express_1.default.Router();\nshopRouter.route(\"/add\").post(shopController_1.addShop);\nshopRouter.route(\"/\").get(shopController_1.getAllShop);\nshopRouter.route(\"/:id\").get(shopController_1.getSingleShop).patch(shopController_1.updateShop).delete(shopController_1.deleteShop);\nexports[\"default\"] = shopRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/shopRoutes.ts?");

/***/ }),

/***/ "./src/routes/trainingRoutes.ts":
/*!**************************************!*\
  !*** ./src/routes/trainingRoutes.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst multer_1 = __importDefault(__webpack_require__(/*! multer */ \"multer\"));\nconst trainingController_1 = __webpack_require__(/*! ../controllers/employee/trainingController */ \"./src/controllers/employee/trainingController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst trainingRoutes = (0, express_1.Router)();\nconst storage = multer_1.default.memoryStorage();\nconst upload = (0, multer_1.default)({ storage: storage });\ntrainingRoutes.get(\"/\", auth_1.isAuthenticatedAdminOrHR, trainingController_1.getTraining);\ntrainingRoutes.post(\"/addLinks\", trainingController_1.addTrainingLinks);\ntrainingRoutes.post(\"/add\", upload.single(\"file\"), trainingController_1.addTrainingDocs);\ntrainingRoutes.get(\"/:id\", trainingController_1.getTrainingData);\ntrainingRoutes.delete(\"/:id\", trainingController_1.deleteTrainingData);\nexports[\"default\"] = trainingRoutes;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/trainingRoutes.ts?");

/***/ }),

/***/ "./src/routes/v2AttendanceRouter.ts":
/*!******************************************!*\
  !*** ./src/routes/v2AttendanceRouter.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst multer_1 = __importDefault(__webpack_require__(/*! multer */ \"multer\"));\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst v2attendanceController_1 = __webpack_require__(/*! ../controllers/employee/v2attendanceController */ \"./src/controllers/employee/v2attendanceController.ts\");\nconst v2AttendanceRouter = (0, express_1.Router)();\nconst storage = multer_1.default.memoryStorage();\nconst upload = (0, multer_1.default)({ storage: storage });\nv2AttendanceRouter.post(\"/\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.absentAndPresentEmployee);\nv2AttendanceRouter.get(\"/singleEmployee/:employeeId\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.singleEmployeeAttendance);\nv2AttendanceRouter.get(\"/myAttendance\", v2attendanceController_1.myAttendance);\nv2AttendanceRouter.get(\"/getPunchInPunchOut\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.getPunchRecords);\nv2AttendanceRouter.post(\"/getPunchInPunchOutNumber\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.getPunchRecordsNumber);\nv2AttendanceRouter.get(\"/staffAttendance\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.employeeStaffAttendance);\nv2AttendanceRouter.get(\"/groupPresent\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.getGroupPunchRecords);\nv2AttendanceRouter.get(\"/ownApproved\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.getMyApprovedAttendance);\nv2AttendanceRouter.post(\"/addAttendance\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.addAttendanceWithEmployeeId);\nv2AttendanceRouter.post(\"/uploadApproveImage\", upload.single(\"file\"), v2attendanceController_1.attendanceApproveImage);\nv2AttendanceRouter.patch(\"/approveAttendance\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.updateAttendance);\nv2AttendanceRouter.post(\"/find-employee-by-Qr\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.getEmployeeByQRCode);\n// for admin and attendance manager only\nv2AttendanceRouter.post(\"/addPunches/:id\", auth_1.isAuthenticatedAdminOrAttendanceManager, v2attendanceController_1.addPunchs);\nv2AttendanceRouter.patch(\"/updatePunches/:id\", auth_1.isAuthenticatedAdminOrAttendanceManager, v2attendanceController_1.updatePunchs);\nv2AttendanceRouter.delete(\"/deletePunches/:id\", auth_1.isAuthenticatedAdminOrAttendanceManager, v2attendanceController_1.deletePunchs);\nv2AttendanceRouter.post(\"/shopFilter\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.shopFilter);\n// for  supervisor\nv2AttendanceRouter.patch(\"/updatePunchOut/:id\", auth_1.isAuthenticatedSupervisor, v2attendanceController_1.updatePunchOut);\nv2AttendanceRouter.get(\"/employeeUnderMe\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.pendingUnderMe);\n// add attendance for shift systems     \nv2AttendanceRouter.post(\"/v2/addAttendance\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.addAttendanceWithEmployeeIdV2);\nv2AttendanceRouter.get(\"/v2/groupview\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.groupOverView);\nv2AttendanceRouter.get(\"/v2/departmentOverview\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.departmentOverView);\nv2AttendanceRouter.get(\"/v2/shopOverview\", auth_1.isAuthenticatedAdminOrHR, v2attendanceController_1.shopOverView);\nv2AttendanceRouter.get(\"/OneDate\", v2attendanceController_1.updateAttendanceDetails);\nexports[\"default\"] = v2AttendanceRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/v2AttendanceRouter.ts?");

/***/ }),

/***/ "./src/routes/workOrderRouter.ts":
/*!***************************************!*\
  !*** ./src/routes/workOrderRouter.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst workOrderController_1 = __webpack_require__(/*! ../controllers/bomControllers/workOrderController */ \"./src/controllers/bomControllers/workOrderController.ts\");\nconst auth_1 = __webpack_require__(/*! ../middleware/auth */ \"./src/middleware/auth.ts\");\nconst workOrderRouter = express_1.default.Router();\n// added filters and search and sorting by date    \nworkOrderRouter.route(\"/\").get(auth_1.isAuthenticatedAdminOrHR, workOrderController_1.getAllWorkOrder);\nworkOrderRouter.route(\"/add/:finishedItemId\").post(workOrderController_1.addWorkOrder);\n// for testing \nworkOrderRouter.route(\"/updateConsumption/:id\").patch(workOrderController_1.updateConsumedItemInMasterBomb);\nworkOrderRouter.route(\"/homeApp/workOrders\").get(workOrderController_1.getAllWorkOrderWithProductionSlip);\n// update master bom in work order\n// workOrderRouter.route(\"/updateConsumption/:id\").patch(updateInMasterBom);\nworkOrderRouter.route(\"/addNewChild/:id\").patch(workOrderController_1.addChildPartInMasterBom);\nworkOrderRouter.route(\"/:id\").get(workOrderController_1.getWorkOrder);\n// edit work order quantity\nworkOrderRouter.route(\"/:id\").patch(workOrderController_1.updateWorkOrder).delete(workOrderController_1.deleteWorkOrder);\n// change process in workOrder  \nworkOrderRouter.route(\"/updateProcess/:id\").patch(workOrderController_1.updateProcessInWorkOrder);\n// not for use \nworkOrderRouter.route(\"/changeWorkOrder\").post(workOrderController_1.changeWorkOrderInProductionSlip);\nexports[\"default\"] = workOrderRouter;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/workOrderRouter.ts?");

/***/ }),

/***/ "./src/routes/workingDayRouter.ts":
/*!****************************************!*\
  !*** ./src/routes/workingDayRouter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.workingDayRouter = void 0;\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst workingDayController_1 = __webpack_require__(/*! ../controllers/employee/workingDayController */ \"./src/controllers/employee/workingDayController.ts\");\nexports.workingDayRouter = (0, express_1.Router)();\nexports.workingDayRouter.route(\"/\").get(workingDayController_1.getMonthData);\nexports.workingDayRouter.route(\"/add\").post(workingDayController_1.addWorkingDay);\nexports.workingDayRouter.route(\"/update\").patch(workingDayController_1.updateWorkingDay);\nexports.workingDayRouter.route(\"/delete\").delete(workingDayController_1.deleteMonth);\n\n\n//# sourceURL=webpack://chawla-ispat/./src/routes/workingDayRouter.ts?");

/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst dotenv_1 = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst connectDb_1 = __webpack_require__(/*! ./database/connection/connectDb */ \"./src/database/connection/connectDb.ts\");\n(0, dotenv_1.config)({ path: path_1.default.join(__dirname, \"..\", \"public/.env\") });\n// addQRCodeToRandomEntries()1\n// listen\nconst PORT = process.env.PORT || 5050;\napp_1.server.listen(PORT, () => {\n    (0, connectDb_1.connectDB)();\n    const address = app_1.server.address();\n    console.log(`Server and WebSocket Server running on ${JSON.stringify(address)}`);\n});\n//  new checking \n// app.listen(process.env.PORT,()=>{\n//     //connecting database\n//     \n//     console.log(`server is running on port http://localhost:${process.env.PORT}`)\n// })\n\n\n//# sourceURL=webpack://chawla-ispat/./src/server.ts?");

/***/ }),

/***/ "./src/translate.ts":
/*!**************************!*\
  !*** ./src/translate.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.translateEnglishToHindi = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"axios\"));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst router = express_1.default.Router();\nrouter.route(\"/test\").get(async (req, resp, next) => {\n    const string = req.query.text;\n    const encodedParams = new URLSearchParams();\n    encodedParams.set('q', string);\n    encodedParams.set('target', 'hi');\n    encodedParams.set('source', 'en');\n    const options = {\n        method: 'POST',\n        url: 'https://google-translate1.p.rapidapi.com/language/translate/v2',\n        headers: {\n            'content-type': 'application/x-www-form-urlencoded',\n            'Accept-Encoding': 'application/gzip',\n            'X-RapidAPI-Key': '2c17824e1fmsh0d03e1d372e5ab1p1b3b16jsn6b6cd5a8ffc0',\n            'X-RapidAPI-Host': 'google-translate1.p.rapidapi.com'\n        },\n        data: encodedParams,\n    };\n    try {\n        const response = await axios_1.default.request(options);\n        console.log(response.data);\n        resp.status(200).json({ hindi: response.data.data.translations[0].translatedText, data: response.data });\n    }\n    catch (error) {\n        console.error(error);\n    }\n});\nconst translateEnglishToHindi = async (text) => {\n    const encodedParams = new URLSearchParams();\n    encodedParams.set('q', text);\n    encodedParams.set('target', 'hi');\n    encodedParams.set('source', 'en');\n    const options = {\n        method: 'POST',\n        url: 'https://google-translate1.p.rapidapi.com/language/translate/v2',\n        headers: {\n            'content-type': 'application/x-www-form-urlencoded',\n            'Accept-Encoding': 'application/gzip',\n            'X-RapidAPI-Key': '2c17824e1fmsh0d03e1d372e5ab1p1b3b16jsn6b6cd5a8ffc0',\n            'X-RapidAPI-Host': 'google-translate1.p.rapidapi.com'\n        },\n        data: encodedParams,\n    };\n    try {\n        const response = await axios_1.default.request(options);\n        return response.data.data.translations[0].translatedText;\n    }\n    catch (error) {\n        console.error(error);\n    }\n};\nexports.translateEnglishToHindi = translateEnglishToHindi;\nexports[\"default\"] = router;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/translate.ts?");

/***/ }),

/***/ "./src/utils/catchAsyncError.ts":
/*!**************************************!*\
  !*** ./src/utils/catchAsyncError.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst catchErrorAsync = (func) => (req, resp, next) => {\n    Promise.resolve(func(req, resp, next)).catch(next);\n};\nexports[\"default\"] = catchErrorAsync;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/utils/catchAsyncError.ts?");

/***/ }),

/***/ "./src/utils/sendCookie.ts":
/*!*********************************!*\
  !*** ./src/utils/sendCookie.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sendCookieAdmin = void 0;\nconst jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\"));\nconst employeeDocsModel_1 = __importDefault(__webpack_require__(/*! ../database/models/employeeDocsModel */ \"./src/database/models/employeeDocsModel.ts\"));\nconst sendCookieAdmin = async (resp, user, message, statusCode = 200) => {\n    const token = jsonwebtoken_1.default.sign({ user: user._id }, process.env.JWT_KEY);\n    const userPicture = await employeeDocsModel_1.default.findOne({ employeeId: user._id });\n    if (user?.email === \"dev@gmail.com\") {\n        return resp\n            .status(statusCode)\n            .cookie(\"token\", token, {\n            maxAge: 500000 * 60 * 60 * 1000,\n            httpOnly: true,\n            secure: true,\n            sameSite: \"none\", // Set the appropriate SameSite policy based on your requirements\n        })\n            .json({\n            success: true,\n            profilePicture: userPicture?.profilePicture,\n            user,\n            message,\n            cookie: \"Cookie saved successfully.\"\n        });\n    }\n    return resp\n        .status(statusCode)\n        .cookie(\"token\", token, {\n        maxAge: 5 * 60 * 60 * 1000,\n        httpOnly: true,\n        secure: true,\n        sameSite: \"none\", // Set the appropriate SameSite policy based on your requirements\n    })\n        .json({\n        success: true,\n        profilePicture: userPicture?.profilePicture,\n        user,\n        message,\n        cookie: \"Cookie saved successfully.\"\n    });\n};\nexports.sendCookieAdmin = sendCookieAdmin;\n\n\n//# sourceURL=webpack://chawla-ispat/./src/utils/sendCookie.ts?");

/***/ }),

/***/ "aws-sdk":
/*!**************************!*\
  !*** external "aws-sdk" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("aws-sdk");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "bcrypt":
/*!*************************!*\
  !*** external "bcrypt" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("bcrypt");

/***/ }),

/***/ "cookie-parser":
/*!********************************!*\
  !*** external "cookie-parser" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("cookie-parser");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("cors");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("dotenv");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("express");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("jsonwebtoken");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("mongoose");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("multer");

/***/ }),

/***/ "node-cron":
/*!****************************!*\
  !*** external "node-cron" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node-cron");

/***/ }),

/***/ "qrcode":
/*!*************************!*\
  !*** external "qrcode" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("qrcode");

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("socket.io");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("uuid");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server.ts");
/******/ 	
/******/ })()
;